THIS HELP GUIDE IS OUT OF DATE.
NEEDS REWRITING TO INCLUDE GLSL, AND THE UNIFORMS


WEBGPU COMPUTE SHADER EDITOR - QUICK START GUIDE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

OVERVIEW
â”€â”€â”€â”€â”€â”€â”€â”€
This is a live WebGPU compute shader editor with real-time graphics and audio
output. You write WGSL shaders that run on your GPU to generate both visuals
and audio simultaneously.

EDITOR TABS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“„ BOILERPLATE - Auto-generated shader setup (read-only)
   Contains all uniforms, buffers, and constants. Updated when settings change.

ğŸ¨ GRAPHICS - Your graphics shader code
   Entry point: graphics_main(@builtin(global_invocation_id) id: vec3<u32>)
   Write to: textureOutput (resizable RGBA8)
   Workgroup size: 8x8x1 (optimized for 2D rendering)

ğŸ”Š AUDIO - Your audio synthesis shader code
   Entry point: audio_main(@builtin(global_invocation_id) id: vec3<u32>)
   Write to: audioBuffer (stereo interleaved)
   Workgroup size: 128x1x1 (optimized for 1D audio)
   Phase accumulation handled on GPU for smooth frequency changes

âš¡ JAVASCRIPT - Runtime control code
   init() - Called once when you press Play
   enterframe(state, api) - Called every visual frame (~60 FPS)
   Use this to animate uniforms, respond to mouse input, etc.

â“ HELP - This guide + WGSL cheatsheet

CONTROLS
â”€â”€â”€â”€â”€â”€â”€â”€
â–¶/â¸ - Play/Pause audio and shader execution
âŸ³ - Reload shader (also: F5 or Ctrl+S in any editor)
Volume Slider - Control audio output volume
Quality Slider - Pixel size (1x, 2x, 3x, 4x, 6x, 8x)
Ctrl+Space - Toggle play/pause from any editor

AVAILABLE UNIFORMS (read-only in your shaders)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
struct Uniforms {
    time: f32,              // Total elapsed time in seconds
    audioCurrentTime: f32,  // Web Audio API current time
    audioPlayTime: f32,     // Time since playback started
    audioFractTime: f32,    // Fractional part of audio time
    audioFrame: u32,        // Current audio block number
    mouseX: f32,            // Mouse X position [0, 1] (set from JS)
    mouseY: f32,            // Mouse Y position [0, 1] (set from JS)
    frequency: f32,         // Audio frequency in Hz (set from JS)
    user3: f32,             // Custom uniform 3 (set from JS)
    user4: f32,             // Custom uniform 4 (set from JS)
}

Access in shaders: uniforms.time, uniforms.mouseX, etc.

AVAILABLE BUFFERS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@group(0) @binding(1) var<storage, read_write> computeBuffer: array<f32>;
  - 64KB shared buffer for passing data between graphics and audio passes

@group(0) @binding(2) var textureOutput: texture_storage_2d<rgba8unorm, write>;
  - Resizable texture for graphics output

@group(0) @binding(3) var<storage, read_write> audioBuffer: array<f32>;
  - Stereo audio buffer (interleaved L/R channels)
  - Size depends on sample rate (typically 2205 or 2400 samples per block)

@group(0) @binding(4) var<storage, read_write> phaseState: array<f32>;
  - Single float for persistent phase accumulation (audio synthesis)

JAVASCRIPT API
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
In your enterframe() function, you have access to:

api.time - Current time in seconds
api.audioFrame - Current audio block number
api.mouse.x, api.mouse.y - Mouse position [0, 1]
api.uniforms.setFloat(index, value) - Set uniform values:
  - Index 5: mouseX
  - Index 6: mouseY
  - Index 7: frequency (Hz)
  - Index 8: user3
  - Index 9: user4

TIPS & TRICKS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ The audio pass runs at ~10 FPS (every 0.1 seconds by default)
â€¢ The graphics pass runs at ~60 FPS (every visual frame)
â€¢ Use computeBuffer to visualize audio data in your graphics shader
â€¢ Phase accumulation for audio happens on GPU - no need to manage it in JS
â€¢ Smooth frequency changes in JS for cleaner audio (see default JS code)
â€¢ Use the audioBuffer in graphics_main to visualize waveforms
â€¢ Press Ctrl+S or F5 in any editor to quickly reload your shader
â€¢ Module-scope variables (var<workgroup>, var<private>) and helper functions work!

COMMON PATTERNS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Graphics: Distance field rendering, raymarching, cellular automata
Audio: Additive synthesis, FM synthesis, wavetable synthesis
Combined: Reactive visuals driven by audio parameters

PERFORMANCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Workgroup sizes are optimized: 8x8x1 for graphics, 128x1x1 for audio
â€¢ Avoid divergent branches in hot loops
â€¢ Use shared memory (var<workgroup>) for local collaboration
â€¢ Remember: This all runs on your GPU in parallel!


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
WGSL LANGUAGE CHEATSHEET
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Assignment and declaration with let, var, const - All three support type inference
const A = 5u;           // const for compile time constants
let B = 5.0;            // let for immutable values that wont change
var C = vec3(1.0);      // var for mutable values, loop counters etc
// var is less efficient, use let unless you have to use var
// All three support type specifiers
const D:u32 = 5u; let E:f32 = 5.0; var F:vec3<f32> = vec3(1.0);
// var only - optional assignment, mandatory type
var G:f32;  G = 5.0;

//Scalar Types
var a: bool = true;
var b: i32 = -42;           // 32-bit signed integer
var c: u32 = 42u;           // 32-bit unsigned integer
var d: f32 = 3.14f;         // 32-bit float
var e: f16 = 1.5h;          // 16-bit float (requires extension)
//Vector Types
var v2f: vec2<f32> = vec2(1.0, 2.0);
var v3f: vec3<f32> = vec3(1.0, 2.0, 3.0);
var v4f: vec4<f32> = vec4(1.0, 2.0, 3.0, 4.0);
var v2i: vec2<i32> = vec2<i32>(1, 2);
var v3u: vec3<u32> = vec3<u32>(1u, 2u, 3u);
var v4b: vec4<bool> = vec4<bool>(true, false, true, false);
// Swizzling is read only/right hand side, unless its single component
var xy: vec2<f32> = v4f.xy;
var bgr: vec3<f32> = v4f.bgr;
var wzyx: vec4<f32> = v4f.wzyx;
//Matrix Types
var m2x2: mat2x2<f32> = mat2x2<f32>(1.0, 0.0, 0.0, 1.0);
var m3x3: mat3x3<f32> = mat3x3<f32>(/* 9 values */);
var m4x4: mat4x4<f32> = mat4x4<f32>(/* 16 values */);
// Non-square matrices
var m2x3: mat2x3<f32>;  // 2 columns, 3 rows
var m3x2: mat3x2<f32>;  // 3 columns, 2 rows
var m2x4: mat2x4<f32>;
var m4x2: mat4x2<f32>;
var m3x4: mat3x4<f32>;
var m4x3: mat4x3<f32>;
// Access
var col: vec3<f32> = m3x3[0];      // First column
var element: f32 = m3x3[1][2];     // Column 1, row 2
//Atomic Types
var<storage, read_write> atomic_val: atomic<i32>;
var<storage, read_write> atomic_uval: atomic<u32>;
//Array Types
// Fixed-size arrays
var arr: array<f32, 4> = array<f32, 4>(1.0, 2.0, 3.0, 4.0);
var arr2: array<vec3<f32>, 2>;
// Runtime-sized arrays (only in storage buffers, must be last member)
struct Buffer {
    data: array<f32>  // Runtime-sized
}
//Structs
struct MyStruct {
    position: vec3<f32>,
    @align(16) color: vec4<f32>,  // Explicit alignment
    @size(32) value: f32,          // Explicit size
    count: u32,
}
var s: MyStruct = MyStruct(
    vec3(0.0, 0.0, 0.0),
    vec4(1.0, 0.0, 0.0, 1.0),
    42.0,
    10u
);

// Access
var pos: vec3<f32> = s.position;
s.count = 20u;
Storage Qualifiers & Address Spaces
// Function scope (default)
var local_var: f32;

// Uniform buffer (read-only)
@group(0) @binding(0) var<uniform> uniforms: MyUniforms;

// Storage buffer (read or read_write)
@group(0) @binding(1) var<storage, read> input: Buffer;
@group(0) @binding(2) var<storage, read_write> output: Buffer;

// Workgroup shared memory
var<workgroup> shared_data: array<f32, 256>;

// Private (per-invocation)
var<private> private_var: f32;
//Math Operators
// Arithmetic
var add = a + b;
var sub = a - b;
var mul = a * b;
var div = a / b;
var mod = a % b;  // Integers only
var neg = -a;

// Compound assignment
a += b;
a -= b;
a *= b;
a /= b;
a %= b;  // Integers only

// Comparison
var eq = a == b;
var ne = a != b;
var lt = a < b;
var le = a <= b;
var gt = a > b;
var ge = a >= b;

// Logical
var and = a && b;
var or = a || b;
var not = !a;

// Bitwise (integers only)
var bit_and = a & b;
var bit_or = a | b;
var bit_xor = a ^ b;
var bit_not = ~a;
var shift_left = a << b;
var shift_right = a >> b;

// Compound assignment 2 (ints only)
a &= 5;   // a = a & 5
a |= 5;   // a = a | 5
a ^= 5;   // a = a ^ 5
a <<= 2;  // a = a << 2
a >>= 2;  // a = a >> 2

// Vector/Matrix operations
var v_add = v1 + v2;           // Component-wise
var v_mul = v1 * 2.0;          // Scalar multiplication
var dot_prod = dot(v1, v2);    // Dot product
var cross_prod = cross(v1, v2); // Cross product (vec3 only)
var m_mul = m1 * m2;           // Matrix multiplication
var mv_mul = m * v;            // Matrix-vector multiplication
//Built-in Functions (Compute Shader Safe)
//Math Functions
// Basic math
abs(x)                  // Absolute value
sign(x)                 // Sign (-1, 0, or 1)
floor(x)                // Round down
ceil(x)                 // Round up
round(x)                // Round to nearest
trunc(x)                // Truncate decimal
fract(x)                // Fractional part
modf(x)                 // Split to integer and fractional (returns struct)
clamp(x, min, max)      // Clamp to range
min(a, b)               // Minimum
max(a, b)               // Maximum
mix(a, b, t)            // Linear interpolation: a*(1-t) + b*t
step(edge, x)           // 0 if x < edge, else 1
smoothstep(low, high, x) // Smooth interpolation
saturate(x)             // Clamp to [0, 1]

// Power/Exponential
pow(x, y)               // x^y
exp(x)                  // e^x
exp2(x)                 // 2^x
log(x)                  // Natural logarithm
log2(x)                 // Base-2 logarithm
sqrt(x)                 // Square root
inverseSqrt(x)          // 1/sqrt(x)

// Trigonometry (radians)
sin(x)
cos(x)
tan(x)
asin(x)
acos(x)
atan(x)
atan2(y, x)             // atan(y/x) with correct quadrant
sinh(x)
cosh(x)
tanh(x)
asinh(x)
acosh(x)
atanh(x)
radians(degrees)
degrees(radians)

// Vector functions
dot(v1, v2)             // Dot product
cross(v1, v2)           // Cross product (vec3 only)
length(v)               // Vector length
distance(p1, p2)        // Distance between points
normalize(v)            // Unit vector
faceforward(N, I, Nref) // Flip N if needed
reflect(I, N)           // Reflect vector
refract(I, N, eta)      // Refract vector

// Matrix functions
determinant(m)          // Matrix determinant
transpose(m)            // Matrix transpose
//Bitwise Functions
countOneBits(x)         // Count set bits
reverseBits(x)          // Reverse bit order
firstLeadingBit(x)      // Position of first 1 from MSB
firstTrailingBit(x)     // Position of first 1 from LSB
extractBits(e, offset, count)  // Extract bit range
insertBits(e, newbits, offset, count) // Insert bit range
//Atomic Functions
atomicLoad(atomic_ptr)
atomicStore(atomic_ptr, value)
atomicAdd(atomic_ptr, value)
atomicSub(atomic_ptr, value)
atomicMax(atomic_ptr, value)
atomicMin(atomic_ptr, value)
atomicAnd(atomic_ptr, value)
atomicOr(atomic_ptr, value)
atomicXor(atomic_ptr, value)
atomicExchange(atomic_ptr, value)
atomicCompareExchangeWeak(atomic_ptr, compare, value)
//Data Packing/Unpacking
pack4x8snorm(v)         // vec4<f32> to u32
pack4x8unorm(v)
pack2x16snorm(v)        // vec2<f32> to u32
pack2x16unorm(v)
pack2x16float(v)

unpack4x8snorm(u)       // u32 to vec4<f32>
unpack4x8unorm(u)
unpack2x16snorm(u)      // u32 to vec2<f32>
unpack2x16unorm(u)
unpack2x16float(u)
//Other Useful Functions
all(v)                  // True if all components true
any(v)                  // True if any component true
select(f, t, cond)      // cond ? t : f (component-wise for vectors)
arrayLength(runtime_array_ptr)  // Length of runtime-sized array

// Derivative functions (NOT available in compute!)
// dpdx, dpdy, fwidth - these are fragment shader only
//Control Flow
//If/Else
if (condition) {
    // code
}

if (condition) {
    // code
} else {
    // code
}

if (condition1) {
    // code
} else if (condition2) {
    // code
} else {
    // code
}
//Switch
switch (value) {
    case 0: {
        // code
    }
    case 1, 2: {  // Multiple cases
        // code
    }
    default: {
        // code
    }
}
//For Loop
for (var i = 0u; i < 10u; i++) {
    // code
    break;     // Exit loop
    continue;  // Next iteration
}
//While Loop
while (condition) {
    // code
    break;
    continue;
}
//Loop (infinite with explicit break)
loop {
    if (condition) {
        break;
    }
    
    // continuing block is executed at the end of each iteration
    continuing {
        // Update code
        break if (exit_condition);  // Can break from continuing block
    }
}
//Array Operations
// Declaration
var arr1: array<f32, 4>;                    // Fixed size
var arr2 = array<f32, 4>(1.0, 2.0, 3.0, 4.0); // With initialization
var arr3: array<vec3<f32>, 2>;              // Array of vectors

// Multi-dimensional
var arr2d: array<array<f32, 3>, 4>;         // 4x3 array

// Access
var element = arr1[0];
arr1[1] = 5.0;

// Runtime-sized (in storage buffer)
struct DynamicBuffer {
    length: u32,
    data: array<f32>  // Must be last member
}

@group(0) @binding(0) var<storage, read> buffer: DynamicBuffer;

// Get length of runtime-sized array
var len = arrayLength(&buffer.data);

// Iteration
for (var i = 0u; i < 4u; i++) {
    arr1[i] = f32(i);
}
// Type Casting
// Scalar casting
let i = i32(3.14);      // f32 to i32
let f = f32(42);        // i32 to f32
let u = u32(-1);        // i32 to u32 (bitcast)
let b = bool(1);        // i32 to bool (non-zero = true)

// Vector casting
let v_f32 = vec3f(1.0, 2.0, 3.0);
let v_i32 = vec3i(v_f32);  // vec3f to vec3i

// Bitcast (reinterpret bits)
let bits = bitcast<u32>(3.14f);
let float_back = bitcast<f32>(bits);
//Pointers & References
fn modify(ptr: ptr<function, f32>) {
    *ptr = 10.0;  // Dereference
}

var value = 5.0;
modify(&value);  // Pass pointer

// Get pointer to array element
var arr = array<f32, 4>(1.0, 2.0, 3.0, 4.0);
let elem_ptr = &arr[2];
//Compute Shader Specifics
//Entry Point
@compute @workgroup_size(8, 8, 1)
fn main(
    @builtin(global_invocation_id) global_id: vec3<u32>,
    @builtin(local_invocation_id) local_id: vec3<u32>,
    @builtin(workgroup_id) workgroup_id: vec3<u32>,
    @builtin(local_invocation_index) local_index: u32,
    @builtin(num_workgroups) num_workgroups: vec3<u32>
) {
    // Compute shader code
}
//Workgroup Barrier
workgroupBarrier();  // Synchronize all invocations in workgroup
storageBarrier();    // Ensure memory writes are visible
//Constants
const PI: f32 = 3.14159265359;
const SIZE: u32 = 256u;

// Override constants (can be set from API)
override BLOCK_SIZE: u32 = 16u;
override THRESHOLD: f32;
//Type Aliases
alias Float = f32;
alias Vec3 = vec3<f32>;
alias MyArray = array<f32, 16>;