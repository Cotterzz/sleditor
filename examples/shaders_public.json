{
 "userName": "Cotterzz",
 "date": "2025-12-27T01:01:40.270Z",
 "numShaders": 65,
 "shaders": [
  {
   "ver": "0.1",
   "info": {
    "id": "td3GDN",
    "date": "1568534348",
    "viewed": 218,
    "name": "ManyWaves",
    "description": "This is my first attempt at writing a shader.",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "texture",
     "blending",
     "sinewaves"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 col = vec4(0.00,1.00,1.00,1.00);\n    float progress = fragCoord.x + (iTime*200.00);\n    float scale = 10.00;\n    \n    if(iMouse.y>5.00){scale=iMouse.y;}\n    \n    float groundHeighta = (((sin(progress/50.00))+2.00)*iResolution.y)/scale;\n    float groundHeightb = (((sin(progress/70.00))+2.00)*iResolution.y)/scale;\n    float groundHeightc = (((sin(progress/130.00))+2.00)*iResolution.y)/scale;\n    float groundHeightd = (((sin(progress/23.00))+2.00)*iResolution.y)/scale;\n    \n    float groundHeight = groundHeighta + groundHeightb + groundHeightc + groundHeightd;\n    \n    col = texture(iChannel0, vec2(progress/512.00,fragCoord.y/groundHeight));\n    col = col+texture(iChannel0, vec2(uv.x,fragCoord.y/groundHeight));\n\n    fragColor = vec4(col);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WX2SWz",
    "date": "1745983631",
    "viewed": 70,
    "name": "Max Drekker Paint effect",
    "description": "first attempt",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "test",
     "reproduction"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float rx = floor(uv.x *11.);\n    float ry = floor(iTime/3. + (uv.y * (3. + rx)));\n    float smudge = 1.2-fract(uv.x *11.);\n    float smudgeB = -0.2-fract(uv.x *11.);\n    smudge=smudge*smudge;\n    ry+=smudgeB;\n    rx+=smudge;\n    vec3 col = vec3(abs(sin((rx+ry)/11.)), abs(sin((rx+ry)/9.))/1.7, abs(sin((rx+ry)/3.))/1.2);\n\n    fragColor = mix(vec4(col,1.0), texture(iChannel0, fragCoord/iResolution.xy+vec2(0,smudge/100.), 0.), 0.15+ smudge/2.);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wf3GDX",
    "date": "1747583911",
    "viewed": 115,
    "name": "Koch Snowflake using buffer",
    "description": "Using the buffer for feedback to create koch snowflake\nRed dots to show how the buffer is being copied - six times, to create infinite pattern.",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "recursive",
     "rectangle",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float fEquilateralTriangle(  in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    return -p.y + 0.5*k*max(abs(p.x)+k*p.y,0.0) - r*(1.0/k);\n}\n\nvec4 compare(vec4 new, vec4 old){\n    return old.r > old.g*2. ? old : min(new , old);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   vec3 col = vec3(1);\n   \n   if(fEquilateralTriangle(uv-vec2(0.5*ar, 0.5), .1)<0.1){col = vec3(0);} // Draw a triangle\n   \n   if(distance(uv, vec2(ar/2.,0.5))<.05){col = vec3(1,0,0);} \n   \n   fragColor = vec4(col, 1.); // output  to screen\n   \n    if(iFrame%60 == 0){\n   vec2 newCoords2 = vec2(uv.x/ar , uv.y-1.00);\n   vec2 newCoords = vec2(uv.x/ar , -uv.y);\n   \n   float mult = 3.;\n   float y1 = -2.315;\n   float y2 = -1.375;\n   float x1 = 1.0;\n   float xw = .307;\n   float x2 = x1+ xw;\n   float x3 = x1- xw;\n   fragColor = compare(fragColor , texture(iChannel0, (newCoords*mult)-vec2(x3,y1), 0.));\n   fragColor = compare(fragColor , texture(iChannel0, (newCoords*mult)-vec2(x2,y1), 0.));\n   fragColor = compare(fragColor , texture(iChannel0, (newCoords*mult)-vec2(x1,y2), 0.));\n   fragColor = compare(fragColor , texture(iChannel0, (newCoords2*mult)-vec2(x3,y1), 0.));\n   fragColor = compare(fragColor , texture(iChannel0, (newCoords2*mult)-vec2(x2,y1), 0.));\n   fragColor = compare(fragColor , texture(iChannel0, (newCoords2*mult)-vec2(x1,y2), 0.));\n  } else {\n  \n   fragColor = texture(iChannel0, nuv, 0.);\n  }\n   if(iFrame<2){fragColor = vec4(col, 1.);} \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wf33Wl",
    "date": "1747645630",
    "viewed": 107,
    "name": "Koch with buffer rotation",
    "description": "Using the buffer for feedback to create koch snowflake, blue dots to show how the buffer is being copied - six times, rotated, to create infinite pattern.\nMuch better version with precise rotation and rotated addition.",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "recursive",
     "rectangle",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float fEquilateralTriangle(  in vec2 p, in float r ){const float k = sqrt(3.0);return -p.y + 0.5*k*max(abs(p.x)+k*p.y,0.0) - r*(1.0/k);}\n\nvec4 compare(vec4 new, vec4 old){return old.b > old.g*2. ? old : min(new , old);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 14;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       vec3 col = vec3(1);\n       if(fEquilateralTriangle(uv-vec2(0.5*ar, 0.5), .1)<0.1){col = vec3(0);}\n       if(distance(uv, vec2(ar/2.,0.5))<.05){col = vec3(0,0,1);}\n       fragColor = vec4(col, 1.);\n   } else if(iFrame%freq == 0){\n       vec2 nc = uv-vec2(0.5*ar, 0.5); \n       float rad = distance(nc,vec2(0,0));\n       float angle = 0.52359877 + float((iFrame/freq)%6)*1.04703 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.207; nc*= 3.; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , texture(iChannel0, nc, 0.));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfcGDs",
    "date": "1747659422",
    "viewed": 83,
    "name": "Koch Squareflake?",
    "description": "Not strictly a type of Koch curve, notice the bare corners of the square, you can't actually fit the required geometry without making the squares much smaller.\nLike the triangle requires six directions of self similarity, the square needs eight.",
    "likes": 2,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "recursive",
     "square",
     "feedback",
     "buffer",
     "koch"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 12:07:11\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float square(  in vec2 p, in float r ){ return max( abs(p.x)-r, abs(p.y)-r ); }\n\nvec4 compare(vec4 new, vec4 old){return old.g > old.r*2. ? old : min(new , old);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 14;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       vec3 col = vec3(1);\n       if(square(uv-vec2(0.5*ar, 0.5), .1)<0.1){col = vec3(0);}\n       if(distance(uv, vec2(ar/2.,0.5))<.05){col = vec3(0,1,0);}\n       fragColor = vec4(col, 1.);\n   } else if(iFrame%freq == 0){\n       vec2 nc = uv-vec2(0.5*ar, 0.5); \n       float rad = distance(nc,vec2(0,0));\n       float angle = float((iFrame/freq)%4)*1.5707963 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.275; nc*= 2.5; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , texture(iChannel0, nc, 0.));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wf33Ds",
    "date": "1747661753",
    "viewed": 88,
    "name": "Koch Squareflake 2",
    "description": "True equivalent of the Koch snowflake for a square (as in constructed the same way)\nThis is why it's not a famous Koch curve. You just end up with another square!\nI've moved the other one to it's own shader now: https://www.shadertoy.com/view/Wfd3Wl",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "recursive",
     "square",
     "feedback",
     "buffer",
     "koch"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch Squareflake?\" by Cotterzz. https://shadertoy.com/view/tfcGDs\n// 2025-05-19 13:27:17\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 12:07:11\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, (fragCoord/iResolution.xy), 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float square(  in vec2 p, in float r ){ return max( abs(p.x)-r, abs(p.y)-r ); }\n\nvec4 compare(vec4 new, vec4 old){return old.r > old.b*2. ? old : min(new , old);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 20;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       vec3 col = vec3(1);\n       if(square(uv-vec2(0.5*ar, 0.5), .1)<0.1){col = vec3(0);}\n       if(distance(uv, vec2(ar/2.,0.5))<.05){col = vec3(1,1,0);}\n       fragColor = vec4(col, 1.);\n   } else if(iFrame%freq == 0){\n       int count = (iFrame/freq)%4;\n       vec2 nc = uv-vec2(0.5*ar, 0.5); \n       float rad = distance(nc,vec2(0,0));\n       float angle = float(count)*1.5707963 + atan(nc.x,nc.y);\n       vec2 nc2 = nc;\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.266; nc*= 3.; nc.x/=ar; nc+=0.5;\n       nc2.y-=.266; nc2*= 3.; nc2.x/=ar; nc2+=0.5;\n       nc2 -= count==0?vec2(.225, -.4):count==1?vec2(-.225, -.4):count==2?vec2(-.225, -1.2):vec2(.225, -1.2);\n       fragColor = compare(fragColor , texture(iChannel0, nc, 0.));\n       fragColor = compare(fragColor , texture(iChannel0, nc2, 0.));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wfd3Wl",
    "date": "1749294083",
    "viewed": 87,
    "name": "Koch Fraccident",
    "description": "I couldnt publish this one by itself before because of posting restrictions.\nThis was an accident, or a fraccident I guess.\n",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "recursive",
     "square",
     "feedback",
     "buffer",
     "koch"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch Squareflake 2\" by Cotterzz. https://shadertoy.com/view/wf33Ds\n// 2025-05-19 14:08:04\n\n// Fork of \"Koch Squareflake?\" by Cotterzz. https://shadertoy.com/view/tfcGDs\n// 2025-05-19 13:27:17\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 12:07:11\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float square(  in vec2 p, in float r ){ return max( abs(p.x)-r, abs(p.y)-r ); }\n\nvec4 compare(vec4 new, vec4 old){return old.b > old.r*2. ? old : min(new , old);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 10;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       vec3 col = vec3(1);\n       if(square(uv-vec2(0.5*ar, 0.5), .1)<0.075){col = vec3(0);}\n       if(distance(uv, vec2(ar/2.,0.5))<.05){col = vec3(0,1,1);}\n       fragColor = vec4(col, 1.);\n   } else if(iFrame%freq == 0){\n       vec2 nc = uv-vec2(0.5*ar, 0.5); \n       float rad = distance(nc,vec2(0,0));\n       float angle = float((iFrame/freq)%4)*1.5707963 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.245; nc.x-=.13; nc*= 2.1; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , texture(iChannel0, nc, 0.));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfG3zW",
    "date": "1747841336",
    "viewed": 297,
    "name": "Massive alien orgy",
    "description": "I was playing with voronoi, and one thing led to another...",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "voronoi",
     "anatomy"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// based on iq's voronoi at https://thebookofshaders.com/edit.php#12/2d-voronoi.frag\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x , float tm) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    float it = iTime*tm;\n    // first pass: regular voronoi\n    vec2 mg, mr;\n    float md = 8.0;\n    for (int j= -1; j <= 1; j++) {\n        for (int i= -1; i <= 1; i++) {\n            vec2 g = vec2(float(i),float(j));\n            vec2 o = random2( n + g );\n            o = 0.5 + 0.5*sin( it + 6.2831*o );\n\n            vec2 r = g + o - f;\n            float d = dot(r,r);\n\n            if( d<md ) {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n\n    // second pass: distance to borders\n    md = 8.0;\n    for (int j= -2; j <= 2; j++) {\n        for (int i= -2; i <= 2; i++) {\n            vec2 g = mg + vec2(float(i),float(j));\n            vec2 o = random2( n + g );\n            o = 0.5 + 0.5*sin( it + 6.2831*o );\n\n            vec2 r = g + o - f;\n\n            if ( dot(mr-r,mr-r)>0.00001 ) {\n                md = min(md, dot( 0.5*(mr+r), normalize(r-mr) ));\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvec3 vcell(vec2 st, float tm){\n    vec3 c = voronoi(st, tm);\n    vec3 color = vec3(0.);\n    // isolines\n    color = c.x*(0.5 + 0.5*sin(64.0*c.x))*vec3(1.0);\n    // borders\n    color = mix( vec3(1.0), color, smoothstep( 0.01, 0.02, c.x ) );\n    // feature points\n    float dd = length( c.yz );\n    color += vec3(1.)*(1.0-smoothstep( 0.0, 0.04, dd));\n    float bounds = iResolution.y*0.8;\n    \n    if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.y;}\n    \n    float mixd = (0.5-dd)*(0.5-c.x);\n    return vec3(pow(mixd,0.7-(bounds/iResolution.y/1.7)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float bounds = iResolution.x/1.6;\n    \n   if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.x;}\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 st = uv-0.5; st.x *= iResolution.x/iResolution.y;\n    st*=0.7 + (3.5*bounds/iResolution.x);\n    float it = 0.4;\n    vec3 col = vec3(0);\n    for(float i = 4.0; i<17.; i*=1.3){\n        st+=i;\n        col = max(col, vcell(st*i*it, i)/(i/3.5));\n    }\n\n\n    fragColor = vec4(col,1.0);\n    \n   // fragColor = (fragColor+texture(iChannel0, uv, 0.))/1.55;\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 addLight(vec3 position, vec3 normal, vec3 colour, vec3 lcol, vec3 lpos){\n    vec3 ref = reflect(vec3(0.0, 0.0, -1.0), normal);\n    vec3 diff = lpos - position;\n    float ldist = length(diff);\n    diff = diff/ldist;\n    float specular = pow(max(0.0, dot(diff, ref)), 64.0);\n    float diffuse = max(0.0, dot(diff,normal));\n    vec3 col1 = colour*0.7;\n    vec3 col2 = colour*0.4*(lcol*diffuse);\n    col2 = col2+(lcol*specular);\n    return col1+col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   vec2 co = fragCoord;\n   float scale  = 0.2 + iMouse.x/iResolution.x*16.;\n   vec3 col = vec3(0);\n    \n    // three sample plus dxdy\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    float ra = texture(iChannel0, co/iResolution.xy, 0.).r;\n    float rb = texture(iChannel0, (co+vec2(1,0))/iResolution.xy, 0.).r;\n    float rc = texture(iChannel0, (co+vec2(0,1))/iResolution.xy, 0.).r;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    \n    float bounds = iResolution.y/1.6;\n    \n    if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.y;}\n    float dvh = 10. + (bounds/iResolution.y)*120.;\n    vec3 normal = normalize(vec3(dx*dvh, dy*dvh, ra));\n    \n    col = vec3(0.8,0.5+(ra/3.),0.4+(ra/3.));\n    \n    col*=(0.3+(ra*1.5));\n    \n    vec3 position = vec3(co/iResolution.xy, ra);\n    \n    vec3 lcol = vec3(1);\n    vec3 lpos = vec3(-0.5,-0.5,2);\n    \n    vec3 rend = addLight(position, normal, col, lcol, lpos);\n    \n    \n    fragColor =vec4(rend, 1.);\n    \n    //fragColor =vec4(vec3(ra), 1.); // uncomment to see raw height data from buffer A\n\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tcG3Rm",
    "date": "1747915397",
    "viewed": 217,
    "name": "Visualiser - Picking out notes.",
    "description": "I revisited a very old shader with some new ideas....\nThis will form the basis of some very interesting visualisations I think.\nVery basic proof of concept but its already doing what I was going for...",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fft",
     "spectrum",
     "music",
     "audio",
     "rgb",
     "visualiser",
     "notes",
     "tones"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4df3Rn",
       "filepath": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Visualiser 203\" by Cotterzz. https://shadertoy.com/view/tsGGRy\n// 2025-05-22 11:51:47\n\n// If you want to change tune, click on the iChannel0 audio display below, then on music tab and select different track\n//                                                              Electronebulae and X'TrackTure are both good.\n\n#define TWO_PI 6.28318530718\n\n#define C9 8372.02\n#define Db9 8870.\n#define D9 9398.\n#define Eb9 9974.\n#define E9 10548.\n#define F9 11176.\n#define Gb9 11840.\n#define G9 12544.\n#define Ab9 13290.\n#define A9 14080.\n#define Bb9 14918.\n#define B9 15804.\n\nfloat notes[] = float[](C9, Db9, D9,Eb9,E9,F9,Gb9,G9,Ab9,A9,Bb9,B9);\n\nfloat flats[] = float[](1., 0.5, 1., 0.5, 1.,1.,0.5, 1., 0.5, 1., 0.5, 1.);\n\nvec3 cols[] = vec3[](vec3(1,1,0),      vec3(0.5,1,0.1),vec3(0,0.8,0),  vec3(0,.8,0.6),vec3(0,0.8,1), vec3(0,0.2,1),\n                     vec3(0.35,0,0.75),vec3(0.5,0,1),  vec3(0.8,0,0.7),vec3(0.8,0,0), vec3(1,0.1,0), vec3(1,0.5,0));\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u / iResolution.xy,\n        to = U * vec2(12,10),\n        TO = floor(to),\n        D  =  abs(fract(to) - .5);\n       vec3 col = cols[int(TO.x)]; float flt = flats[int(TO.x)];\n       \n    float dist = max(D.x, D.y),\n     frequency = notes[int(TO.x)] / exp2(9.-TO.y),\n        f = texture(iChannel0, vec2(frequency/11025.,0)).r,\n        fa = texture(iChannel0, vec2((frequency*1.13)/11025.,0)).r,\n        fb = texture(iChannel0, vec2((frequency*0.87)/11025.,0)).r,\n        fc = texture(iChannel0, vec2((frequency*1.2)/11025.,0)).r,\n        fd = texture(iChannel0, vec2((frequency*0.8)/11025.,0)).r;\n        float av = (f+fa+fb+fc+fd)/5.;\n        float ff = (f-av)*8.*f;\n        f=(f+f+f+ff+ff)/4.;\n\t\tfloat bright = smoothstep(.0, .01 , (f*f*f*f)-dist*2. );\n\t\n    O = bright * vec4(col*flt, 1);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cVGzm",
    "date": "1747928722",
    "viewed": 171,
    "name": "Another feedback fractal",
    "description": "One simple curve, repeated four times with feedback.",
    "likes": 14,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "tree",
     "recursive",
     "rectangle",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch with hexagons\" by Cotterzz. https://shadertoy.com/view/tfd3Ds\n// 2025-05-22 15:34:19\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 18:21:33\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "vec4 compare(vec4 new, vec4 old){return old.b > old.g*2. ? old : min(new , old);}\nvec4 getTex(vec2 nc){\n   if(nc.x>0.&&nc.x<1.&&nc.y>0.&&nc.y<1.){return texture(iChannel0, nc, 0.); } else {return vec4(1);}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 50;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       fragColor = vec4(1);\n       if(uv.x>0.5 && abs(distance(uv, vec2(0.5,-0.05))-(ar/3.))<(0.003/(uv.y+0.2))){fragColor = vec4(0,0,0,1);}\n\n   } else if(iFrame%freq == 0){\n   \n       vec2 nc = uv-vec2(0.5*ar, 0);\n       //nc.x = -nc.x;\n       float rad = distance(nc,vec2(0,0));\n       float angle = .55 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.48; nc.x-=.03;nc*= 2.; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , getTex(nc));\n       \n       nc = uv-vec2(0.5*ar, 0);\n       nc.x = -nc.x;\n       rad = distance(nc,vec2(0,0));\n       angle = -.25 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.03; nc.x-=.25;nc*= 3.; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , getTex(nc));\n       \n       nc = uv-vec2(0.5*ar, 0);\n       //nc.x = -nc.x;\n       rad = distance(nc,vec2(0,0));\n       angle = 1.29 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=0.7; nc.x-=.13;nc*= 1.8; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , getTex(nc));\n       \n       nc = uv-vec2(0.5*ar, 0);\n       //nc.x = -nc.x;\n       rad = distance(nc,vec2(0,0));\n       angle = 3.1 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.56; nc.x+=.59;nc*= 3.; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , getTex(nc));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcG3D1",
    "date": "1748012964",
    "viewed": 151,
    "name": "Random image pixel sort",
    "description": "Instructions:\nDrag the canvas until you see an image you like, let go and watch the pixel sorting happen.\nScrub across canvas again to see result and derivative, let go to see height map.\nRewind to try again with new image",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "random",
     "generative",
     "linear",
     "sort",
     "assignment"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* Fork of \"Parallel Linear Assignment Sort\" by michael0884. https://shadertoy.com/view/wfK3Rw\n   Fork of \"Random Feedback Shader\" by Cotterzz. https://shadertoy.com/view/wft3Dr\n   2025-05-23 08:51:41\n---\nInstructions:\nDrag the canvas until you see an image you like, let go and watch the pixel sorting happen.\nScrub across canvas again to see result and derivative, let go to see height map.\nRewind to try again with new image\n---\nThis was two shaders thrown together quite quickly, so the code is a mess, and a bit slow at high res.\nI need to turn the image generation into an easy to use function, plus the whole thing could be optimised a lot\n---\nI loved the unpredictable but deterministic results of michael0884's pixel sort shader,\nSo I used my random image genearator as input to explore different images.\nThe result feels very random & truly generative.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(mTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(mTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n#define T (mTime*4.)\n#define rot(a) mat2(cos(a+vec4(0,33,11,0)))\n#define P(z) (vec3(tanh(cos((z) * .15) * 1.) * 8., \\\n                   tanh(cos((z) * .12) * 1.) * 8., (z)))\n\n\n// PREVIEW 0 to disable preview mode\n\n\n#define PREVIEW 0\n#define VOLUMETRIC 0\n\nfloat displaytime = 1.2; // seconds between switch\n\n// select palette mode below\nint PALETTE = 9;\n\n// 0 = Original\n// 1 = Original with hsl mixed\n// 2 = Original translated to hsl\n// 3 = hsl calculated\n// 4 = hsl enhanced\n// 5 = hsl*2\n// 6 = weird\n// 7 = fhex\n// 8 = Banded.\n// 9 = RANDOMISE!!!\n\nfloat hash1(vec2 x)\n{\n    uvec2 t = floatBitsToUint(x);\n    uint h = 0xc2b2ae3du * t.x + 0x165667b9u;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h += 0xc2b2ae3du * t.y;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h ^= h >> 15u;\n    h *= 0x85ebca77u;\n    h ^= h >> 13u;\n    h *= 0xc2b2ae3du;\n    h ^= h >> 16u;\n    return uintBitsToFloat(h >> 9u | 0x3f800000u) - 1.0;\n}\n\nvec2 hash2(vec2 x) // improved hash using xxhash\n{\n    float k = 6.283185307 * hash1(x);\n    return vec2(cos(k), sin(k));\n}\n\nfloat noise2( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0))); // changed to h^3 [1]\n    return dot( n, vec3(32.99) ); // analytic factor (= 2916*sqrt(2)/125)\n}\n\nfloat pnoise (vec2 uv){\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2( uv ); uv = m*uv;\n    f += 0.2500*noise2( uv ); uv = m*uv;\n    f += 0.1250*noise2( uv ); uv = m*uv;\n    f += 0.0625*noise2( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    return f;\n}\n\nvec3 p = vec3(0);\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat map(vec3 p) {\n    return 1.5 - length(p - P(p.z));\n}\nfloat rMix(float a, float b, float s, float y){\n    s = rand(s);\n    //if(y>0.){s*=2.;}\n    if(s>1.){\n      return s>1.66?texture(iChannel0, vec2(a,b), 0.).r:s>1.33?texture(iChannel0, vec2(a,b), 0.).g:texture(iChannel0, vec2(a,b), 0.).b;\n    }\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/(a==0.?0.01:a):s>0.3?pnoise(vec2(a,b)):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nvec3 fhexRGB(float fh){\n    if(isinf(fh)||fh>100000.){fh = 0.;}\n    fh = abs(fh*10000000.);\n    float r = fract(fh/65536.);\n    float g = fract(fh/256.);\n    float b= fract(fh/16777216.);\n    //return gmc(contrast(hsl2rgb(vec3(r,g,b)), 0.9), 0.9);\n   return hsl2rgb(vec3(r,g,b));\n}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = fhexRGB(num);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n    \n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n       \n        return col;\n       \n    } else {\n\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        // if(PALETTE == 0){col = contrast(col, 1.01); }\n        return col;\n    \n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., abs(dc.r));\n    dc.g = min(1., abs(dc.g));\n    dc.b = min(1., abs(dc.b));\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   int smode = int(texture(iChannel0, vec2(0), 0.).g);\n   if(iFrame<2){\n       smode = 0;\n   } else if(smode<2&&iMouse.z>0.) { smode = 1; } else if ( (iMouse.x>0. || iMouse.y > 0.) && smode==1 && iMouse.z<=0. ){smode = 2;} \n   \n    float mTime = iTime;\n    vec3 old = texture(iChannel0, fragCoord/iResolution.xy, 0.).rgb;\n    if(smode < 2){\n    \n    vec3 oldu = texture(iChannel0, (fragCoord+vec2(1,1))/iResolution.xy, 0.).rgb;\n    vec3 oldd = texture(iChannel0, (fragCoord+vec2(-1,-1))/iResolution.xy, 0.).rgb;\n    vec3 oldl = texture(iChannel0, (fragCoord+vec2(1,-1))/iResolution.xy, 0.).rgb;\n    vec3 oldr = texture(iChannel0, (fragCoord+vec2(-1,1))/iResolution.xy, 0.).rgb;\n     vec3  r = iResolution;\n    vec2 u = fragCoord;\n    \n        \n        float s=.002,d,i, l;\n\n        u = (u-r.xy/2.)/r.y;\n    \n        vec3  p = P(T),ro=p,q,\n              Z = normalize( P(T+1.)  - p),\n              X = normalize(vec3(Z.z,0,-Z)),\n              D = vec3(rot(tanh(sin(p.z*.03)*8.)*3.)*u, 1)* mat3(-X, cross(X, Z), Z);\n       \n        for(; i++<80. && s > .001; ) {\n    \n            p = ro + D * d,\n            s = map(p)*.8,\n            d += s;\n        }\n        p = ro + D * d;\n    \n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 4.;\n    if(VOLUMETRIC == 1 ){ zoom+= (1.5*(sin(mTime)+1.)); } else { zoom+= (3.*(sin(mTime)+1.));}\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 468.;\n    float iy = 330.;\n    if(iMouse.x>0.&&iMouse.y>0.){\n    ix = iMouse.x; iy = iMouse.y;}\n    \n    float seed = (ix + (iy*iResolution.x))/iResolution.x;\n    \n    if(!(iMouse.z>0.) && iMouse.x==0. && iMouse.y==0.){\n        seed = floor(mTime/displaytime);\n    }\n    \n    bool pfb = false; if(rand(seed*3.4)<0.5){pfb=true;}\n    bool reverseEF = false;  if(rand(seed*5.4)<0.5){reverseEF=true;}\n    \n    if(PALETTE == 9){\n        PALETTE = int(floor(float(8)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 31;\n    \n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = p.x;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = p.y;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = p.z;\n   values[21] = atan(x, y)*4.;\n   values[22] = pnoise(vec2(x,y)/2.);\n   values[23] = pnoise(vec2(y,x)*10.);\n   \n   if(pfb){\n   values[24] = old.r;\n   values[25] = old.g;\n   values[26] = old.b;\n    values[27] = (oldu.r+oldu.g+oldu.b)/3.;\n     values[28] = (oldd.r+oldd.g+oldd.b)/3.;\n      values[29] = (oldl.r+oldl.g+oldl.b)/3.;\n       values[30] = (oldr.r+oldr.g+oldr.b)/3.;\n   } else {\n      values[24] = 2.;\n      values[25] = 10.;\n      values[26] = 3.14159;\n          values[27] = 1.;\n     values[28] = 3.;\n      values[29] = 5.;\n       values[30] = 7.;\n   }\n    float total = 0.;\n    float sub = 0.;\n    int maxi = 25; int mini = 3;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        float dif = rand(seed+float(i+3))-(abs(total));\n        if(reverseEF) {dif = -dif;}\n        if(dif>0.){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4), y) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4), y), seed+float(i), y);\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i), y);\n      \n        }\n        dif = rand(seed+float(i))-sub;\n        if(reverseEF) {dif = -dif;}\n        if(dif>0.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2), y);\n            sub = 0.;\n            dif = rand(seed+float(i+30))-total;\n            if(reverseEF) {dif = -dif;}\n            if(dif > 0.){\n                col += addColor(total, seed+float(i), values[21]);\n                cn+=1.;\n            }\n        }\n    }\n    \n    total = sub==0. ? total : rMix(total, sub, seed, y);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    if(VOLUMETRIC == 1 ) { \n    uv+=vec2(0.16,0.1);\n    if(abs(uv.x)>0.6 || abs(uv.y)>0.32){col=vec3(0);}\n    \n    float alph = (col.r+col.g+col.b)/3.;\n    alph = alph<0.5?0.0:alph<0.7?(alph-0.5)*5.:1.0;\n    fragColor = vec4(mix(oldd*.98, col, alph), 1.);\n    } else {\n    fragColor = vec4(col, 1.);\n    }\n    if(floor(fragCoord) == vec2(0)){fragColor = vec4(float(iFrame), float(smode), 0, 1.);}\n\n    } else {\n    fragColor = vec4(old, 1.);\n    if(floor(fragCoord) == vec2(0)){fragColor = vec4(old.r, float(smode), 0, 1.);}\n    }\n   // if(fragCoord.x> (iResolution.x -  (float(smode+1)*50.))){ fragColor = vec4(0,1,0, 1.);}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "//pause between reset\n#define PAUSE 8192\n\n#define STEP 128\n#define MAX_STEPS 8\n#define PERIOD (MAX_STEPS * STEP)\n#define LOD_OFFSET 0.0\n#define MIN_BLOCK_SIZE 8u\n\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n\n//flip lowest n bits\nint xor_n(int x, int n)\n{\n    return x ^ ( (1<<(n+1)) - 1 );\n}\n\nint imod(int a, float b)\n{\n    return a - int(b*floor(float(a)/b));\n}\n\nuint pcg(uint v)\n{\n    uint state = v * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nuint rand_int(uint seed, uint max_value)\n{\n    return pcg(seed) % max_value;\n}\n\nuint xor_swap(uint idx, uint n, uint seed)\n{\n    uint xor_seed = rand_int(seed, n);\n    uint xor_idx = idx ^ xor_seed;\n    uint max_idx = max(idx, xor_idx);\n    uint min_idx = min(idx, xor_idx);\n    bool swap = rand_int(min_idx * 451u + seed, 2u) == 0u;\n    return (swap && (max_idx < n)) ? xor_idx : idx;\n}\n\nuint reverse(uint idx, uint n)\n{\n    return n - 1u - idx;\n}\n\nuint shuffle(uint idx, uint n, uint seed, uint iters)\n{\n    for(uint i = 0u; i < iters; i++)\n    {\n        idx = xor_swap(idx, n, seed + i);\n        idx = reverse(idx, n);\n    }\n    return idx;\n}\n\nuint unshuffle(uint idx, uint n, uint seed, uint iters)\n{\n    for (uint i = iters; i-- > 0u; )\n    {\n        idx = reverse(idx, n);                 \n        idx = xor_swap(idx, n, seed + i);\n    }\n    return idx;\n}\n\nuint getcompanion(uint idx, uint n, uint seed, uint iters)\n{\n    uint shuffled = shuffle(idx, n, seed, iters);\n    uint shuffled_companion = clamp(shuffled ^ 1u, 0u, n - 1u);\n    return unshuffle(shuffled_companion, n, seed, iters);\n}\n\nuvec2 blockSize;\nuvec2 blockOffset;\n\nuvec2 i2xy(uint id)\n{\n    return uvec2(id %blockSize.x, id/blockSize.x);\n}\n\nuint xy2i(uvec2 xy)\n{\n    return xy.x + xy.y*blockSize.x;\n}\n\n\nvec4 gaussianBlur5x5Lod(sampler2D image, vec2 uv, float lod)\n{\n    const float w[5] = float[5](1.0, 4.0, 6.0, 4.0, 1.0);\n    vec2 stepSize = exp2(lod) / iResolution.xy;\n    vec4 sum = vec4(0.0);\n    float weightSum = 0.0;\n    for(int y = 0; y < 5; ++y)\n    {\n        float wy = w[y];\n        for(int x = 0; x < 5; ++x)\n        {\n            vec2 offset = vec2(float(x) - 1.5, float(y) - 1.5) * stepSize;\n            float weight = wy * w[x];\n            weightSum += weight;\n            sum += textureLod(image, uv + offset, lod) * weight;\n        }\n    }\n    return sum / weightSum;\n}\n\nvoid mainImage( out vec4 U, in vec2 p )\n{  \n    int smode = int(texture(iChannel1, vec2(0), 0.).g);\n    vec2 fragCoord = p;\n    if(smode == 2 ){\n    int sFrame = int(texture(iChannel1, vec2(0), 0.).r);\n    int iter0 = (iFrame-sFrame) % (PERIOD + PAUSE);\n    uint iter1 = uint(MAX_STEPS) - (uint(clamp(iter0, 0, PERIOD)) / uint(STEP));\n    blockSize = min(uvec2(MIN_BLOCK_SIZE << iter1), uvec2(iResolution.xy));\n    blockOffset = (((iFrame-sFrame) & 1) == 0) ? blockSize/2u : uvec2(0u);\n    float LOD = float(iter1) + LOD_OFFSET;\n    p = floor(p);\n    \n    //reset state\n    if(iter0 == 0)\n    {\n        U = texture(iChannel1, p / iResolution.xy);\n        return;\n    }\n    \n    //select blocks of pixels\n    uvec2 pu = uvec2(p);\n    uvec2 block = ((pu + blockOffset) / blockSize) * blockSize - blockOffset;\n    uvec2 bPos = pu - block;\n    \n    //random pair of 2 unique pixels, this pixel and its random partner (symmetric)\n    uint bid0 = xy2i(bPos);\n    uint bid1 = getcompanion(bid0, blockSize.x*blockSize.y, uint((iFrame-sFrame)), 12u); \n\n    //the pair positions \n    uvec2 p0 = block + i2xy(bid0);\n    uvec2 p1 = block + i2xy(bid1);\n    \n    //current values\n    vec4 c0 = texel(ch0, vec2(p0));\n    vec4 c1 = texel(ch0, vec2(p1));\n    \n    if(any(greaterThan(p1, uvec2(iResolution.xy - 1.0)))) { U = c0; return; } //invalid pair\n    \n    //target blurred values\n    vec4 bc0 = gaussianBlur5x5Lod(iChannel0, vec2(p0)/iResolution.xy, LOD);\n    vec4 bc1 = gaussianBlur5x5Lod(iChannel0, vec2(p1)/iResolution.xy, LOD);\n\n    //flip the pixels so that its closer to blurred \n    float score0 = distance(c0, bc0) + distance(c1, bc1);\n    float score1 = distance(c1, bc0) + distance(c0, bc1);\n    U = (score0 < score1) ? c0 : c1;\n    \n    } else {\n        U = texture(iChannel1, fragCoord/iResolution.xy, 0.);\n    }\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "vec4 absGradient(sampler2D tex, vec2 uv)\n{\n    vec2 o = 0.5 / iResolution.xy;\n    vec4 dX = texture(tex, uv + vec2(o.x, 0.0)) - texture(tex, uv - vec2(o.x, 0.0));\n    vec4 dY = texture(tex, uv + vec2(0.0, o.y)) - texture(tex, uv - vec2(0.0, o.y));\n    return 20.0*sqrt(dX * dX + dY * dY);\n}\n\nvoid mainImage( out vec4 U, in vec2 p )\n{\n    float line = iResolution.x*1.0;\n    p = floor(p);\n    if(iMouse.z > 0.0  && texture(iChannel1, vec2(0), 0.).g>1.5) line = iMouse.x;\n    vec4 color = texelFetch(iChannel0, ivec2(p), 0);\n    vec4 grad = absGradient(iChannel0, p / iResolution.xy);\n    U = (p.x < line) ? color : grad;\n    U.xyz = 1.5*tanh(pow(U.xyz, vec3(2.2)));\n    U.w = 1.0;\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int h = 200;\n    float el = float(iFrame%h)*(1./iResolution.y);\n    vec2 huv = uv-vec2(0,el);\n    vec2 nuv = huv;\n\n    nuv.y*=3.3;\n\n\n    nuv.x -= 0.24-huv.y;\n    nuv.y += 0.2-huv.x;\n    \n    vec3 col = vec3(0);\n    \n    if(nuv.x>0.&&nuv.x<1.&&nuv.y>0.&&nuv.y<1.){col = texture(iChannel0, nuv, 0.).rgb; } else {col =  vec3(0);}\n    \n    if(((col.r+col.g+col.b)/10.) < el) { col = texture(iChannel1, uv, 0.).rgb;}\n    \n    if(iMouse.z>0. || texture(iChannel2, vec2(0), 0.).g<1.5){col = texture(iChannel0, uv, 0.).rgb;}\n    fragColor = vec4(col,1);\n\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcV3Dh",
    "date": "1748036352",
    "viewed": 201,
    "name": "simple heightmap from texture",
    "description": "Something I needed for another shader. It scans in so it's not too expensive.",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "terrain",
     "heightmap",
     "height",
     "relief"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "M O = T; }\n\n//old\n//void mainImage( out vec4 fragColor, in vec2 fragCoord ){fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "M\n    vec2 N = iResolution.xy,\n         U = u/N;\n         \n    float e = float( iFrame % 200 ) / N.y;\n    \n    N = mat2(1,-1., 1,  3.3) * ( U - vec2(0,e) ) + vec2(-.24,.2);\n    \n    O = clamp(N,0.,1.) == N ? texture(iChannel1, N, 0.) : O*0.;\n        \n    O.r+O.g+O.b < e*15. ? O = T : O;\n}\n\n\n//old\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 2.;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    int h = 300;\n    float el = float(iFrame%h)*(1./iResolution.y);\n    vec2 huv = uv-vec2(0,el);\n    vec2 nuv = huv;\n    nuv.y*=3.3;\n    nuv.x -= 0.24-huv.y;\n    nuv.y += 0.2-huv.x;\n    vec3 col = vec3(0);\n    \n    if(nuv.x>0.&&nuv.x<1.&&nuv.y>0.&&nuv.y<1.){col = texture(iChannel0, nuv, 0.).rgb; } else {col =  vec3(0);}\n    if((col.r+col.g+col.b)/3. < (el*10.)/scale) { col = texture(iChannel1, uv, 0.).rgb;}\n    \n    fragColor = vec4(col,1);\n\n}\n*/\n\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define M   void mainImage( out vec4 O, vec2 u ) { // \n#define T   texelFetch(iChannel0, ivec2(u), 0)",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tcy3Rd",
    "date": "1748401067",
    "viewed": 241,
    "name": "Picture evolver v1",
    "description": "After seeing a video by the guy that made picbreeder, I decided to put this together.\nThis is very rudimentary and is just a proof of concept - I wanted to get the interactivity and state figured out first.\nOnly 12 options and no parameters atm.",
    "likes": 24,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "random",
     "generative",
     "interaction",
     "evolution",
     "art",
     "user"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// See comments for instructions, video and link\n\n/*\nInstructions:\nThe small thumbnails are the different options for mutating the image, click on one to transform the image and see the next set of choices.\nIt goes on forever.\nBackground\nThe idea is simple, an evolving image with user selected mutation, with the user picking each iteration based on how interesting they think the image is.\n(As opposed to my other attempts at random images that applied a series of transformations automatically based on a random seed,\nthis felt like a great way to follow that up) The current steps are very limited,\nI just wanted to get the basic interaction working and see if it was as fun as it sounded before creating a balanced and varied selection of mutations.\nReferences\nThis is the picbreeder site https://nbenko1.github.io/#/\nThey're doing this but at scale, with a user base, and collaborative evolution of pictures, gallery etc.\nI think they're using the process of selecting interesting images to train AI as well.\nAnd this is the interview that prompted me to try this out\nhttps://www.youtube.com/watch?v=5zg_5hg8Ydo&t=778s\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "vec3 hsl2rgb( in vec3 c )\n{\n    float  ct = c.r+c.g+c.b; c.r = ct;c.g=ct;c.b=ct;\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec4 absGradient(sampler2D tex, vec2 uv) // from michael0884. https://shadertoy.com/view/wfK3Rw\n{\n    vec2 o = 0.5 / iResolution.xy;\n    vec4 dX = texture(tex, uv + vec2(o.x, 0.0)) - texture(tex, uv - vec2(o.x, 0.0));\n    vec4 dY = texture(tex, uv + vec2(0.0, o.y)) - texture(tex, uv - vec2(0.0, o.y));\n    return 20.0*sqrt(dX * dX + dY * dY);\n}\n\nvec3 getPC(vec3 c) {\n    float t =c.r+c.b+c.g;\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 drawSomething2(vec2 uv, vec3 col){ float d = abs(0.5-uv.x) + abs(0.5-uv.y) -0.2; if(d<0.){return col;}else{return mix(col, vec3(1), d*15.) ;} }\nvec3 drawSomething(vec2 uv, vec3 col){ float d = distance(uv, vec2(0.5, 0.5)) - 0.2718; if(d<0.){return col;}else{return mix(col, vec3(1), d*15.) ;} }\n\nvec2 getOUV(vec2 suv, vec4 sq){ \n    vec2 nuv = vec2(sq.x + ((sq.z-sq.x)*suv.x), sq.y + ((sq.w-sq.y)*suv.y));\n    nuv.x = clamp(nuv.x,sq.x+0.003,sq.z-0.003);\n    nuv.y = clamp(nuv.y,sq.y+0.003,sq.w-0.003);\n    \n    return nuv;\n}\n\nvec2 getSUV(vec2 uv, vec4 sq){  return vec2 ( (uv.x-sq.x) / (sq.z-sq.x) , (uv.y-sq.y) / (sq.w-sq.y) ); }\n\nvec3 getTX(vec2 uv){ return texture(iChannel0, uv, 0.).rgb; }\n\nbool isin(vec2 co, vec4 sq){ return ( co.x >= sq.x && co.x <= sq.z && co.y >= sq.y && co.y <= sq.w ); }\n\nvec3 warp(int wt, float wp, vec2 suv, vec4 sq){\n float rad, angle; vec2 auv;\n    switch (wt) {\n    case 0:\n    return getTX(getOUV(suv, sq)).gbr;\n    case 1:\n    return getPC(getTX(getOUV(suv, sq)));\n    case 2:\n    return hsl2rgb(getTX(getOUV(suv, sq)));\n    case 3:\n    return getTX(getOUV(suv+vec2(0,cos(suv.x*15.)/15.), sq));\n    case 4:\n    return getTX(getOUV(suv+vec2(sin(suv.y*10.)/10.,0), sq));\n    case 5:\n    return getTX(getOUV(suv+vec2(sin(suv.y*8.)/8.,sin(suv.x*9.)/9.), sq));\n    case 6:\n    suv-=vec2(0,0.5);rad = distance(suv, vec2(0))*3.;angle = (atan(suv.x,suv.y)/3.141);\n    auv = vec2(rad*cos(angle),rad*sin(angle))-vec2(1,0.3);;return getTX(getOUV(auv, sq));\n    case 7:\n    suv+=vec2(0.5,0);rad = distance(suv, vec2(0.5,0))*2.;angle = (atan(suv.x,suv.y)/3.141);\n    auv = vec2(rad*cos(angle),rad*sin(angle))-vec2(1.,0);return getTX(getOUV(auv, sq));\n    case 8:\n    return getTX(getOUV(suv, sq))*drawSomething2(suv, vec3(1,0,0));\n    case 9:\n    return mix(getTX(getOUV(suv, sq)),drawSomething(suv, vec3(0,1,0)), suv.x);\n    case 10:\n    return absGradient(iChannel0, getOUV(suv, sq)).rgb;\n    case 11:\n    suv*=2.;\n    suv.x = fract(suv.x);suv.y = fract(suv.y);\n    return getTX(getOUV(suv, sq));\n    }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int smode = iFrame<2?0:int(ceil(texture(iChannel0, vec2(0), 0.).b));\n    int wmode = iFrame<2?-1:int(ceil(texture(iChannel0, vec2(0), 0.).r));\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float vb = 0.02;\n    float hb = vb/ar;\n    vec4 sc = vec4(hb,vb, (1./ar)-hb, 1.-vb);\n    vec2 ss = vec2( -hb+(1.-((1./ar)))/3., (1.-(vb*5.))/4. );\n    vec4  sc1 = vec4(sc.z+hb, vb, sc.z+hb+ss.x, vb+ss.y);\n    vec4  sc2 = sc1;  sc2.xz+= (hb+ss.x);\n    vec4  sc3 = sc2;  sc3.xz+= (hb+ss.x);\n    vec4  sc4 = sc1;  sc4.yw+= (vb+ss.y);\n    vec4  sc5 = sc2;  sc5.yw+= (vb+ss.y);\n    vec4  sc6 = sc3;  sc6.yw+= (vb+ss.y);\n    vec4  sc7 = sc4;  sc7.yw+= (vb+ss.y);\n    vec4  sc8 = sc5;  sc8.yw+= (vb+ss.y);\n    vec4  sc9 = sc6;  sc9.yw+= (vb+ss.y);\n    vec4 sc10 = sc7; sc10.yw+= (vb+ss.y);\n    vec4 sc11 = sc8; sc11.yw+= (vb+ss.y);\n    vec4 sc12 = sc9; sc12.yw+= (vb+ss.y);\n    fragColor = vec4(0.8);\n    int wm = -1;\n    vec4 scc = sc1;\n    if (isin(uv,  sc1)) { wm=0;scc=sc1; }\n    if (isin(uv,  sc2)) { wm=1;scc=sc2; }\n    if (isin(uv,  sc3)) { wm=2;scc=sc3; }\n    if (isin(uv,  sc4)) { wm=3;scc=sc4; }\n    if (isin(uv,  sc5)) { wm=4;scc=sc5; }\n    if (isin(uv,  sc6)) { wm=5;scc=sc6; }\n    if (isin(uv,  sc7)) { wm=6;scc=sc7; }\n    if (isin(uv,  sc8)) { wm=7;scc=sc8; }\n    if (isin(uv,  sc9)) { wm=8;scc=sc9; }\n    if (isin(uv, sc10)) { wm=9;scc=sc10; }\n    if (isin(uv, sc11)) { wm=10;scc=sc11; }\n    if (isin(uv, sc12)) { wm=11;scc=sc12; }\n    if(wm>-1){fragColor = vec4( warp(wm,0.,getSUV(uv, scc), sc) ,1); }\n    \n    if(iMouse.z>0.){\n    \n    if (isin(iMouse.xy/iResolution.xy,  sc1)) { wmode=0; }\n    if (isin(iMouse.xy/iResolution.xy,  sc2)) { wmode=1; }\n    if (isin(iMouse.xy/iResolution.xy,  sc3)) { wmode=2; }\n    if (isin(iMouse.xy/iResolution.xy,  sc4)) { wmode=3; }\n    if (isin(iMouse.xy/iResolution.xy,  sc5)) { wmode=4; }\n    if (isin(iMouse.xy/iResolution.xy,  sc6)) { wmode=5; }\n    if (isin(iMouse.xy/iResolution.xy,  sc7)) { wmode=6; }\n    if (isin(iMouse.xy/iResolution.xy,  sc8)) { wmode=7; }\n    if (isin(iMouse.xy/iResolution.xy,  sc9)) { wmode=8; }\n    if (isin(iMouse.xy/iResolution.xy, sc10)) { wmode=9; }\n    if (isin(iMouse.xy/iResolution.xy, sc11)) { wmode=10; }\n    if (isin(iMouse.xy/iResolution.xy, sc12)) { wmode=11; }\n    \n    if(smode==0 && wmode>-1){smode=1;}\n    if(smode==3 && wmode>-1){smode=1;}\n    }\n\n    if (isin(uv, sc)) {\n        if(smode==0) {\n            fragColor = vec4(drawSomething(getSUV(uv,sc), vec3(0,0.5,1)), 1);\n        } else if(smode==1){ \n            fragColor = vec4( warp(wmode,0.,getSUV(uv, sc), sc) ,1);\n        } else if(smode>1){ \n            fragColor = vec4(getTX(getOUV(getSUV(uv, sc), sc)),1);\n        }\n    }\n    if(smode==1){smode=2;wmode=-1;}\n    if(smode==2 && iMouse.z<0.){smode=3;}\n    if(floor(fragCoord) == vec2(0)){fragColor = vec4(float(wmode), 0, float(smode), 1);}\n\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3fV3WV",
    "date": "1748540377",
    "viewed": 279,
    "name": "Buffer View Example",
    "description": "Use this code on your image tab to view the four different buffers as thumbnails.\nClick on thumbnail to see it in main window",
    "likes": 14,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "debug",
     "buffer",
     "buffers"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* Use this code on your image tab to view the four different buffers as thumbnails.\nRemember to set up the four buffers in the iChannel screens at the bottom.\nClick on thumbnail to see it in main window\nUsing \"Blue Porcelain v2\" https://shadertoy.com/view/3XS3RV as an example\n*/\n\n// set this to 0 to only show thumbs on mouse down\n#define ALWAYSSHOW 1  \nvec2 getOUV(vec2 suv, vec4 sq){ vec2 nuv = vec2(sq.x + ((sq.z-sq.x)*suv.x), sq.y + ((sq.w-sq.y)*suv.y)); return nuv;}\nvec2 getSUV(vec2 uv, vec4 sq){  return vec2 ( (uv.x-sq.x) / (sq.z-sq.x) , (uv.y-sq.y) / (sq.w-sq.y) ); }\nbool isin(vec2 co, vec4 sq){ return ( co.x >= sq.x && co.x <= sq.z && co.y >= sq.y && co.y <= sq.w ); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float vb = 0.02;\n    float hb = vb/ar;\n    float th = (1. - (vb*5.))/4.;\n    float tw = th*ar/2.;\n    vec4  sc1 = vec4(1.-(tw+hb), vb, 1.-hb, vb+th);\n    \n    vec4  sc2 = sc1;  sc2.yw += (vb+th);\n    vec4  sc3 = sc2;  sc3.yw += (vb+th);\n    vec4  sc4 = sc3;  sc4.yw += (vb+th);\n    \n   if(isin(muv, sc1)){fragColor = texture(iChannel0, uv, 0.);}\n   else if(isin(muv, sc2)){fragColor = texture(iChannel1, uv, 0.);}\n   else if(isin(muv, sc3)){fragColor = texture(iChannel2, uv, 0.);}\n   else if(isin(muv, sc4)){fragColor = texture(iChannel3, uv, 0.);}\n   else {\n       \n         //If you want to do more processing in the Image tab for a fifth final image, do it here.\n         vec3 col = sqrt( texture(iChannel3, uv, 0.).rgb );\n         fragColor = vec4(col, 1.);\n         \n         //And if you already have a mainImage function in the Image tab, you can just rename it mainImage0\n         //And call it with:\n         //mainImage0(fragColor, fragCoord);\n       \n         // Otherwise just copy the buffer:\n         // fragColor = texture(iChannel3, uv, 0.)\n       \n   }\n   \n   if(iMouse.z>0. || ALWAYSSHOW ==1){\n       if(isin(uv, sc1)){fragColor = texture(iChannel0, getSUV(uv,sc1), 0.);}\n       if(isin(uv, sc2)){fragColor = texture(iChannel1, getSUV(uv,sc2), 0.);}\n       if(isin(uv, sc3)){fragColor = texture(iChannel2, getSUV(uv,sc3), 0.);}\n       if(isin(uv, sc4)){fragColor = texture(iChannel3, getSUV(uv,sc4), 0.);}\n   }\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// todo: implement sweep amt\nvec2 mouse;\n\n////////////////////////////////////////////////////////////////\n// BOILERPLATE UTILITIES...................\nconst float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\nfloat opI( float d1, float d2) { return max(d1,d2); }\n\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float a){return .5+.5*sin(a);}\nfloat ncos(float a){return .5+.5*cos(a);}\n\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    return length(uv - origin) - radius;\n}\n// 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\n{\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\n}\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n// returns -.5 to 1.5. i think.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\t\n}\nfloat noise01(vec2 p)\n{\n    return clamp((noise(p)+.5)*.5, 0.,1.);\n}\n// debug function to convert distance to color, revealing sign.\nvec3 dtocolor(vec3 inpColor, float dist)\n{\n    vec3 ret;\n    if(dist > 0.)\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\n    else\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\n    return ret;\n}\n\nfloat smoothf(float x)\n{\n    return x*x*x*(x*(x*6. - 15.) + 10.);\n}\n\n////////////////////////////////////////////////////////////////\n// APP CODE ...................\n\n// this function will produce a line with brush strokes. the inputs are such\n// that you can apply it to pretty much any line; the geometry is separated from this function.\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\n{\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\n\n    if(iMouse.z > 0.)\n    {\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\n    \tfloat okthen = 42.;// NOP\n    }\n    \n    // warp the position-in-line, to control the curve of the brush falloff.\n    if(posInLineY > 0.)\n    {\n        float mouseX = 200. == 0. ? 0.2 : (200. / iResolution.x);\n\t   posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\n        //posInLineY = pow(posInLineY, (pow(200.,2.) * 15.) + 1.5);\n        \n    }\n\n    // brush stroke fibers effect.\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\n    float strokeTexture = 0.\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\n        ;\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\n    // fade out the end of the stroke by shifting the noise curve below 0\n    const float strokeAlphaBoost = 1.09;\n    if(posInLineY > 0.)\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.8));// fade out\n    else\n        strokeAlpha *= strokeAlphaBoost;\n\n    strokeAlpha = smoothf(strokeAlpha);\n    \n    // paper bleed effect.\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\n paperBleedAmt = 400.;// disable paper bleed    \n    \n    // blotches (per stroke)\n    //float blotchAmt = smoothstep(2.,28.5,magicBox(vec3(uvPaper, uvLine.x)));\n    //blotchAmt *= (strokeAlpha+0.1);\n    //strokeAlpha += blotchAmt;\n\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\n    alpha = clamp(alpha, 0.,1.);\n    return mix(inpColor, brushColor.rgb, alpha);\n}\n\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\n    mat2 rotMat = rot2D(lineAngle);\n\n    float lineLength = distance(p2_, p1_);\n    // make an axis-aligned line from this line.\n    vec2 tl = (p1_ * rotMat);// top left\n    vec2 br = tl + vec2(0,lineLength);// bottom right\n    vec2 uvLine = uv * rotMat;\n\n    // make line slightly narrower at end.\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\n    \n    // wobble it around, humanize\n    float res = min(iResolution.y,iResolution.x);\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\n    uvLine = tl - uvLine;\n    \n    vec2 lineSize = vec2(lineWidth, lineLength);\n    \n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\n                                d, inpColor, brushColor);\n    return ret;\n}\n\n// returns:\n// xy = uvLine\n// z = radius\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\n{\n    vec2 humanizedUVLine = uvLine;\n    \n\t// offsetting the circle along its path creates a twisting effect.\n    float twistAmt = .24;\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\n    humanizedUVLine.x += linePosY * twistAmt;\n    \n    // perturb radius / x\n    float humanizedRadius = radius_;\n    float res = min(iResolution.y,iResolution.x);\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n    \n    return vec3(humanizedUVLine, humanizedRadius);\n}\n\n// there's something about calling an Enso a \"donut\" that makes me giggle.\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n{\n\tvec2 uvLine = uv - o;\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\n    angle = mod(angle-angleStart+pi, pi2);\n    if(!clockwise)\n        angle = pi2 - angle;\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\n    uvLine = vec2(\n        radius_ - length(uvLine),\n        angle / pi2 * lineLength\n    );\n    \n    // make line slightly narrower at end.\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\n    \n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n    vec2 humanizedUVLine = hu.xy;\n    float humanizedRadius = hu.z;\n\n    float d = opS(sdCircle(uv, o, humanizedRadius),\n                  sdCircle(uv, o, humanizedRadius));\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\n\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\n    \n    // do the same but for before the beginning of the line. distance field is just a single point\n    vec3 ret2 = vec3(1);\n    if(angle > pi)\n    {\n        uvLine.y -= lineLength;\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n        humanizedUVLine = hu.xy;\n        humanizedRadius = hu.z;\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\n        d = distance(uv, strokeStartPos);\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\n\t}\n    return min(ret, ret2);\n}\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n\n// Blue Porcelain specific code below\nfloat lips(vec2 a , vec2 b, float h, vec2 p){\n    float col = 0.;\n    if(p.x>a.x && p.x<b.x){col = 1.;}\n    float sc = 1./h/(b.x-a.x);\n    float bottom = (a.y - sin((a.x-p.x)/(b.x-a.x)*3.1416)/(sc*2.7)) - p.y;\n    //float f = smoothstep(-1.0, 1000.5, bottom);col = mix(1.,0.5, f);\n    if(col==1. && bottom>0.) {col =1.0;} else {col = 0.;}\n    //col=bottom;\n    float dist = (b.x-a.x)/4.5;\n    a.x+=dist;b.x-=dist;\n    if(col==1. && p.y>(a.y + sin((a.x-p.x)/(b.x-a.x)*9.423)/(sc*20.))) {col = 1.;} else {col = 0.;}\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1);\n    vec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));\n    // Caching output - if we're on the first frame or the resolution has changed, draw everything.\n    uv.y-=0.5;\n    if(iFrame<2 || texelFetch(iChannel0, ivec2(0), 0).r != iResolution.x){\n\n        \n        float yo = sin(-uv.x*pi*0.5)*0.2;\n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.03,.5),1.),vec2(0.4, -0.35+yo ),vec2(0.25, 0.12+yo), 0.05);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.1, -0.24 ),vec2(0.9, -0.6), 0.01);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.1, -0.1 + (sin((uv.x+0.1) * 25.) * 0.03)),vec2(0.85, -0.6), 0.01);                    \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.09, -0.12 ),vec2(0.13, -0.17 ), 0.001);\n              \n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.1, -0.24 ),vec2(-0.9, -0.6), 0.02);\n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.1, -0.1 - (sin((uv.x+0.1) * 25.) * 0.03)),vec2(-0.85, -0.5), 0.01);                    \n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.09, -0.12),vec2(-0.13, -0.17 ), 0.001);\n//col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.4),vec2(0.32, .245+yo),vec2(0.2, .205+yo), 0.002);\n        vec2 sps = vec2(0.25,-0.01);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,4.0,6.6,0.0001,true);\n        sps+=vec2(-0.015,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,3.0,1.6,0.03,true);\n        sps+=vec2(0.07,0.07);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,5.0,6.6,0.0001,true);\n        sps+=vec2(0.015,-0.0);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,3.0,1.6,0.03,true);\n        \n        sps = vec2(-0.18,0.12);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,1.0,6.6,0.0001,true);\n        sps+=vec2(-0.01,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,-3.0,1.6,0.02,true);\n        sps+=vec2(0.05,0.05);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,1.0,6.6,0.0001,true);\n        sps+=vec2(0.01,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,-3.0,1.6,0.02,true);\n//colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n        sps = vec2(-0.23,-0.3);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.3,6.3,5.1,0.02,false);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.2,6.3,5.1,0.02,false);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.15,6.3,5.1,0.015,false);\n        sps+=vec2(-0.05,0.03);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.2,6.3,5.1,0.04,false);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.25,6.3,5.1,0.04,false);\n        \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.24, 0.15 + (sin((uv.x+0.1) * 25.) * 0.06)),vec2(-1.3, -1.3), 0.07);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.2, -0.2 + (sin((uv.x+0.1) * 25.) * 0.06)),vec2(-1.3, -1.0), 0.04);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.25 + sin(uv.y * 25.) * 0.03, -0.0 - (sin(uv.x * 15.) * 0.04)),vec2(0.8, -2.5), 0.03);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.55 + sin(uv.y * 25.) * 0.03, -0.4 - (sin(uv.x * 15.) * 0.04)),vec2(0.8, -2.), 0.06);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.55 + sin(uv.y * 25.) * 0.07, -0.4 - (sin(uv.x * 15.) * 0.06)),vec2(-0.8, -2.), 0.05);\n         col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.4 + sin(uv.y * 25.) * 0.07, -0.1 - (sin(uv.x * 15.) * 0.06)),vec2(1.2, -1.5), 0.06);    \n         col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.0 + sin(uv.y * 25.) * 0.07, -0.9 - (sin(uv.x * 15.) * 0.06)),vec2(0.0, -1.9), 0.12);    \n\ncol = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.0, -0.44),0.44,-2.,5.1,0.06,false);\n        \n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.09,0.0,0.3,0.0002,true);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.12,0.0,0.3,0.0002,true);\n\n       // if(lips(vec2(0.27, 0.14), vec2(0.385, 0.15), 0.8, uv)>0.){col = vec3(.0,.1,.7);}\n       float lp = lips(vec2(-0.12, 0.13), vec2(0.12, 0.13), 0.9, uv);\n        if(lp>0.){col = vec3(.0,.1,.7)*lp;}\n\n        \n        //col = colorBrushStroke(vec2(0.1,0.1), vec2(0.1,0.1), vec2(0.1,0.1), sdCircle(uv, vec2(0.1,0.1), 0.1), vec3(1,0,0), vec4(0,1,0,1));\n        \n        if(ivec2(fragCoord.xy) == ivec2(0)){ col.r = iResolution.x;}// Store resolution in 0,0 pixel\n    } else {\n       // We've already drawn everything, use buffer instead\n      col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n  }\n   \n\n\n       \n\n    fragColor = vec4(col, 1.);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\n\n\nfloat sdSphere( in vec3 p, in float r)\n{\n    return length(p)-r;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n// The MIT License\n// Copyright  2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    return -opSmoothUnion(d1,-d2,k);\n    \n    //float h = max(k-abs(-d1-d2),0.0);\n    //return max(-d1, d2) + h*h*0.25/k;\n}\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    //vec3 q = abs(p)-h;\n    //return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n// Euclidean distance to a capped torus\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Bottomless depth https://www.shadertoy.com/view/tsBXRh\n// Exploring procedural painting\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.03.17\n// Using code from:\n// Inigo Quilez (shadertoy.com/view/Xds3zN)\n// Morgan McGuire (shadertoy.com/view/4dS3Wd)\n\nconst float zoomSpeed = 0.05;\nconst float noiseScale = 4.;\nconst float noiseSpeed = 0.0;\n\nconst float PI = 3.1415;\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\nfloat fbm (vec3 p) {\n  float amplitude = .5;\n  float result = 0.0;\n  for (float index = 0.0; index <= 5.0; ++index) {\n    result += noise(p / amplitude) * amplitude;\n    amplitude /= 2.;\n  }\n  return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\nvec2 uv = fragCoord.xy/iResolution.xy;\nif(iFrame<30){\n  vec3 color = vec3(1);\n  float timeline = iTime*zoomSpeed;\n  vec2 unit = 1./iResolution.xy;\n  \n  vec2 p = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  float stage = floor(timeline);\n  float ratio = fract(timeline);\n  const float iterations = 3.;\n  float spawn = 1.;\n  float zoom = .5;\n  float scale = noiseScale * iResolution.y / 320.;\n  for (float index = iterations; index > 0.; --index) {\n    ratio = mod(ratio+1./iterations, 1.);\n    vec3 s = vec3(p*scale*(zoom-ratio*zoom), 1. + timeline*noiseSpeed);\n    float salty = fbm(s) * 2. - 1.;\n    float angle = salty * PI * 8.;\n    uv += vec2(cos(angle),sin(angle)) * unit * sin(ratio*PI);\n    spawn *= 1. - abs(sin(angle)) * sin(ratio*PI);\n  }\n  color *= spawn;\n  float blend = (.5+.5*(1.-spawn));\n  fragColor = texture(iChannel0, uv)*blend + (1.-blend)*vec4(color, 1);\n  }\nelse{fragColor = texture(iChannel0, uv);}\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame<30){\n        fragColor = texture(iChannel0, (uv*1.45));\n        if(fragColor.r>0.25){\n            fragColor.g=0.1; fragColor.b=0.1;fragColor.r*=1.5;\n        } else if(fragColor.r>0.15){fragColor.g=0.1; fragColor.r=0.1;fragColor.b=0.7;}else{fragColor = vec4(1);}\n    } else {fragColor = texture(iChannel1, uv);}\n    }",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Blue Porcelain\" by Cotterzz. https://shadertoy.com/view/W3XGWS\n// 2025-04-10 04:23:43\n\n// This is my first attempt at using SDFs and raymarching\n// It's a bit ambitious, and is still very much a work in progress.\n// There's lots more I want to do with it, but I have some tidying and optimisation to look into before I take it any further.\n// --\n// Based on/inspired by Bao Pham's painting 'Blue Porcelain' https://arthur.io/art/bao-pham/blue-porcelain\n// Uses code and functions from the following shaders:\n// \"Bottomless depth\" by leon       https://www.shadertoy.com/view/tsBXRh\n// \"Capped torus - distance\" by iq. https://www.shadertoy.com/view/tl23RK\n// \"Elongation SDF\" by iq.          https://www.shadertoy.com/view/Ml3fWj\n// \"Vesica Segment\" by iq.          https://www.shadertoy.com/view/Ds2czG\n// \"Brush Experiment 3\" by 104      https://www.shadertoy.com/view/ltj3Wc\n// \"Magic Fractal\" by dgreensp      https://www.shadertoy.com/view/4ljGDd\n// --\n// 2025-03-31 04:38:41\n// Copyright/licensing of forked code belongs to respective artists/authors.\n// Everything else assembled here is the work of John Cotterell johnmdcotterell@gmail.com\n// and cannot be use outside shadertoy without permission.\n\n#define AA 2\n// The porcelain looks better with anti-aliasing, but it tanks the fps on slower machines.\n// 1 is off, 2 is 2x2 AA, 3 is 3x3 AA etc..\n\n#define SAA 1\n// Selective anti-aliasing tries to target edges and doesn't look quite as good, but is faster.\n// 1 is off, 2 is on\n\nint area = 0;\nvec2 facepos = vec2(0);\nbool necka = false;\nbool roses = false;\nfloat sdHead( vec3 p ){\n    // TOP - Cranium\n\n    float cran = sdSphere(p-vec3(0,0,0.03),0.35);\n    // BOTTOM - Jaw/Cheekbones\n    vec2 os = vec2(-0.14,0.05);\n    float ms = 0.127;\n    vec3 ql = p - vec3(ms,os);\n    vec3 qr = p - vec3(-ms,os);\n    ql = ql*rotateZ(0.26);\n    qr = qr*rotateZ(-0.26);\n    ql = ql*rotateX(0.42);\n    qr = qr*rotateX(0.42);\n    vec3 a = vec3(0.,-0.4, 0.0);\n    vec3 b = vec3( 0., 0.4, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.105/l);\n    float jaw = opSmoothUnion(sdVerticalVesicaSegment( ql-a, l, wv*0.85 ) - wv*0.15, \n    sdVerticalVesicaSegment( qr-a, l, wv*0.85 ) - wv*0.15, 0.07);\n    cran = opSmoothUnion( cran, jaw, 0.03);\n    // SHAPING - sides\n    float d2 = sdRoundBox(p-vec3(0.74,-0.4,-0.15), vec3(0.4,0.6,0.4), 0.02 ); \n    float d1 = sdRoundBox(p-vec3(-0.74,-0.4,-0.15), vec3(0.4,0.6,0.4), 0.02); \n\n    cran = opSmoothSubtraction(d2,opSmoothSubtraction(d1,cran, .2), .2);\n    // SHAPING - top\n    float d6 = sdRoundBox(p-vec3(0.,0.75,-0.0), vec3(0.4,0.4,0.4), 0.04 ); \n    cran = opSmoothSubtraction(d6,cran,.52);\n    // SHAPING - front\n    float d7 = sdRoundBox(p-vec3(0.,0.25,0.77), vec3(0.4,0.4,0.4), 0.01 ); \n    cran = opSmoothSubtraction(d7,cran,.15);\n    // Eye Sockets\n    float d5 = sdRoundBox(p-vec3(0.0,-0.21,0.385), vec3(0.18,0.001,0.001), 0.06 );\n    cran = opSmoothSubtraction( d5, cran, .04);\n    // nose\n    float nose = sdRoundCone(   p-vec3( 0.0,-0.32, 0.32), vec3(0.0,0.0,0), vec3(0.0,0.2,-0.06), 0.033, 0.01);\n    nose = opSmoothUnion( nose, sdRoundCone(   p-vec3( 0.0,-0.34, 0.3), vec3(-0.026,0,0), vec3(0.026,0,0), 0.015, 0.015), 0.03);\n    float nos = sdSphere(p-vec3(0.,-0.21,0.45), 0.11);\n    nose = opSmoothSubtraction( nos, nose, .08);\n    cran = opSmoothUnion( cran, nose, 0.02);\n    \n    \n    // Eyes\n    float eyel = sdSphere(p-vec3(0.11,-0.22,0.257), 0.035);\n    \n    \n    float eyer = sdVerticalVesicaSegment(p-vec3(-0.15,-0.43,0.2), 0.35, 0.23);\n    \n    eyer+=sin(p.y*70.)/300.;\n    eyer+=sin(p.x*80.)/400.;\n    eyer+=sin(p.z*90.)/500.;\n    if(eyer<0.01){roses = true;}\n    cran = opSmoothUnion( cran, eyer, 0.01);\n    \n    cran = opSmoothUnion( cran, eyel, 0.03);\n\n    float fan = sdRoundBox(p-vec3(0.,0.37,-0.7), vec3(0.8,0.8,0.8), 0.01 ); \n    \n    cran = min(fan,cran);\n\n    if(cran<0.001){area = 1;facepos = p.xy;}\n    if(fan<0.02){area = 2;facepos = p.xy;}\n    \n    return cran;\n}\n\nfloat map( in vec3 pos )\n{\n    float d = 1e10;\n    pos *= 0.9;\n    pos = pos*rotateZ(-0.08);\n    // Shoulders-Arms-Torso\n    vec3 q = pos - vec3(0.0,0.0,0.0);\n    q.z-=0.3;\n    q.y+=1.8 - q.x/20.;\n    q.x+=0.35 + q.y/20.;;\n    q = q*rotateX(1.7);\n    q = q*rotateZ(0.4);\n    q = q*rotateY(0.25);\n    float an = 1.0;\n    vec2 c = vec2(sin(an),cos(an));\n    vec4 w = opElongate( q, vec3(0.13,0.27,0.78) );\n    float shoulder = sdCappedTorus(w.xyz, c, 0.7, 0.2);\n    shoulder = shoulder+ sin((1.75+q.x)*3.)/15.;\n    shoulder = shoulder+0.04;\n    d = min( d, shoulder);\n    // Collar Bones\n    vec3 qt = pos - vec3(-0.8,-1.1,-0.7);\n    float collar = rounding( udTriangle( qt, vec3(0.6,0.0,0.1), vec3(0.4,-0.7,0.2), vec3(-0.1,-0.2,0.03) ), 0.05 );\n    collar = opSmoothUnion(collar, rounding( udTriangle( qt, vec3(0.7,0.0,0.1), vec3(0.8,-0.7,0.2), vec3(1.1,0.2,0.4) ), 0.01 ), 0.1);\n    d = opSmoothUnion(d, collar , 0.13);\n\n    // Neck\n     vec3 qv = pos - vec3(0.2,-1.5,-0.3);\n     vec3 a = vec3(0.,-0.2, 0.0);\n     vec3 b = vec3( 0., 0.3, 0.0);\n   float l = length(b-a);\n    qv = pos - vec3(-0.2,-0.9,-0.55);\n    qv = qv*rotateX(-0.3);\n    float neck = sdCylinder(qv, vec2(0.16, 0.65));\n    \n    d = opSmoothUnion( d, neck, 0.2);\n    if(d<0.01){necka=true;}\n    // Head\n    vec3 qh = pos - vec3(-0.15,-0.12,-0.36);\n    qh = qh*rotateY(-0.9-(0.1*sin(iTime/1.5)));\n    float head = sdHead(qh/1.03);\n    d = opSmoothUnion( d, head , 0.15);\n    return d;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n     // camera movement\t\n\tfloat an = 0.8+(0.2*sin(iTime/1.5));\n    //float an = iMouse.x/100.;\n\tvec3 ro = vec3( 1.8*cos(an), 0.3,1.8*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 edge = ww;\n    float ed = 0.;\n    vec3 ndif = vec3(0);\n    bool close = false;\n    bool miss = false;\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    // render\n    vec3 tot = vec3(0.0);\n    int count = 0;\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    #if SAA<2\n    for( int n=0; n<AA; n++ )\n    #endif\n    {\n        count++;\n        // pixel coordinates\n         #if SAA>1\n        int n = 0;\n        #endif\n        vec2 mn = vec2(float(m),float(n));\n        #if SAA>1\n        if(fragCoord.y>iResolution.y/2.){mn = mn.yx;}\n        #endif\n        vec2 o =  mn/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n                // shading/lighting\t\n        vec3 bg = vec3(0.6,0.65,0.8);\n        vec3 col = bg;\n        // paint blotches\n        float blotchAmt = smoothstep(30.,44.5, magicBox((p+5.2)*5.));\n        blotchAmt = pow(blotchAmt, 3.);// attenuate\n        blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\n        col *= vec3(1.-blotchAmt,1.-blotchAmt,1.0);\n        // grain\n        col.rgb += (rand(p)-.5)*.08;\n        col.rgb = saturate(col.rgb);\n        vec3 bd = col;\n        // raymarch\n        if(uv.x>0.4 && uv.x<0.7 && uv.y<0.7){\n        const float tmax = 5.0;\n \n        float cth = 0.01;\n        float mth = 0.02;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            #if SAA>1\n            close = h<cth?true:close;\n            miss = close&&h>mth?true:miss;\n            #endif\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n\n        vec2 hres = vec2(800., 450.)/iResolution.xy;\n       // edge = cross(edge, nor);\n            vec2 tpoz = facepos.xy*370.;tpoz.y+=234.;tpoz.x+=400.; tpoz = abs(tpoz); //350\n            vec2 rpoz = tpoz; rpoz.y += 116.;\n            vec3 alb = vec3(1);\n            if(area>0){alb = textureLod(iChannel0, (tpoz/hres)/iResolution.xy, 0.5).rgb;}\n        if( t<tmax )\n        {\n           \n            \n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            ed = 10.*(dot(nor,rd)+0.3);\n            //ndif = normalize(vec3(0,0,1)-nor);\n            edge = abs(cross(edge, nor));\n            vec3  lig = normalize(vec3(0.5,2.0,1.5));\n            //vec3  lig2 = normalize(vec3(1.0,0.5,1.5));\n            vec3 ref = reflect(rd, nor);\n            ndif = normalize(ref+nor);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            //float dif2 = clamp( dot(nor,lig2), 0.0, 1.0 );\n            \n            \n           // vec2 tpoy = pos.zy*200.;tpoy.y+=300.;tpoy.x-=450.; tpoy = abs(tpoy);\n \n            //if(necka){alb = vec3(0,1,0);}\n            //vec3 alb = texture(iChannel0, (tpoy.xy/hres)/iResolution.xy, 0.).rgb;\n            //alb=alb*alb;\n            //alb = min(alb, texture(iChannel0, (tpoz.xy/hres)/iResolution.xy, 0.).rgb*0.75);\n            //vec3 alb = texelFetch(iChannel0, ivec2(tpoy.xy/hres), 0).rgb*0.75;\n            //alb = min(alb, texelFetch(iChannel0, ivec2(tpoz.xy/hres), 0).rgb*0.75);\n            if(area!=2||pos.y<-0.7) {\n\n                if(necka){\n                  vec2 bpoz = pos.xy*570.;bpoz.y+=400.;bpoz.x+=600.; bpoz = abs(bpoz);\n                  alb = textureLod(iChannel0, (bpoz/hres)/iResolution.xy, 0.5).rgb;\n                  vec2 bpox = pos.xz*370.;bpox.y+=225.;bpox.x+=310.; bpox = abs(bpox);\n                  alb = min(alb,textureLod(iChannel0, (bpox/hres)/iResolution.xy, 0.5).rgb);\n                }\n\n                float spe = pow(max(0.0, dot(lig, ref)),32.0);\n                float sha = 1.;//calcSoftshadow( pos, lig, 0.03,3.0, 8.0 );\n                float amb = 0.55 + 0.2*dot(nor,normalize(vec3(0.0,1.0,0.0)));\n                if(roses){\n                  vec3 rcol = textureLod(iChannel1, (rpoz/hres)/iResolution.xy, 0.5).rgb;\n                  if(rcol.r>0.3&&rcol.g<0.3&&rcol.b<0.3){\n                        alb=rcol;\n                  }\n                  alb = min(alb, rcol);\n                  spe=0.;\n                  dif=0.4;\n                }\n                col =alb*amb + (spe*sha) + vec3(0.4,0.4,0.6)*dif/2.*sha;\n            } else {\n                col=min(col,alb);\n                \n            }\n            \n            if(alb.r>0.3&&alb.g<0.3&&alb.b<0.3){\n                col=alb;\n            }\n        }\n        }\n   \n        float f = smoothstep(-0.7,-1.0, p.y);\n        col = mix(col, bg, f);\n        // gamma        \n        \n\t    tot += col;\n    #if AA>1\n        #if SAA>1\n        vec3 edgef = fwidth(edge);\n        float edget = edgef.x+edgef.y+edgef.z;\n        if(edget<0.1&&!miss){m=AA;}//else{tot=vec3(0);}\n        #endif\n    }\n    tot /= float(count);\n    #endif\n    //if(miss){tot=vec3(0);}\n    //if(sqrt((ndif.x*ndif.x) + (ndif.y*ndif.y)+ (ndif.z*ndif.z))>1.){tot=ndif;}\n    \n\tfragColor = vec4( tot, 1.0 );\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfGGWc",
    "date": "1748580855",
    "viewed": 118,
    "name": "Equation Clock",
    "description": "A different equation every second, well the same equation, with the digits of the clock used as coefficients and exponents\n\nYou can scrub to different hours/minutes by dragging the canvas. Based on 24hr clock.",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "time",
     "quadratic",
     "equation",
     "challenge",
     "date",
     "maths",
     "hyperbolic",
     "parabolic",
     "unofficial",
     "byt3m3chanic"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// so if the time is 10:23:42\n// it plots the graph of z=(10xy)-(23xy)+(42xy)\n// (Or similar - I had to mix the exponents around for best results)\n// ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int sec = int(mod(iDate.w,60.));\n    int minute = int(mod(iDate.w/60.,60.));\n    int hour = int(mod(iDate.w/3600.,24.));\n    \n    if(iMouse.z>0.){\n       minute = int(floor((iMouse.y/iResolution.y) * 60.));\n       hour = int(floor((iMouse.x/iResolution.x) * 24.));\n    }\n    \n    float num = float(hour);\n    int h1 = int(mod(num / pow(10.0,1.),10.0));\n    int h2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(minute);\n    int m1 = int(mod(num / pow(10.0,1.),10.0));\n    int m2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(sec);\n    int s1 = int(mod(num / pow(10.0,1.),10.0));\n    int s2 = int(mod(num / pow(10.0,0.),10.0));\n\n\n    float hours =float(hour);\n    float minutes = float(minute);\n    float secs = float(sec);\n    float zoom = 10.;\n    \n    int MS = 6;\n    float xp = 1./iResolution.x;\n    float yp = 1./iResolution.y;\n    int count = 0;\n    float result = 0.;float result2 = 0.;\n    vec3 rf = vec3(0);\n    for( int m=0; m<MS; m++ ){\n        for( int n=0; n<MS; n++ ){\n            vec2 nuv = uv;\n            nuv.x +=( xp/float(MS))*float(n);\n            nuv.y += (yp/float(MS))*float(m);\n            vec2 guv = (nuv*zoom)-(zoom/2.);\n            float x = guv.x;\n            float y = guv.y;\n            result = -( p(x,m1) * p(y,s2) *hours )-( p(x,h1) * p(y,s1) * minutes)+( secs * p(x,h2) * p(y,m2) ) ;\n            count+=1;\n            rf+=getPC(result);\n        }\n    }\n    \n    rf /= float(count);\n\n    fragColor = vec4(rf,1.0);\n    \n    ivec2 letters = ivec2(34,10);\n    vec2 letterp = vec2(fract(uv.x * float(letters.x)), fract(uv.y * float(letters.y)));\n    int letter = int(floor(uv.x * float(letters.x)));\n    if(uv.y<1./float(letters.y)){ fragColor = texture(iChannel0, getLetter(letterp, letter, h1,h2,m1,m2,s1,s2), .0).rrra; }\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define lbracket letterpos = vec2(8.,13.); break;\n#define rbracket letterpos = vec2(9.,13.); break;\n#define times letterpos = vec2(10.,13.); break;\n#define minus letterpos = vec2(29.,29.); break;\n#define plus letterpos = vec2(27.,29.); break;\n#define X letterpos = vec2(8.,10.); break;\n#define Y letterpos = vec2(9.,10.); break;\n#define m1super letterpos = vec2(float(m1+1),12.); super=true; break;\n#define m2super letterpos = vec2(float(m2+1),12.); super=true; break;\n#define s1super letterpos = vec2(float(s1+1),12.); super=true; break;\n#define s2super letterpos = vec2(float(s2+1),12.); super=true; break;\n#define h1super letterpos = vec2(float(h1+1),12.); super=true; break;\n#define h2super letterpos = vec2(float(h2+1),12.); super=true; break;\n#define h1reg letterpos = vec2(float(h1),12.); break;\n#define h2reg letterpos = vec2(float(h2),12.); break;\n#define m1reg letterpos = vec2(float(m1),12.); break;\n#define m2reg letterpos = vec2(float(m2),12.); break;\n#define s1reg letterpos = vec2(float(s1),12.); break;\n#define s2reg letterpos = vec2(float(s2),12.); break;\n\nfloat p(in float a, in int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\nvec3 getPC(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec2 getLetter(vec2 p , int n, int h1, int h2, int m1, int m2, int s1, int s2){\n\n    vec2 letterpos = vec2(0);\n    \n    bool super = false;\n    \n    switch (n) {\n    case 0: letterpos = vec2(10.,10.); break;\n    case 1: letterpos = vec2(13.,12.); break;\n    case 2: lbracket\n    case 3: h1reg\n    case 4: h2reg\n    case 5: times\n    case 6: X\n    case 7: m1super\n    case 8: times\n    case 9: Y\n    case 10: s2super\n    case 11: rbracket\n    case 12: minus\n    case 13: lbracket\n    case 14: m1reg\n    case 15: m2reg\n    case 16: times\n    case 17: X\n    case 18: h1super\n    case 19: times\n    case 20: Y\n    case 21: s1super\n    case 22: rbracket\n    case 23: plus\n    case 24: lbracket\n    case 25: s1reg\n    case 26: s2reg\n    case 27: times\n    case 28: X\n    case 29: h2super\n    case 30: times\n    case 31: Y\n    case 32: m2super\n    case 33: rbracket\n    }\n    letterpos/=16.;\n    \n    if(super){if(p.x>0.25 && p.x<0.75 &&p.y>0.5){letterpos += -(1./16.) + p/8.; letterpos.x-=1./32.;} } else {letterpos+=p/16.;}\n\n    return letterpos;\n\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wcy3Wd",
    "date": "1748626164",
    "viewed": 91,
    "name": "Polynomial Clock v2",
    "description": "Version 2 - much better name, colour translation and improved text\nA different result every second, with the digits of the clock used as coefficients and exponents\nYou can scrub to different hours/minutes by dragging the canvas.",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "time",
     "equation",
     "challenge",
     "polynomial",
     "date",
     "maths",
     "bivariate",
     "unofficial",
     "byt3m3chanic"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Equation Clock\" by Cotterzz. https://shadertoy.com/view/tfGGWc\n// 2025-05-30 17:11:06\n\n// so if the time is 10:23:42\n// it plots the graph of z=(10xy)-(23xy)+(42xy)\n// (Or similar - I had to mix the exponents around for best results)\n// ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = fragCoord/iResolution.y;\n    cuv.x += 0.5 - (iResolution.x/iResolution.y)*0.5;\n    int sec = int(mod(iDate.w,60.));\n    int minute = int(mod(iDate.w/60.,60.));\n    int hour = int(mod(iDate.w/3600.,24.));\n    \n    if(iMouse.z>0.){\n       minute = int(floor((iMouse.y/iResolution.y) * 60.));\n       hour = int(floor((iMouse.x/iResolution.x) * 24.));\n    }\n    \n    float num = float(hour);\n    int h1 = int(mod(num / pow(10.0,1.),10.0));\n    int h2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(minute);\n    int m1 = int(mod(num / pow(10.0,1.),10.0));\n    int m2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(sec);\n    int s1 = int(mod(num / pow(10.0,1.),10.0));\n    int s2 = int(mod(num / pow(10.0,0.),10.0));\n\n\n    float hours =float(hour);\n    float minutes = float(minute);\n    float secs = float(sec);\n    float zoom = 8.; // use this to zoom\n    \n    int MS = 7;  // -------------------------------------- If performance is bad, lower this number\n    float xp = 1./iResolution.x;\n    float yp = 1./iResolution.y;\n    int count = 0;\n    float result = 0.;float result2 = 0.;\n    vec3 rf = vec3(0);\n    for( int m=0; m<MS; m++ ){\n        for( int n=0; n<MS; n++ ){\n            vec2 nuv = cuv;\n            nuv.x +=( xp/float(MS))*float(n);\n            nuv.y += (yp/float(MS))*float(m);\n            vec2 guv = (nuv*zoom)-(zoom/2.);\n            float x = guv.x;\n            float y = guv.y;\n            result = -( p(x,m1) * p(y,s2) *hours )-( p(x,h1) * p(y,s1) * minutes)+( secs * p(x,h2) * p(y,m2) ) ;\n            count+=1;\n            rf+=getPC(result);\n        }\n    }\n    \n    rf /= float(count);\n\n    fragColor = vec4(rf,1.0); vec4 fc = fragColor;\n    \n    float fdiff = (abs(fc.r-fc.g) + abs(fc.r-fc.b) + abs(fc.g-fc.b))/3.;\n    \n    fragColor = mix(vec4(0), fragColor, sqrt(fdiff));\n    //fragColor = sqrt(fragColor);\n    ivec2 letters = ivec2(34,13);\n    vec2 letterp = vec2(fract(uv.x * float(letters.x)), fract(uv.y * float(letters.y)));\n    int letter = int(floor(uv.x * float(letters.x)));\n    fragColor = mix(vec4(0), fragColor, min( 1. , (uv.y * float(letters.y)*0.8)-0.));\n    if(uv.y<1./float(letters.y)){\n        vec4 texColor = texture(iChannel0, getLetter(letterp, letter, h1,h2,m1,m2,s1,s2), .0);\n        if(texColor.a<0.55){fragColor = texColor.rrrr;}\n    }\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define lbracket letterpos = vec2(8.,13.); break;\n#define rbracket letterpos = vec2(9.,13.); break;\n#define times letterpos = vec2(10.,13.); break;\n#define minus letterpos = vec2(29.,29.); break;\n#define plus letterpos = vec2(27.,29.); break;\n#define X letterpos = vec2(8.,10.); break;\n#define Y letterpos = vec2(9.,10.); break;\n#define m1super letterpos = vec2(float(m1+1),12.); super=true; break;\n#define m2super letterpos = vec2(float(m2+1),12.); super=true; break;\n#define s1super letterpos = vec2(float(s1+1),12.); super=true; break;\n#define s2super letterpos = vec2(float(s2+1),12.); super=true; break;\n#define h1super letterpos = vec2(float(h1+1),12.); super=true; break;\n#define h2super letterpos = vec2(float(h2+1),12.); super=true; break;\n#define h1reg letterpos = vec2(float(h1),12.); break;\n#define h2reg letterpos = vec2(float(h2),12.); break;\n#define m1reg letterpos = vec2(float(m1),12.); break;\n#define m2reg letterpos = vec2(float(m2),12.); break;\n#define s1reg letterpos = vec2(float(s1),12.); break;\n#define s2reg letterpos = vec2(float(s2),12.); break;\n\nfloat p(in float a, in int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\nvec3 getPC(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec2 getLetter(vec2 p , int n, int h1, int h2, int m1, int m2, int s1, int s2){\n\n    vec2 letterpos = vec2(0);\n    \n    bool super = false;\n    \n    switch (n) {\n    case 0: letterpos = vec2(10.,10.); break;\n    case 1: letterpos = vec2(13.,12.); break;\n    case 2: lbracket\n    case 3: h1reg\n    case 4: h2reg\n    case 5: times\n    case 6: X\n    case 7: m1super\n    case 8: times\n    case 9: Y\n    case 10: s2super\n    case 11: rbracket\n    case 12: minus\n    case 13: lbracket\n    case 14: m1reg\n    case 15: m2reg\n    case 16: times\n    case 17: X\n    case 18: h1super\n    case 19: times\n    case 20: Y\n    case 21: s1super\n    case 22: rbracket\n    case 23: plus\n    case 24: lbracket\n    case 25: s1reg\n    case 26: s2reg\n    case 27: times\n    case 28: X\n    case 29: h2super\n    case 30: times\n    case 31: Y\n    case 32: m2super\n    case 33: rbracket\n    }\n    letterpos/=16.;\n    \n    if(super){if(p.x>0.25 && p.x<0.75 &&p.y>0.5){letterpos += -(1./16.) + p/8.; letterpos.x-=1./32.;} } else {letterpos+=p/16.;}\n\n    return letterpos;\n\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wctXzr",
    "date": "1748730899",
    "viewed": 111,
    "name": "Polynomial Clock 3.0",
    "description": "Constructs a polynomial from the digits in the time\nV3, lots more visual improvements. I think this is the final version\nClick on the canvas to see how it looks at other times.",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "math",
     "time",
     "graph",
     "equation",
     "challenge",
     "polynomial",
     "date",
     "maths",
     "bivariate",
     "unofficial",
     "byt3m3chanic"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Version 3.\n// Plots the graph to very high numbers as it gets near the edge, so most details are visible.\n// Added lighting effects.\n// Improved text with time at the top and colour coded numbers.\n\n\n// Fork of \"Polynomial Clock v2\" by Cotterzz. https://shadertoy.com/view/Wcy3Wd\n// 2025-05-30 18:24:31\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define lbracket letterpos = vec2(8.,13.); break;\n#define rbracket letterpos = vec2(9.,13.); break;\n#define times letterpos = vec2(10.,13.); break;\n#define minus letterpos = vec2(29.,29.); break;\n#define colon letterpos = vec2(10.,12.); break;\n#define plus letterpos = vec2(27.,29.); break;\n#define X letterpos = vec2(8.,10.); break;\n#define Y letterpos = vec2(9.,10.); break;\n#define m1super letterpos = vec2(float(m1+1),12.); super=true; break;\n#define m2super letterpos = vec2(float(m2+1),12.); super=true; break;\n#define s1super letterpos = vec2(float(s1+1),12.); super=true; break;\n#define s2super letterpos = vec2(float(s2+1),12.); super=true; break;\n#define h1super letterpos = vec2(float(h1+1),12.); super=true; break;\n#define h2super letterpos = vec2(float(h2+1),12.); super=true; break;\n#define h1reg letterpos = vec2(float(h1),12.); break;\n#define h2reg letterpos = vec2(float(h2),12.); break;\n#define m1reg letterpos = vec2(float(m1),12.); break;\n#define m2reg letterpos = vec2(float(m2),12.); break;\n#define s1reg letterpos = vec2(float(s1),12.); break;\n#define s2reg letterpos = vec2(float(s2),12.); break;\n\nfloat p(in float a, in int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\nvec3 getPC(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 getHC( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvec2 getLetter(vec2 p , int n, int h1, int h2, int m1, int m2, int s1, int s2){\n\n    vec2 letterpos = vec2(0);\n    \n    bool super = false;\n    \n    switch (n) {\n    case 0: letterpos = vec2(10.,10.); break;\n    case 1: letterpos = vec2(13.,12.); break;\n    case 2: lbracket\n    case 3: h1reg\n    case 4: h2reg\n    case 5: times\n    case 6: X\n    case 7: m1super\n    case 8: times\n    case 9: Y\n    case 10: s2super\n    case 11: rbracket\n    case 12: minus\n    case 13: lbracket\n    case 14: m1reg\n    case 15: m2reg\n    case 16: times\n    case 17: X\n    case 18: h1super\n    case 19: times\n    case 20: Y\n    case 21: s1super\n    case 22: rbracket\n    case 23: plus\n    case 24: lbracket\n    case 25: s1reg\n    case 26: s2reg\n    case 27: times\n    case 28: X\n    case 29: h2super\n    case 30: times\n    case 31: Y\n    case 32: m2super\n    case 33: rbracket\n    }\n    letterpos/=16.;\n    \n    if(super){if(p.x>0.25 && p.x<0.75 &&p.y>0.5){letterpos += -(1./16.) + p/8.; letterpos.x-=1./32.;} } else {letterpos+=p/16.;}\n\n    return letterpos;\n\n}\n\nvec3 getLCol(int n){\n\n    vec3 lettercol = vec3(1);\n    \n    switch (n) {\n    case 3: lettercol = vec3(0,1,0); break;\n    case 4: lettercol = vec3(0,1,0); break;\n    case 18: lettercol = vec3(0,1,0); break;\n    case 29: lettercol = vec3(0,1,0); break;\n    case 14: lettercol = vec3(1,0.6,0); break;\n    case 15: lettercol = vec3(1,0.6,0); break;\n    case 7: lettercol = vec3(1,0.6,0); break;\n    case 32: lettercol = vec3(1,0.6,0); break;\n    case 25: lettercol = vec3(0,0.8,1); break;\n    case 26: lettercol = vec3(0,0.8,1); break;\n    case 10: lettercol = vec3(0,0.8,1); break;\n    case 21: lettercol = vec3(0,0.8,1); break;\n    }\n\n    return lettercol;\n\n}\n\nvec2 getCLetter(vec2 p , int n, int h1, int h2, int m1, int m2, int s1, int s2){\n\n    vec2 letterpos = vec2(0);\n    \n    bool super = false;\n    \n    switch (n) {\n    case 0: h1reg\n    case 1: h2reg\n    case 2: colon\n    case 3: m1reg\n    case 4: m2reg\n    case 5: colon\n    case 6: s1reg\n    case 7: s2reg\n\n    }\n    letterpos/=16.;\n    \n    if(super){if(p.x>0.25 && p.x<0.75 &&p.y>0.5){letterpos += -(1./16.) + p/8.; letterpos.x-=1./32.;} } else {letterpos+=p/16.;}\n\n    return letterpos;\n\n}\n\nvec3 getCLCol(int n){\n\n    vec3 lettercol = vec3(1);\n    \n    switch (n) {\n    case 0: lettercol = vec3(0,1,0); break;\n    case 1: lettercol = vec3(0,1,0); break;\n    case 2: lettercol = vec3(1); break;\n    case 3: lettercol = vec3(1,0.6,0); break;\n    case 4: lettercol = vec3(1,0.6,0); break;\n    case 5: lettercol = vec3(1); break;\n    case 6: lettercol = vec3(0,0.8,1); break;\n    case 7: lettercol = vec3(0,0.8,1); break;\n    }\n\n    return lettercol;\n\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Equation Clock\" by Cotterzz. https://shadertoy.com/view/tfGGWc\n// 2025-05-30 17:11:06\n\n// so if the time is 10:23:42\n// it plots the graph of z=(10xy)-(23xy)+(42xy)\n// (Or similar - I had to mix the exponents around for best results)\n// ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = fragCoord/iResolution.y;\n    cuv.x += 0.5 - (iResolution.x/iResolution.y)*0.5;\n    \n    int sec = int(mod(iDate.w,60.));\n    int minute = int(mod(iDate.w/60.,60.));\n    int hour = int(mod(iDate.w/3600.,24.));\n    \n    if(iMouse.z>0.){\n       minute = int(floor((iMouse.y/iResolution.y) * 60.));\n       hour = int(floor((iMouse.x/iResolution.x) * 24.));\n    }\n    \n    float num = float(hour);\n    int h1 = int(mod(num / pow(10.0,1.),10.0));\n    int h2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(minute);\n    int m1 = int(mod(num / pow(10.0,1.),10.0));\n    int m2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(sec);\n    int s1 = int(mod(num / pow(10.0,1.),10.0));\n    int s2 = int(mod(num / pow(10.0,0.),10.0));\n\n\n    float hours =float(hour);\n    float minutes = float(minute);\n    float secs = float(sec);\n    float dc = 0.5 + distance(uv, vec2(0.5))/3.;\n    \n    float zoom = dc / pow(1.0 - dc*dc, 5.5); \n\n    //zoom = 3.;\n    int MS = 8;  // -------------------------------------- If performance is bad, lower this number\n    float xp = 1./iResolution.x;\n    float yp = 1./iResolution.y;\n    int count = 0;\n    float result = 0.;float result2 = 0.;\n    vec3 rf = vec3(0);\n    for( int m=0; m<MS; m++ ){\n        for( int n=0; n<MS; n++ ){\n            vec2 nuv = cuv;\n            nuv.x +=( xp/float(MS))*float(n);\n            nuv.y += (yp/float(MS))*float(m);\n            vec2 guv = (nuv*zoom)-(zoom/2.);\n            float x = guv.x;\n            float y = guv.y;\n            result = -( p(x,m1) * p(y,s2) *hours )-( p(x,h1) * p(y,s1) * minutes)+( secs * p(x,h2) * p(y,m2) ) ;\n            //result = -( p(x,m1) * cos(p(y,s2)) *hours )-sin( p(x,h1) * p(y,s1) * minutes)+( secs * cos(p(x,h2)) * sin(p(y,m2)) ) - p(atan( x/y ), s2)+atan(p(x, s1)/p(y,m2)); // :D\n            count+=1;\n            vec3 col = mix(getPC(result), getHC(vec3(result, 1.0, 0.5)), 0.35);\n            rf+=col;\n        }\n    }\n    \n    rf /= float(count);\n\n    fragColor = vec4(rf,1.0); vec4 fc = fragColor;\n    \n    float fdiff = (abs(fc.r-fc.g) + abs(fc.r-fc.b) + abs(fc.g-fc.b))/3.;\n    \n    fragColor = mix(vec4(0), fragColor, sqrt(fdiff));\n   \n\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 addLight(vec3 position, vec3 normal, vec3 colour, vec3 lcol, vec3 lpos){\n    vec3 ref = reflect(vec3(0.0, 0.0, -1.0), normal);\n    vec3 diff = lpos - position;\n    float ldist = length(diff);\n    diff = diff/ldist;\n    float specular = pow(max(0.0, dot(diff, ref)), 16.0);\n    float diffuse = max(0.0, dot(diff,normal));\n    vec3 col1 = colour*0.7;\n    vec3 col2 = colour*0.4*(lcol*diffuse);\n    col2 = col2+(lcol*specular);\n    return col1+col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n   vec2 co = fragCoord;\n   float scale  = 0.2 + iMouse.x/iResolution.x*16.;\n   vec3 col = vec3(0);\n    //-------------- find a better way to retrieve these values\n    int sec = int(mod(iDate.w,60.));\n    int minute = int(mod(iDate.w/60.,60.));\n    int hour = int(mod(iDate.w/3600.,24.));\n    \n    if(iMouse.z>0.){\n       minute = int(floor((iMouse.y/iResolution.y) * 60.));\n       hour = int(floor((iMouse.x/iResolution.x) * 24.));\n    }\n    \n    float num = float(hour);\n    int h1 = int(mod(num / pow(10.0,1.),10.0));\n    int h2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(minute);\n    int m1 = int(mod(num / pow(10.0,1.),10.0));\n    int m2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(sec);\n    int s1 = int(mod(num / pow(10.0,1.),10.0));\n    int s2 = int(mod(num / pow(10.0,0.),10.0));\n    //---------------------------------------------\n    // three sample plus dxdy\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    vec4 texa = texture(iChannel0, co/iResolution.xy, 0.);\n    vec4 texb = texture(iChannel0, (co+vec2(1,0))/iResolution.xy, 0.);\n    vec4 texc = texture(iChannel0, (co+vec2(0,1))/iResolution.xy, 0.);\n    float fda = (abs(texa.r-texa.g) + abs(texa.r-texa.b) + abs(texa.g-texa.b))/3.;\n    float fdb = (abs(texb.r-texb.g) + abs(texb.r-texb.b) + abs(texb.g-texb.b))/3.;\n    float fdc = (abs(texc.r-texc.g) + abs(texc.r-texc.b) + abs(texc.g-texc.b))/3.;\n    float ra = (texa.r+texa.g+texa.b)/3.;\n    float rb = (texb.r+texb.g+texb.b)/3.;\n    float rc = (texc.r+texc.g+texc.b)/3.;\n    ra = fda*ra;\n    rb = fdb*rb;\n    rc = fdc*rc;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    \n    float bounds = iResolution.y/1.6;\n    \n    if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.y;}\n    float dvh = 50.;// + (bounds/iResolution.y)*120.;\n    vec3 normal = normalize(vec3(dx*dvh, dy*dvh, ra));\n    \n    col = texa.rgb*2.*fda;//vec3(0.8,0.5+(ra/3.),0.4+(ra/3.));\n    \n    vec3 position = vec3(co/iResolution.xy, ra);\n    \n    vec3 lcol = vec3(3.5)*fda;//vec3(0,1,0);\n    vec3 lpos = vec3(3.,3.,5.);\n    \n    vec3 rend = addLight(position, normal, col, lcol, lpos);\n    \n    \n    fragColor =vec4(rend, 1.);\n    \n    //fragColor =vec4(vec3(ra), 1.); // uncomment to see raw height data from buffer A\n    \n    ivec2 letters = ivec2(34,16);\n    vec2 letterp = vec2(fract(uv.x * float(letters.x)), fract(uv.y * float(letters.y)));\n    int letter = int(floor(uv.x * float(letters.x)));\n    fragColor = mix(vec4(0), fragColor, min( 1. , (uv.y * float(letters.y)*0.8)));\n    if(uv.y<1./float(letters.y)){\n        vec4 texColor = texture(iChannel1, getLetter(letterp, letter, h1,h2,m1,m2,s1,s2), .0);\n        if(texColor.a<0.55){fragColor = texColor.rrrr; fragColor.rgb *= getLCol(letter);}\n    }\n    ivec2 cletters = ivec2(17,8);\n    int loffset =0;\n    vec2 cletterp = vec2(fract(uv.x * float(cletters.x)), fract(uv.y * float(cletters.y)));\n    int cletter = int(floor(uv.x * float(cletters.x)));\n    if(uv.y>(1./float(cletters.y))*float(cletters.y-1) && cletter>=loffset && cletter<8+loffset){\n        vec4 texColor = texture(iChannel1, getCLetter(cletterp, cletter-loffset, h1,h2,m1,m2,s1,s2), .0);\n        if(texColor.a<0.55){fragColor = texColor.rrrr; fragColor.rgb *= getCLCol(cletter-loffset);}\n    }\n     fragColor = sqrt(fragColor);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfcXRH",
    "date": "1748770292",
    "viewed": 127,
    "name": "Multiverse of Polynomial Madness",
    "description": "Just having some fun with random polynomials.\nClick on canvas to change multisampling level, from lowest on the left to highest on the right \nAlso, linear zoom at the bottom, more logarithmic at the top.",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "math",
     "time",
     "graph",
     "equation",
     "challenge",
     "polynomial",
     "date",
     "maths",
     "bivariate"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Polynomial Clock 3.0\" by Cotterzz. https://shadertoy.com/view/wctXzr\n// 2025-06-01 08:07:26\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float p(in float a, in int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\n\nfloat p(in float a, in float b){return pow(abs(a), b);}\nvec3 getPC(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 getHC( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = fragCoord/iResolution.y;\n    cuv.x += 0.5 - (iResolution.x/iResolution.y)*0.5;\n    \n    float dc = 0.3 + distance(uv, vec2(0.5));\n    \n    float zoom = dc / pow(1.0 - dc*dc, 1.5); \n\n    zoom = mix(5., zoom, (iMouse.y/iResolution.y)-0.01);\n    int MS = 1 + int((iMouse.x/iResolution.x)*12.); \n    float xp = 1./iResolution.x;\n    float yp = 1./iResolution.y;\n    int count = 0;\n    float result = 0.;float result2 = 0.;\n    vec3 rf = vec3(0);\n    for( int m=0; m<MS; m++ ){\n        for( int n=0; n<MS; n++ ){\n            vec2 nuv = cuv;\n            nuv.x +=( xp/float(MS))*float(n);\n            nuv.y += (yp/float(MS))*float(m);\n            vec2 guv = (nuv*zoom)-(zoom/2.);\n            float x = guv.x;\n            float y = guv.y;\n           \n            result = p(x, 2.+sin(iTime/1.6)*2.) * p(y, 2.+cos(iTime/2.4)*3.) * 2.+ sin(iTime/5.)*10.;\n            result -= p(x, 2.+sin(iTime/2.6)*3.) * p(y, 2.+cos(iTime/4.4)*2.) * 2.+ sin(iTime/10.)*5.;\n            result += sin(p(x, 2.+sin(iTime/2.6)*3.)) * p(y, 2.+cos(iTime/4.4)*2.) * 2.+ sin(iTime/10.)*5.;\n            result -= atan(p(x, 2.+sin(iTime/2.6)*3.) / p(y, 2.+cos(iTime/4.4)*2.)) * 2.+ sin(iTime/10.)*5.;\n            result += p(x, 2.+sin(iTime/4.6)*4.) / cos(p(y, 2.+cos(iTime/1.4)*3.)) * 2.+ sin(iTime/7.)*7.;\n             result *= p(x, sin(iTime/2.)*3.) * p(y, cos(iTime/3.7)*2.) * sin(iTime/10.);\n            count+=1;\n            vec3 col = mix(getPC(result), getHC(vec3(result, 1.0, 0.5)), 0.35);\n            rf+=col;\n        }\n    }\n    \n    rf /= float(count);\n\n    fragColor = vec4(rf,1.0); vec4 fc = fragColor;\n    \n    float fdiff = (abs(fc.r-fc.g) + abs(fc.r-fc.b) + abs(fc.g-fc.b))/3.;\n    \n    fragColor = mix(vec4(0), fragColor, sqrt(fdiff));\n   \n\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 addLight(vec3 position, vec3 normal, vec3 colour, vec3 lcol, vec3 lpos){\n    vec3 ref = reflect(vec3(0.0, 0.0, -1.0), normal);\n    vec3 diff = lpos - position;\n    float ldist = length(diff);\n    diff = diff/ldist;\n    float specular = pow(max(0.0, dot(diff, ref)), 16.0);\n    float diffuse = max(0.0, dot(diff,normal));\n    vec3 col1 = colour*0.7;\n    vec3 col2 = colour*0.4*(lcol*diffuse);\n    col2 = col2+(lcol*specular);\n    return col1+col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n   vec2 co = fragCoord;\n   float scale  = 0.2 + iMouse.x/iResolution.x*16.;\n   vec3 col = vec3(0);\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    vec4 texa = texture(iChannel0, co/iResolution.xy, 0.);\n    vec4 texb = texture(iChannel0, (co+vec2(1,0))/iResolution.xy, 0.);\n    vec4 texc = texture(iChannel0, (co+vec2(0,1))/iResolution.xy, 0.);\n    float fda = (abs(texa.r-texa.g) + abs(texa.r-texa.b) + abs(texa.g-texa.b))/3.;\n    float fdb = (abs(texb.r-texb.g) + abs(texb.r-texb.b) + abs(texb.g-texb.b))/3.;\n    float fdc = (abs(texc.r-texc.g) + abs(texc.r-texc.b) + abs(texc.g-texc.b))/3.;\n    float ra = (texa.r+texa.g+texa.b)/3.;\n    float rb = (texb.r+texb.g+texb.b)/3.;\n    float rc = (texc.r+texc.g+texc.b)/3.;\n    ra = fda*ra;\n    rb = fdb*rb;\n    rc = fdc*rc;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    \n    float bounds = iResolution.y/1.6;\n    \n    if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.y;}\n    float dvh = 50.;// + (bounds/iResolution.y)*120.;\n    vec3 normal = normalize(vec3(dx*dvh, dy*dvh, ra));\n    \n    col = texa.rgb*2.*fda;//vec3(0.8,0.5+(ra/3.),0.4+(ra/3.));\n    \n    vec3 position = vec3(co/iResolution.xy, ra);\n    \n    vec3 lcol = vec3(3.5)*fda;//vec3(0,1,0);\n    vec3 lpos = vec3(3.,3.,5.);\n    \n    vec3 rend = addLight(position, normal, col, lcol, lpos);\n    \n    \n    fragColor =vec4(rend, 1.);\n    \n    //fragColor =texa; // uncomment to see raw height data from buffer A\n    \n     fragColor = sqrt(fragColor);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WfdSzj",
    "date": "1749296243",
    "viewed": 90,
    "name": "Inverse Koch Fraccident",
    "description": "The inverse shape is similar but not quite the same (like a regular koch snowflake), but still interesting.\n",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "recursive",
     "square",
     "feedback",
     "buffer",
     "koch"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch Fraccident\" by Cotterzz. https://shadertoy.com/view/Wfd3Wl\n// 2025-06-07 11:23:25\n\n// Fork of \"Koch Squareflake 2\" by Cotterzz. https://shadertoy.com/view/wf33Ds\n// 2025-05-19 14:08:04\n\n// Fork of \"Koch Squareflake?\" by Cotterzz. https://shadertoy.com/view/tfcGDs\n// 2025-05-19 13:27:17\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 12:07:11\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float ar = iResolution.x/iResolution.y;\n   float dw = 0.402;\n   float dh = 0.08;\n   fragColor = texture(iChannel0, (fragCoord/iResolution.xy)+vec2(-dw,dh), 0.);\n   fragColor = min(fragColor, texture(iChannel0, (fragCoord/iResolution.xy)+vec2(dw,-dh), 0.));\n   fragColor = min(fragColor, texture(iChannel0, (fragCoord/iResolution.xy)+vec2(-dh/ar,-dw*ar), 0.));\n   fragColor = min(fragColor, texture(iChannel0, (fragCoord/iResolution.xy)+vec2(dh/ar,dw*ar), 0.));\n   if(distance(fragCoord, iResolution.xy/2.)<iResolution.x/3.5 && fragColor.r > 0.8){ fragColor.rgb = vec3(1,0,0);}\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float square(  in vec2 p, in float r ){ return max( abs(p.x)-r, abs(p.y)-r ); }\n\nvec4 compare(vec4 new, vec4 old){return old.b > old.r*2. ? old : min(new , old);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 10;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       vec3 col = vec3(1);\n       if(square(uv-vec2(0.5*ar, 0.5), .1)<0.075){col = vec3(0);}\n       if(distance(uv, vec2(ar/2.,0.5))<.05){col = vec3(0,1,1);}\n       fragColor = vec4(col, 1.);\n   } else if(iFrame%freq == 0){\n       vec2 nc = uv-vec2(0.5*ar, 0.5); \n       float rad = distance(nc,vec2(0,0));\n       float angle = float((iFrame/freq)%4)*1.5707963 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.245; nc.x-=.13; nc*= 2.1; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , texture(iChannel0, nc, 0.));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfyXzm",
    "date": "1749955696",
    "viewed": 202,
    "name": "Fork of vol vox box",
    "description": "Check out the [url=https://shadertoy.com/view/wfySzh]original shader[/url]\nI just added sdf code from another shader of mine with fancy colors - fork the original shader and drop your volumetric code into the voxel() function if you want to have a play.",
    "likes": 19,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "volumetric"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"vol vox box\" by 01000001. https://shadertoy.com/view/wfySzh\n// 2025-06-15 02:31:32\n\nconst float pi = 3.14159;\nconst float eps = 1e-4;\nfloat pc = 3.;\nvec3 getHC( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n// your code should go in this function:\nvec3 voxel(vec3 p){\n    //p = floor(p); //uncomment for voxel-like rendering\n    p=p.xzy;\n    p-=vec3(25.,30.,30.);\n    float d = map(p/20.);\n    if(d>0.){\n    float e=d/2.;\n    vec3 col = vec3(0.9,0.6,0.3);\n    col *= 1.0 - exp(-6.0*abs(e));\n\tcol *= 0.8 + 0.2*cos(150.0*e);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(e)) );\n        if(p.y<-29.){return pow(col*5.,vec3(3));}else{return pow(col*5.,vec3(3))/(p.y+30.)/2.;}\n    } else {return getHC(vec3(-d*10.,10.,3.+(d*20.)));}\n \n}\n\nfloat planeRay(vec3 ro, vec3 rd, vec3 pos, vec3 norm){\n    if (dot(norm, rd) > 0.) return -1.;\n    return dot(norm, ro-pos) / dot(norm, -rd);\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b){\n    float x = min(length(uv-a),length(uv-b));\n    vec2 v = normalize(b-a);\n    if (dot(v, uv-a) > 0. && dot(v, uv-a) < length(a-b)) x = min(x, abs(dot(uv-a, v.yx*vec2(-1,1)))); \n    return x;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = iMouse.xy == vec2(0)?vec2(iTime/5., -.2):(2.*iMouse.xy-r)/r.y;\n    O = vec4(0);\n\n    int lines = 46;//int(iResolution.y/100.);\n    float flines = float(lines);\n\n    vec2 camM = muv*(pi/2. - 1e-3);\n    vec3 camF = vec3(sin(camM.x)*cos(camM.y), cos(camM.x)*cos(camM.y), sin(camM.y));\n    vec3 camR = normalize(cross(camF, vec3(0,0,1)));\n    vec3 camU = cross(camR, camF);\n    \n    vec3 o = vec3(.5) - 3.*camF;\n    \n    vec3[8] p;\n    float vx,vy,vz;\n    for (int i = 0; i < 8; i++){\n        vx = dot(camR, vec3(i>>2, (i>>1)%2, i%2)-o);\n        vy = dot(camU, vec3(i>>2, (i>>1)%2, i%2)-o);\n        vz = dot(camF, vec3(i>>2, (i>>1)%2, i%2)-o);\n        p[i] = vec3(vx,vy, vz/pc);\n    } // vertex shader lol\n    \n    float d = 1e4;\n    \n    vec3 a,b;\n    \n    //*\n    for (int z = 0; z <= lines; z+=lines){\n        for (int x = 1; x < lines; x++){\n            float fx = float(x)/flines;\n            float fz = float(z)/flines;\n            a = mix(mix(p[0], p[1], fz), mix(p[4], p[5], fz), fx);\n            b = mix(mix(p[2], p[3], fz), mix(p[6], p[7], fz), fx);\n\n            d = min(d, line(cuv, a.xy / a.z, b.xy / b.z));\n\n\n            a = mix(mix(p[4], p[5], fz), mix(p[6], p[7], fz), fx);\n            b = mix(mix(p[0], p[1], fz), mix(p[2], p[3], fz), fx);\n\n            d = min(d, line(cuv, a.xy / a.z, b.xy / b.z));\n        }\n    }\n    //*/\n    \n    float x = .1 * \n    //smoothstep(2./r.y, 0., d);\n    exp(-pow(d / (2./r.y), 2.));\n    // gaussian instead of smoothstep nearly eliminates moire\n\n    d = 1e4;\n    // Outlines\n    //*\n    d = min(d, line(cuv, p[0].xy / p[0].z, p[2].xy / p[2].z));\n    d = min(d, line(cuv, p[2].xy / p[2].z, p[6].xy / p[6].z));\n    d = min(d, line(cuv, p[6].xy / p[6].z, p[4].xy / p[4].z));\n    d = min(d, line(cuv, p[4].xy / p[4].z, p[0].xy / p[0].z));\n    \n    d = min(d, line(cuv, p[1].xy / p[1].z, p[3].xy / p[3].z));\n    d = min(d, line(cuv, p[3].xy / p[3].z, p[7].xy / p[7].z));\n    d = min(d, line(cuv, p[7].xy / p[7].z, p[5].xy / p[5].z));\n    d = min(d, line(cuv, p[5].xy / p[5].z, p[1].xy / p[1].z));\n    \n    d = min(d, line(cuv, p[0].xy / p[0].z, p[1].xy / p[1].z));\n    d = min(d, line(cuv, p[2].xy / p[2].z, p[3].xy / p[3].z));\n    d = min(d, line(cuv, p[6].xy / p[6].z, p[7].xy / p[7].z));\n    d = min(d, line(cuv, p[4].xy / p[4].z, p[5].xy / p[5].z));\n    //*/\n\n    x = mix(x, .8, smoothstep(3./r.y, 0., d));\n    \n        \n    vec3 dir = camF + camR * cuv.x/pc + camU*cuv.y/pc;\n    float t = 0.;\n    vec3 pt,pos;\n\n    t = max(t, planeRay(o, dir, vec3(0, 0, 0), vec3(-1, 0, 0)));\n    t = max(t, planeRay(o, dir, vec3(0, 0, 0), vec3(0, -1, 0)));\n    t = max(t, planeRay(o, dir, vec3(0, 0, 0), vec3(0, 0, -1)));\n    t = max(t, planeRay(o, dir, vec3(1, 0, 0), vec3(1, 0, 0)));\n    t = max(t, planeRay(o, dir, vec3(0, 1, 0), vec3(0, 1, 0)));\n    t = max(t, planeRay(o, dir, vec3(0, 0, 1), vec3(0, 0, 1)));\n\n    pt = o + dir * t;\n    //O = (pt.xyzz); return;\n    t *= flines;\n    //t+= 10.; // Verification of optimization \n    \n    if (\n           pt.x >=    - eps\n        && pt.x <= 1. + eps\n        && pt.y >=    - eps\n        && pt.y <= 1. + eps\n        && pt.z >=    - eps\n        && pt.z <= 1. + eps\n    ) {\n        \n        float d;\n        vec3 p,v=vec3(0);\n        bvec3 sides = bvec3(dir.x > 0., dir.y > 0., dir.z > 0.);\n        vec3 dists,norm;\n\n        for (int i = 0; i < 512; i++){\n            p = o*flines + dir*t;\n\n            if (\n                   p.x > flines + eps\n                || p.y > flines + eps\n                || p.z > flines + eps\n                || p.x < -eps \n                || p.y < -eps\n                || p.z < -eps\n            ) break; // prevents loop unrolling too. \n\n            vec3 vox = voxel(p);\n            \n            for (int q = 0; q < 3; q++){\n                dists[q] = (sides[q]?ceil(p[q])-p[q]:floor(p[q])-p[q])/dir[q];\n            }\n\n            d = min(dists.x, min(dists.y, dists.z));\n\n            t += d + max(t*1e-5, 1e-4);\n            \n            v += d * max(vec3(0), vox);\n\n        }\n\n        O.xyz += (1.-exp(-v*.02));\n\n    }\n    \n    O += vec4(pow(x, 1./2.2));    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\n\n\nfloat sdSphere( in vec3 p, in float r)\n{\n    return length(p)-r;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n// The MIT License\n// Copyright  2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    return -opSmoothUnion(d1,-d2,k);\n    \n    //float h = max(k-abs(-d1-d2),0.0);\n    //return max(-d1, d2) + h*h*0.25/k;\n}\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    //vec3 q = abs(p)-h;\n    //return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n// Euclidean distance to a capped torus\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdHead( vec3 p, float r ){\n    // TOP - Cranium\n    float cran = sdSphere(p, r);\n    // BOTTOM - Jaw/Cheekbones\n    vec2 os = vec2(-0.14,0.05);\n    float ms = 0.1215;\n    vec3 ql = p - vec3(ms,os);\n    vec3 qr = p - vec3(-ms,os);\n    ql = ql*rotateZ(0.26);\n    qr = qr*rotateZ(-0.26);\n    ql = ql*rotateX(0.42);\n    qr = qr*rotateX(0.42);\n    vec3 a = vec3(0.,-0.4, 0.0);\n    vec3 b = vec3( 0., 0.4, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.12/l);\n    float jaw = opSmoothUnion(sdVerticalVesicaSegment( ql-a, l, wv*0.85 ) - wv*0.15, \n    sdVerticalVesicaSegment( qr-a, l, wv*0.85 ) - wv*0.15, 0.07);\n    cran = opSmoothUnion( cran, jaw, 0.03);\n    // SHAPING - sides\n    float d2 = sdRoundBox(p-vec3(0.76,-0.6,-0.15), vec3(0.4,0.4,0.4), 0.02 ); \n    float d1 = sdRoundBox(p-vec3(-0.76,-0.6,-0.15), vec3(0.4,0.4,0.4), 0.02); \n    float d3 = sdRoundBox(p-vec3(0.76,0.35,-0.2), vec3(0.4,0.4,0.4), 0.02 ); \n    float d4 = sdRoundBox(p-vec3(-0.76,0.35,-0.2), vec3(0.4,0.4,0.4), 0.02 ); \n    cran = opSmoothSubtraction(d4,opSmoothSubtraction(d3,cran, .2), .2);\n    cran = opSmoothSubtraction(d2,opSmoothSubtraction(d1,cran, .2), .2);\n    // SHAPING - top\n    float d6 = sdRoundBox(p-vec3(0.,0.8,-0.0), vec3(0.4,0.4,0.4), 0.03 ); \n    cran = opSmoothSubtraction(d6,cran,.5);\n    // SHAPING - front\n    float d7 = sdRoundBox(p-vec3(0.,0.42,0.82), vec3(0.4,0.4,0.4), 0.03 ); \n    cran = opSmoothSubtraction(d7,cran,.17);\n    // Eye Sockets\n    float d5 = sdRoundBox(p-vec3(0.0,-0.22,0.39), vec3(0.18,0.001,0.001), 0.03 );\n    cran = opSmoothSubtraction( d5, cran, .08);\n    // Nose\n    cran = opSmoothUnion( cran, sdRoundCone(   p-vec3( 0.0,-0.3, 0.34), vec3(0.0,0.0,0), vec3(0.0,0.17,-0.06), 0.03, 0.001), 0.05);\n    // Eyes\n    float eyel = sdSphere(p-vec3(0.11,-0.2,0.257), 0.05);\n    float eyer = sdSphere(p-vec3(-0.11,-0.2,0.257), 0.05);\n    cran = opSmoothUnion( cran, eyer, 0.025);\n    cran = opSmoothUnion( cran, eyel, 0.025);\n\n    return cran;\n}\nfloat map( in vec3 pos )\n{\n    float d = 1e10;\n    pos *= 0.9;\n    // Shoulders-Arms-Torso\n    vec3 q = pos - vec3(0.0,0.0,0.0);\n    q.z-=0.3;\n    q.y+=1.8 - q.x/20.;\n    q.x+=0.35 + q.y/20.;;\n    q = q*rotateX(1.7);\n    q = q*rotateZ(0.4);\n    q = q*rotateY(0.25);\n    float an = 1.0;\n    vec2 c = vec2(sin(an),cos(an));\n    vec4 w = opElongate( q, vec3(0.13,0.27,0.78) );\n    float shoulder = sdCappedTorus(w.xyz, c, 0.7, 0.2);\n    shoulder = shoulder+ sin((1.75+q.x)*3.)/15.;\n    shoulder = shoulder+0.04;\n    d = min( d, shoulder);\n    // Collar Bones\n    vec3 qt = pos - vec3(-0.8,-1.1,-0.7);\n    float collar = rounding( udTriangle( qt, vec3(0.6,0.0,0.19), vec3(0.4,-0.7,0.2), vec3(-0.1,-0.2,0.03) ), 0.05 );\n    collar = opSmoothUnion(collar, rounding( udTriangle( qt, vec3(0.7,0.0,0.1), vec3(0.8,-0.7,0.2), vec3(1.1,0.2,0.5) ), 0.01 ), 0.1);\n    d = opSmoothUnion(d, collar , 0.13);\n    // Extra Arm Padding\n    vec3 qv = pos - vec3(-0.9,-2.3,-0.6);\n    vec3 a = vec3(0.,-0.5, 0.0);\n    vec3 b = vec3( 0., 0.5, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.1/l);\n    d = opSmoothUnion( d, sdVerticalVesicaSegment( qv-a, l, wv*0.85 ) - wv*0.15 , 0.2);\n    // Extra Chest Padding\n    qv = pos - vec3(-0.1,-1.8,-0.5);\n    a = vec3(0.,-0.35, 0.0);\n    b = vec3( 0., 0.35, 0.0);\n    l = length(b-a);\n    wv = sqrt(0.2/l);\n    d = opSmoothUnion( d, sdVerticalVesicaSegment( qv-a, l, wv*0.85 ) - wv*0.15 , 0.3);\n    // Neck\n    qv = pos - vec3(0.2,-1.5,-0.3);\n    a = vec3(0.,-0.2, 0.0);\n    b = vec3( 0., 0.3, 0.0);\n    l = length(b-a);\n    qv = pos - vec3(-0.2,-0.9,-0.55);\n    qv = qv*rotateX(-0.3);\n    float neck = sdCylinder(qv, vec2(0.185, 0.65));\n    d = opSmoothUnion( d, neck, 0.2);\n    // Head\n    vec3 qh = pos - vec3(-0.1,-0.07,-0.3);\n    qh = qh*rotateY(-0.8);\n    float head = sdHead(qh, 0.36);\n    d = opSmoothUnion( d, head , 0.15);\n    return d;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXdXzS",
    "date": "1753606072",
    "viewed": 96,
    "name": "Another Fraccident",
    "description": "I was trying to do something else with the iteration limits and ended up with this.\nUse the mouse to control parameters",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fractal",
     "mandelbrot",
     "accident"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/*\n//GOLFED VERSION\nvec3 H(vec3 c){return c.z+c.y*(clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.)-.5)*(1.-abs(2.*c.z-1.));}\nvoid M(out vec4 o,vec2 u){\nvec2 v=u/iResolution.y,m=iMouse.z>0.?iMouse.xy/iResolution.xy:vec2(sin(iTime/2.)+1.,cos(iTime)+1.)/2.+1e-4;\nfloat s=3.,x=-1.,y=-.5,l=m.y*60.,a=x+v.x,b=y+v.y,c=a*s,d=b*s,e,f,r;int i;\nfor(i=0;i<int(m.x*30.)+1;i++){e=c*c-d*d+a*s;f=2.*c*d+b*s;c=e;d=f;r=c*c+d*d;if(r>l)break;}\no=vec4(atan(sqrt(H(vec3(r>l?r/l:r,1.,r>l?.4+float(i)/50.:.5+m.x/2.)))),1);}\nvoid mainImage(out vec4 o, vec2 u) { float s = 16., k; vec2 j = vec2(.5); o = vec4(0); vec4 c; M(c, u); \nfor (k = s; k-- > .5; ) { M(c, u + j - .5); o += c; j = fract(j + vec2(.755, .57).yx); };o /= s;o.a==1.;} \n*/\n\n// HSL to RGB color conversion function\nvec3 hslToRgb(vec3 c){return c.z+c.y*(clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.)-.5)*(1.-abs(2.*c.z-1.));}\n\n// Main Mandelbrot calculation function\nvoid calculateMandelbrot(out vec4 outputColor, vec2 pixelCoords) {\n    // Normalize coordinates to maintain aspect ratio\n    vec2 normalizedCoords = pixelCoords / iResolution.y;\n    \n    // Set up mouse interaction or automatic animation\n    vec2 mouseParams;\n    if (iMouse.z > 0.0) {\n        // If mouse is clicked, use mouse position\n        mouseParams = iMouse.xy / iResolution.xy;\n    } else {\n        // Otherwise, animate automatically\n        mouseParams = vec2(sin(iTime / 2.0) + 1.0, cos(iTime) + 1.0) / 2.0 + 0.0001;\n    }\n    \n    // Mandelbrot parameters\n    float zoom = 3.0;           // Zoom level\n    float centerX = -1.0;       // X center of view\n    float centerY = -0.5;       // Y center of view\n    float escapeRadius = mouseParams.y * 60.0;  // Escape radius threshold\n    \n    // Convert pixel coordinates to complex plane coordinates\n    float realPart = centerX + normalizedCoords.x;\n    float imagPart = centerY + normalizedCoords.y;\n    \n    // Initialize z = 0 for Mandelbrot iteration (z = z + c)\n    float zReal = realPart * zoom;\n    float zImag = imagPart * zoom;\n    \n    // Iterate the Mandelbrot equation\n    int iterations;\n    float magnitudeSquared;\n    int maxIterations = int(mouseParams.x * 30.0) + 1;\n    \n    for (iterations = 0; iterations < maxIterations; iterations++) {\n        // Calculate z + c\n        float newReal = zReal * zReal - zImag * zImag + realPart * zoom;\n        float newImag = 2.0 * zReal * zImag + imagPart * zoom;\n        \n        zReal = newReal;\n        zImag = newImag;\n        \n        // Check if point escaped\n        magnitudeSquared = zReal * zReal + zImag * zImag;\n        if (magnitudeSquared > escapeRadius) {\n            break;\n        }\n    }\n    \n    // Color the pixel based on escape time and magnitude\n    float hue, saturation, lightness;\n    \n    if (magnitudeSquared > escapeRadius) {\n        // Point escaped - color based on iterations\n        hue = magnitudeSquared / escapeRadius;\n        saturation = 1.0;\n        lightness = 0.4 + float(iterations) / 50.0;\n    } else {\n        // Point is in the Mandelbrot set\n        hue = magnitudeSquared;\n        saturation = 1.0;\n        lightness = 0.5 + mouseParams.x / 2.0;\n    }\n    \n    // Convert HSL to RGB and apply artistic transformation\n    vec3 color = hslToRgb(vec3(hue, saturation, lightness));\n    outputColor = vec4(atan(sqrt(color)), 1.0);  // Artistic color transformation\n}\n\n// Main shader entry point with anti-aliasing\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float sampleCount = 16.0;\n    \n    // Random offset for jittered sampling (pseudo-random)\n    vec2 jitter = vec2(0.5);\n    \n    // Initialize output color\n    fragColor = vec4(0.0);\n    \n    // Perform multiple samples for anti-aliasing\n    for (float k = sampleCount; k > 0.5; k--) {\n        vec4 sampleColor;\n        \n        // Calculate color at jittered position\n        calculateMandelbrot(sampleColor, fragCoord + jitter - 0.5);\n        fragColor += sampleColor;\n        \n        // Update jitter position (creates pseudo-random pattern)\n        jitter = fract(jitter + vec2(0.755, 0.57).yx);\n    }\n    \n    // Average all samples\n    fragColor /= sampleCount;\n    fragColor.a = 1.0;  // Set full opacity\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "w3dSDs",
    "date": "1754097449",
    "viewed": 110,
    "name": "Noisy geometry god",
    "description": "Adding audio to an old shader, ended up here, not exactly what I was looking for, but interesting.",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "random",
     "audio",
     "generative",
     "code",
     "feedback",
     "geometry",
     "angrygod"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4df3Rn",
       "filepath": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Angry geometry god\" by Cotterzz. https://shadertoy.com/view/tftGD4\n// 2025-08-02 01:15:44\n\n// Fork of \"Random Generative Shaders v5\" by Cotterzz. https://shadertoy.com/view/wf3GRN\n// 2025-05-13 06:05:43\n\n// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 06:21:07\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\n#define NEWVALUE values[int(floor(float(v)*GNF()))] \n#define NEWVALUE2 values[int(floor(float(v)*GNF()))] \n\nint PALETTE = 9;\n\nint note = -1;\n\nfloat cen = 0.;\n\nfloat GNF(){\n    note+=1;\n    if(note>=512){note=0;}\n    float r = texture(iChannel0, vec2(float(note)/512.,0)).r;\n    return (r + (r/cen))/2.;\n}\n\nfloat rand(float n){return fract(cos(n*89.42)*343.42);}\n\nfloat nz(vec2 nv){\n    float o = 0.;\n    for (float i = .2; i < 2.;\n    o += abs(dot(sin(nv * i * 64.), vec2(.05))) / i,\n    i *= 1.4142);\n    return mix(o,  distance(vec2(0), nv), 0.5 + (sin(iTime)/2.));\n}\n\nfloat rMix(float a, float b, float s){\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?nz(vec2(a,b)):s>0.3?b/(a==0.?0.01:a):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\n\nvec3 gpc(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = contrast(gpc(num),1.7);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n        return col;\n    } else {\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        return col;\n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., dc.r);\n    dc.g = min(1., dc.g);\n    dc.b = min(1., dc.b);\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 8.;\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    float o = nz(guv);\n    float seed = floor(iTime/1.0);\n    PALETTE = int(floor(float(8)*rand(seed+66.)));\n    const int v = 24;\n    vec3 col = vec3(0);\n    float cn = 1.;\n    float values[v];\n    values[0] = texture(iChannel0, vec2(x,0)).r;\n    values[1] = texture(iChannel0, vec2(x,1)).r;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = texture(iChannel0, vec2(y,1)).r;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = texture(iChannel0, vec2(y,0)).r;\n   values[21] = atan(x, y)*4.;\n   values[22] = o;\n   values[23] = distance(vec2(x,y), vec2(0))*sin(atan(x, y));\n   \n   cen = values[19];\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 20; int mini = 5;\n    int iterations = min(maxi,mini + int(floor(GNF()*float(maxi-mini))));\n    \n    for(int i = 0; i<iterations; i++){\n        if(GNF()>0.5){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, GNF()) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, GNF()), GNF());\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, GNF());\n        }\n        if(abs(sub)<1.){PALETTE = int(floor(float(8)*GNF()));}\n        if(GNF()>GNF()/2.){\n            total = total==0. ? sub : rMix(total, sub,GNF());\n            sub = 0.;\n            col += addColor(total, GNF(), values[21]);\n            cn+=1.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, GNF());\n    col += addColor(total, GNF(), values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + GNF()));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(GNF()>0.5){col = col.gbr;}\n        if(GNF()>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    fragColor = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wXVXzR",
    "date": "1754166000",
    "viewed": 103,
    "name": "FFT Audio Visualiser",
    "description": "Seeing how much information I can get out of the very limited 512 pixels of fft data.\nUsing a bit of time and frequency differential to amplify the sounds.",
    "likes": 8,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fft",
     "audio"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4sXGzn",
       "filepath": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 fcr = fragCoord;\n    if(fcr.x>=512.){fcr.x-=512.;}\n    vec2 uvr =  fcr/iResolution.xy;\n    vec3 col = vec3(0);\n    vec3 fcol = texture(iChannel0, vec2(fcr.x/512.,0.), 0.).rgb;\n    vec3 fcolr = texture(iChannel0, vec2((fcr.x+1.)/512.,0.), 0.).rgb;\n    vec3 fcoll = texture(iChannel0, vec2((fcr.x-1.)/512.,0.), 0.).rgb;\n    vec3 fcolo = texture(iChannel1, vec2(uvr.x,0.), 0.).rgb;\n    float dxr = fcol.r-fcolr.r;\n    float dxl = fcol.r-fcoll.r;\n    float dxt = max(0.,dxr+dxl);\n    float dxo = max(0.,fcol.r-fcolo.r);\n    float r2 = fcol.r * (0.4 + (fcr.x/300.));\n    r2 = mix(r2, fcol.r, fcr.x/1100.);\n    float r3 = max(0.,r2+(dxt));\n    float r4 = max(0.,r2+(dxo*1.5));\n    float r5 = max(0.,(r2/2.)+(dxt*2.)+(dxo))*2.;\n    if(fragCoord.x<512.){\n        if(fragCoord.y< 10.){col=fcol;}\n        else if(fragCoord.y< (10. + (fcol.r*100.))){col=vec3(0.5,0,0);}\n        else if(fragCoord.y< (110. + (r2*100.))){col=vec3(0.7,0.3,0);}\n        else if(fragCoord.y< (210. + (r3*100.))){col=vec3(1.0,1.0,0);}\n        else if(fragCoord.y< (310. + (r4*100.))){col=vec3(0.0,1.0,0);}\n        else if(fragCoord.y< (410. + (r5*100.))){col=vec3(0.0,0.4,1.0);}\n    } else if(fragCoord.x<1024.){\n        vec3 ocol = vec3(4.*dxt,r5/1.5,4.*dxo);\n        if(fragCoord.y< 10.){col=ocol;} else {col = texture(iChannel1, vec2(uv.x,uv.y-(1./iResolution.y)), 0.).rgb;}\n    }\n    fragColor = vec4(col,1.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3XGXRW",
    "date": "1754255998",
    "viewed": 78,
    "name": "Random Volumetric V2",
    "description": "I was just playing around with [url=https://shadertoy.com/view/3fc3Dn]this shader[/url] and I think I like it more now, the scrolling volume is no longer visible, but the overall effect is it's own thing.\nClick on the canvas to change the pattern",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "random",
     "volumetric",
     "generative",
     "code"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Volumetric Shader\" by Cotterzz. https://shadertoy.com/view/3fc3Dn\n// 2025-08-03 21:08:55\n\n// Fork of \"Random Generative Shaders v5\" by Cotterzz. https://shadertoy.com/view/wf3GRN\n// 2025-05-10 22:57:51\n\n// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 06:21:07\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n    fragColor.rgb = contrast(fragColor.rgb, 1.5);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float hash1(vec2 x)\n{\n    uvec2 t = floatBitsToUint(x);\n    uint h = 0xc2b2ae3du * t.x + 0x165667b9u;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h += 0xc2b2ae3du * t.y;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h ^= h >> 15u;\n    h *= 0x85ebca77u;\n    h ^= h >> 13u;\n    h *= 0xc2b2ae3du;\n    h ^= h >> 16u;\n    return uintBitsToFloat(h >> 9u | 0x3f800000u) - 1.0;\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\nvec2 hash2(vec2 x) // improved hash using xxhash\n{\n    float k = 6.283185307 * hash1(x);\n    return vec2(cos(k), sin(k));\n}\n\nfloat noise2( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0))); // changed to h^3 [1]\n    return dot( n, vec3(32.99) ); // analytic factor (= 2916*sqrt(2)/125)\n}\n\nfloat pnoise (vec2 uv){\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2( uv ); uv = m*uv;\n    f += 0.2500*noise2( uv ); uv = m*uv;\n    f += 0.1250*noise2( uv ); uv = m*uv;\n    f += 0.0625*noise2( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    return f;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n#define T (iTime*4.)\n#define rot(a) mat2(cos(a+vec4(0,33,11,0)))\n#define P(z) (vec3(tanh(cos((z) * .15) * 1.) * 8., \\\n                   tanh(cos((z) * .12) * 1.) * 8., (z)))\n\n\n// PREVIEW 0 to disable preview mode\n// SHOWITER 0 to disable iterations view\n// select palette mode below\n\n#define PREVIEW 0\n#define SHOWITER 0\n#define VOLUMETRIC 1\n\nfloat displaytime = 2.5; // seconds between switch\n\nint PALETTE = 9;\n\n// 0 = Original\n// 1 = Original with hsl mixed\n// 2 = Original translated to hsl\n// 3 = hsl calculated\n// 4 = hsl enhanced\n// 5 = hsl*2\n// 6 = weird\n// 7 = fhex\n// 8 = Banded.\n// 9 = RANDOMISE!!!\n\nvec3 p = vec3(0);\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat map(vec3 p) {\n    return 1.5 - length(p - P(p.z));\n}\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/(a==0.?0.01:a):s>0.3?pnoise(vec2(a,b)):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nvec3 fhexRGB(float fh){\n    if(isinf(fh)||fh>100000.){fh = 0.;}\n    fh = abs(fh*10000000.);\n    float r = fract(fh/65536.);\n    float g = fract(fh/256.);\n    float b= fract(fh/16777216.);\n    //return gmc(contrast(hsl2rgb(vec3(r,g,b)), 0.9), 0.9);\n   return hsl2rgb(vec3(r,g,b));\n}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = fhexRGB(num);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n    \n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n       \n        return col;\n       \n    } else {\n\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        // if(PALETTE == 0){col = contrast(col, 1.01); }\n        return col;\n    \n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., abs(dc.r));\n    dc.g = min(1., abs(dc.g));\n    dc.b = min(1., abs(dc.b));\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec3  r = iResolution;\n    vec2 u = fragCoord;\n    \n        \n        float s=.002,d,i, l;\n\n        u = (u-r.xy/2.)/r.y;\n    \n        vec3  p = P(T),ro=p,q,\n              Z = normalize( P(T+1.)  - p),\n              X = normalize(vec3(Z.z,0,-Z)),\n              D = vec3(rot(tanh(sin(p.z*.03)*8.)*3.)*u, 1)* mat3(-X, cross(X, Z), Z);\n       \n        for(; i++<80. && s > .001; ) {\n    \n            p = ro + D * d,\n            s = map(p)*.8,\n            d += s;\n        }\n        p = ro + D * d;\n        \n    vec2 uv = fragCoord/iResolution.y;\n    vec2 uvd = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 4.;\n    if(VOLUMETRIC == 1 ){ zoom+= (1.5*(sin(iTime)+1.)); } else { zoom+= (3.*(sin(iTime)+1.));}\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 468.;\n    float iy = 330.;\n    if(iMouse.x>0.&&iMouse.y>0.){\n    ix = iMouse.x; iy = iMouse.y;}\n    \n    float thumb = 5.+sin((iTime/2.)-1.62)*2.;\n    \n    if(!(iMouse.z>0.)&& bool(PREVIEW)){\n        float pantime = (iTime)+50.;\n\n        ix = floor(pantime+(uv.x*thumb/(iResolution.x/iResolution.y)));\n        iy = floor((pantime+(uv.y*thumb)));\n\n        uv.y*=thumb;\n        uv.x*=thumb/(iResolution.x/iResolution.y);\n        uv+=pantime;\n        uv=fract(uv);\n        uv.x-=0.5;\n        uv.y-=0.5;\n        guv = (uv*zoom);\n        x = guv.x;\n        y = guv.y;\n    }\n    \n    float seed = (ix + (iy*iResolution.x))/iResolution.x;\n    \n    if(!(iMouse.z>0.) && iMouse.x==0. && iMouse.y==0.){\n        seed = floor(iTime+50./displaytime);\n    }\n    \n    if(PALETTE == 9){\n        PALETTE = int(floor(float(8)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 24;\n    \n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = p.x;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = p.y;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = p.z;\n   values[21] = atan(x, y)*4.;\n   values[22] = pnoise(vec2(x,y)/2.);\n   values[23] = pnoise(vec2(y,x)*10.);\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 40; int mini = 4;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n      \n        }\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            if(rand(seed+float(i+30))>rand(seed)){\n                col += addColor(total, seed+float(i), values[21]);\n                cn+=1.;\n            }\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    if(VOLUMETRIC == 1 ) { \n    uv+=vec2(0.25,0.15);\n    //if(uvd.x<uvd.y){if(abs(uv.x)>0.6 || abs(uv.y)>0.32){col=vec3(0);}}\n    float xspeed = ar*4.*(iMouse.x/iResolution.x);\n    float yspeed = 4.*(iMouse.y/iResolution.y);\n    vec3 old = textureLod(iChannel0, (fragCoord+vec2(-xspeed,-yspeed))/iResolution.xy, 0.).rgb;\n    float alph = (col.r+col.g+col.b)/5.;\n    //if(uvd.x<uvd.y){alph = alph<0.5?0.0:alph<0.7?(alph-0.5)*5.:1.0;}\n    //alph = alph<0.25?0.0:alph<0.5?(alph-0.25)*5.:1.0;\n    fragColor = vec4(mix(old, col, alph), 1.);\n    } else {\n    fragColor = vec4(col, 1.);\n    }\n\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "w3GSRD",
    "date": "1754286303",
    "viewed": 130,
    "name": "Random Volumetric V3",
    "description": "Final go at adding effects and making this look as otherworldly as possible.\nthx to chronos for the herringbone pattern",
    "likes": 8,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "random",
     "volumetric",
     "generative",
     "code"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Volumetric V2\" by Cotterzz. https://shadertoy.com/view/3XGXRW\n// 2025-08-04 05:40:13\n\n// Fork of \"Random Volumetric Shader\" by Cotterzz. https://shadertoy.com/view/3fc3Dn\n// 2025-08-03 21:08:55\n\n// Fork of \"Random Generative Shaders v5\" by Cotterzz. https://shadertoy.com/view/wf3GRN\n// 2025-05-10 22:57:51\n\n// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 06:21:07\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n    fragColor.rgb = contrast(fragColor.rgb, 4.-(abs((iResolution.x/2.)-fragCoord.x)/(iResolution.x/2.)));\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float hash1(vec2 x)\n{\n    uvec2 t = floatBitsToUint(x);\n    uint h = 0xc2b2ae3du * t.x + 0x165667b9u;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h += 0xc2b2ae3du * t.y;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h ^= h >> 15u;\n    h *= 0x85ebca77u;\n    h ^= h >> 13u;\n    h *= 0xc2b2ae3du;\n    h ^= h >> 16u;\n    return uintBitsToFloat(h >> 9u | 0x3f800000u) - 1.0;\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\nvec2 hash2(vec2 x) // improved hash using xxhash\n{\n    float k = 6.283185307 * hash1(x);\n    return vec2(cos(k), sin(k));\n}\n\nfloat noise2( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0))); // changed to h^3 [1]\n    return dot( n, vec3(32.99) ); // analytic factor (= 2916*sqrt(2)/125)\n}\n\nfloat pnoise (vec2 uv){\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2( uv ); uv = m*uv;\n    f += 0.2500*noise2( uv ); uv = m*uv;\n    f += 0.1250*noise2( uv ); uv = m*uv;\n    f += 0.0625*noise2( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    return f;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n#define T (iTime*4.)\n#define rot(a) mat2(cos(a+vec4(0,33,11,0)))\n#define P(z) (vec3(tanh(cos((z) * .15) * 1.) * 8., \\\n                   tanh(cos((z) * .12) * 1.) * 8., (z)))\n\n\n// PREVIEW 0 to disable preview mode\n// SHOWITER 0 to disable iterations view\n// select palette mode below\n\n#define PREVIEW 0\n#define SHOWITER 0\n#define VOLUMETRIC 1\n\nfloat displaytime = 1.0; // seconds between switch\n\nint PALETTE = 9;\n\n// 0 = Original\n// 1 = Original with hsl mixed\n// 2 = Original translated to hsl\n// 3 = hsl calculated\n// 4 = hsl enhanced\n// 5 = hsl*2\n// 6 = weird\n// 7 = fhex\n// 8 = Banded.\n// 9 = RANDOMISE!!!\n\nvec3 p = vec3(0);\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat map(vec3 p) {\n    return 1.5 - length(p - P(p.z));\n}\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/(a==0.?0.01:a):s>0.3?pnoise(vec2(a,b)):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nvec3 fhexRGB(float fh){\n    if(isinf(fh)||fh>100000.){fh = 0.;}\n    fh = abs(fh*10000000.);\n    float r = fract(fh/65536.);\n    float g = fract(fh/256.);\n    float b= fract(fh/16777216.);\n    //return gmc(contrast(hsl2rgb(vec3(r,g,b)), 0.9), 0.9);\n   return hsl2rgb(vec3(r,g,b));\n}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = fhexRGB(num);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n    \n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n       \n        return col;\n       \n    } else {\n\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        // if(PALETTE == 0){col = contrast(col, 1.01); }\n        return col;\n    \n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., abs(dc.r));\n    dc.g = min(1., abs(dc.g));\n    dc.b = min(1., abs(dc.b));\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec3  r = iResolution;\n    vec2 u = fragCoord;\n    \n        \n        float s=.002,d,i, l;\n\n        u = (u-r.xy/2.)/r.y;\n    \n        vec3  p = P(T),ro=p,q,\n              Z = normalize( P(T+1.)  - p),\n              X = normalize(vec3(Z.z,0,-Z)),\n              D = vec3(rot(tanh(sin(p.z*.03)*8.)*3.)*u, 1)* mat3(-X, cross(X, Z), Z);\n       \n        for(; i++<80. && s > .001; ) {\n    \n            p = ro + D * d,\n            s = map(p)*.8,\n            d += s;\n        }\n        p = ro + D * d;\n        \n    vec2 uv = fragCoord/iResolution.y;\n    vec2 uvd = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 4.;\n    if(VOLUMETRIC == 1 ){ zoom+= (1.5*(sin(iTime)+1.)); } else { zoom+= (3.*(sin(iTime)+1.));}\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 468.;\n    float iy = 330.;\n    if(iMouse.x>0.&&iMouse.y>0.){\n    ix = iMouse.x; iy = iMouse.y;}\n    \n    float thumb = 5.+sin((iTime/2.)-1.62)*2.;\n    \n    if(!(iMouse.z>0.)&& bool(PREVIEW)){\n        float pantime = (iTime)+50.;\n\n        ix = floor(pantime+(uv.x*thumb/(iResolution.x/iResolution.y)));\n        iy = floor((pantime+(uv.y*thumb)));\n\n        uv.y*=thumb;\n        uv.x*=thumb/(iResolution.x/iResolution.y);\n        uv+=pantime;\n        uv=fract(uv);\n        uv.x-=0.5;\n        uv.y-=0.5;\n        guv = (uv*zoom);\n        x = guv.x;\n        y = guv.y;\n    }\n    \n    float seed = (ix + (iy*iResolution.x))/iResolution.x;\n    \n    if(!(iMouse.z>0.) && iMouse.x==0. && iMouse.y==0.){\n        seed = floor(iTime/displaytime);\n    }\n    \n    if(PALETTE == 9){\n        PALETTE = int(floor(float(8)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 26;\n    \n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    float xb = x*5.;\n    float yb = y*5.;\n    \n    values[0] = 1.0;\n    values[1] = p.x;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = p.y;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = p.z;\n   values[21] = atan(x, y)*4.;\n   values[22] = pnoise(vec2(x,y)/2.);\n   values[23] = pnoise(vec2(y,x)*10.);\n   values[24] = .2+(.4+.4*cos(xb*2. + sin(yb*2.)) * cos(yb*2.  + sin(xb*2.)))/2.;\n   values[25] = .2+(.4+.4*cos(xb + sin(yb)) * cos(yb  + sin(xb)))/2.;\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 40; int mini = 4;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n      \n        }\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            if(rand(seed+float(i+30))>rand(seed)){\n                col += addColor(total, seed+float(i), values[21]);\n                cn+=1.;\n            }\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n     \n    uv+=vec2(0.25,0.15);\n    //if(uvd.x<uvd.y){if(abs(uv.x)>0.6 || abs(uv.y)>0.32){col=vec3(0);}}\n    float xspeed = ar*(col.r-col.b)*10.;\n    float yspeed = (col.g+col.b)*10.;\n    yspeed = mix(xspeed,(col.g*5.)*col.b,uvd.x);\n    xspeed = mix(yspeed,(col.r*5.)*-col.b,uvd.x);\n    vec3 old = textureLod(iChannel0, (fragCoord+vec2(-xspeed,-yspeed))/iResolution.xy, 0.).rgb;\n    float alph1 = (col.r+col.g+col.b)/5.;\n    float alph2 = 1.-(abs(col.r-old.r)+abs(col.g-old.g)+abs(col.b-old.b))/3.;\n    vec3 col1 = 1.-col;\n    \n    float alph = alph1;//mix(alph1, alph2, uvd.y);\n    col = mix(col, col1, uvd.x);\n    \n    fragColor = vec4(mix(old, col, alph), 1.);\n    }\n\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXyXzV",
    "date": "1754776669",
    "viewed": 113,
    "name": "Golfed Mandelbrot",
    "description": "Inspired by [url=https://www.shadertoy.com/view/wcyXRK]this shader[/url]\nI asked AI for shortest possible golfed mandelbrot.\nThe result was pretty bad, but I managed to improve it and bring it down to 125 chars. Then 109...\nMight look odd on big screen :)",
    "likes": 7,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fractal",
     "mandelbrot",
     "golf",
     "ai",
     "llm"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//   First AI attempt 151 chars:\n// void mainImage(out vec4 o,vec2 p){p=p/iResolution.y*3.-2.;vec2 z=p;for(int i=0;i<9;i++)z=vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+p;o=vec4(step(4.,dot(z,z)));}\n\n//   My improvement 125 chars:\n// void mainImage(out vec4 o,vec2 p){p=p*.01-2.;vec2 z=p;for(int i=0;i<23;i++)z=vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+p;o=vec4(z,z);}\n\n//   Second AI attempt (w matrix) 145 chars:\n// void mainImage(out vec4 o,vec2 c){c=c/iResolution.y-vec2(.7,.5);vec2 z;for(int i=0;i<99;i++)z=mat2(z,-z.y,z.x)*z+c;o=vec4(1.-step(4.,dot(z,z)));}\n\n//   My improvement 109 chars:\n// void mainImage(out vec4 o,vec2 c){c=c/99.-2.;vec2 z;for(int i=0;i<99;i++)z=mat2(z,-z.y,z.x)*z+c;o=1.-z.yxxx;}\n\n//   Edits by BlobKat & HexaPhoenix 100 chars:\n// void mainImage(out vec4 o,vec2 c){for(vec2 z,i;i.x++<99.;z=mat2(z,-z.y,z.x)*z+c/99.-2.)o=1.-z.yxxx;}\n\n//   Edit by shadertoyjiang 98 chars:\n// void mainImage(out vec4 o,vec2 c){for(vec2 z,i;i.x++<99.;z=mat2(z,-z.y,z)*z+c/99.-2.)o=1.-z.yxxx;}\n   \n//   Another Edit by HexaPhoenix 96 chars:\n   void mainImage(out vec4 o,vec2 c){for(vec2 z,i;i.x++<99.;z=mat2(z,-z.y,z)*z+c/99.-2.)o.xy = 1.-z;}\n   \n//   This is 94 chars, but breaks in win/chrome because of uninitialised o\n// void mainImage(out vec4 o,vec2 c){for(vec2 z;o.w++<99.;z=mat2(z,-z.y,z)*z+c/99.-2.)o.xy = 1.-z;}\n\n//   And this leads to: https://www.shadertoy.com/view/33KSRK - 85 chars! but only works on certain platforms.\n   ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXKXzV",
    "date": "1754822552",
    "viewed": 113,
    "name": "Cat Eye SDF",
    "description": "Something I need for a shader",
    "likes": 8,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "distancefield",
     "sdf",
     "eye",
     "distance",
     "cat",
     "vesica",
     "pupil"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Cat eye SDF.\n// It's almost identical to a vesica, but with different params/constraints\n// so it's suited for a specific use case.\n\n// See also: https://www.shadertoy.com/view/XtVfRW and https://www.shadertoy.com/view/XlVfz1\n// For similar/alternative SDF   \n\nfloat sdCateye(vec2 p, float height, float dilation)\n{\n    // height is actual height of pupil, vrad is half height\n    float vrad = height/2.;\n    // dilation is maxed at 1, a regular circle, zero would not be visible so it's limited to 0.001\n    dilation = min(.999, max(0.01, dilation));\n    // radius is half height when circle is centred and dilation is 1, and gets bigger as dilation gets smaller\n    float rad = (vrad)/dilation;\n    // dist is distance between circle centre and eye centre\n    float dist = sqrt((rad*rad)-(vrad*vrad));\n    // same as IQ's vesica, - we only need to calculate a quarter because of symmetry\n    p = abs(p);\n    // now we calculate distance from circle centre\n    vec2 center = vec2(-dist, 0.);\n    float tdist = distance(p, center);\n    // and subtract radius for distance from surface\n    float result = tdist - rad;\n    \n    // This is for correct distance from the sharp top and bottom corners\n    // Comment these two lines for pointy SDF shape.\n    vec2 nearest = center+(p-center)*rad/tdist;\n    if(nearest.y>vrad){result=distance(p,vec2(0.,vrad));}\n\n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float eHeight = 1.;\n    float eDilation = 0.4*(sin(iTime)+1.3);\n    \n    //if( iMouse.z>0.001 ) {eHeight = iMouse.y/iResolution.y; eDilation = iMouse.x/iResolution.x;}\n    \n\tfloat d = sdCateye( p, eHeight, eDilation);\n\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d)); col *= 0.8 + 0.2*cos(110.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n\n    if( iMouse.z>0.001 ){ d = sdCateye( m, eHeight, eDilation);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));}\n\n\tfragColor = vec4(col,1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfXczr",
    "date": "1755230781",
    "viewed": 147,
    "name": "Domain Repetition Hair/Fur",
    "description": "I needed something like this for a shader and I've not seen this approach used before so I thought I'd build a prototype.\nMouse over to change thickness/number",
    "likes": 13,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "domainrepetition",
     "hair",
     "fur",
     "organic",
     "cat"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// First proof of concept for raymarched hair/fur\n// I wondered if we couldn't just use domain repetition, in between an outer and inner sphere,\n// using perpendicular intervals to make a grid for the hair, with the hairs as grid points on a polar plane.\n// Still lots of things to do like shaping the hair more, light/shadow and adapting to more complex shapes\n// I also need to use cell noise on the grid positions so the hairs arent in perfect rows.\n// It's very fast though, without AA it's 60fps on intel 630 at 1200x675 with seemingly any number of hairs.\n\n// Check out v2 here: https://www.shadertoy.com/view/3fsyzn\n\n#define AA 4.0 // 1. is off, 4. is 2x2 etc...\n\nfloat sdSphere(vec3 p, float r) {return length(p) - r;}\n\nvec2 cartesianToSpherical(vec3 p) {\n    float r = length(p);\n    if(r < 0.001) return vec2(0.0);\n    vec3 n = p / r;\n    float lon = atan(n.z, n.x);\n    float lat = acos(clamp(n.y, -1.0, 1.0));\n    return vec2(lat, lon);\n}\n\nvec3 applyDroop(vec3 p) {\n    float radialDist = length(p);\n    float normalizedRadius = (radialDist - 0.4) / 0.7; // 0 at inner sphere, 1 at outer\n    \n    // Calculate droop amount based on distance from inner sphere\n    float droopFactor = normalizedRadius * normalizedRadius;\n    float droopAmount = droopFactor * 0.4; \n    \n    vec3 droopedPos = p;\n    droopedPos.y -= droopAmount;\n    \n    float curlFactor = droopFactor * 0.1;\n    vec3 toCenter = -normalize(vec3(p.x, 0.0, p.z));\n    droopedPos += toCenter * curlFactor;\n    \n    return droopedPos;\n}\n\n// Distance function for hair based on lat/lon grid with drooping\nfloat sdRadialLine(vec3 p, float gridSpacing, float thickness) {\n    vec3 straightPos = p;\n\n    for(int i = 0; i < 3; i++) {\n        vec3 drooped = applyDroop(straightPos);\n        vec3 error = p - drooped;\n        straightPos += error * 0.7;\n    }\n    \n    vec2 spherical = cartesianToSpherical(straightPos);\n    \n    float lat = spherical.x;\n    float lon = spherical.y;\n\n    float lonSpacing = gridSpacing / max(sin(lat), 0.1);\n    \n    vec2 gridPos = vec2(lat, lon);\n    vec2 gridCell = vec2(\n        round(gridPos.x / gridSpacing) * gridSpacing,\n        round(gridPos.y / lonSpacing) * lonSpacing\n    );\n    vec2 toLine = gridPos - gridCell;\n\n    toLine.y *= sin(lat);\n    float distToLine = length(toLine);\n\n    if(distToLine > gridSpacing * 0.8) return 1e10;\n    \n    float radialDist = length(straightPos);\n    float normalizedRadius = (radialDist - 0.5) / 0.5;\n\n    float taperFactor = 1.0 - normalizedRadius;\n    float currentThickness = thickness * taperFactor;\n    \n    return distToLine - currentThickness;\n}\n\n\nfloat hash(vec2 p) {\n    p = fract(p * vec2(123.34, 456.78));\n    p += dot(p, p + 34.56);\n    return fract(p.x * p.y);\n}\n\nvec2 getHairID(vec3 p, float gridSpacing) {\n    vec3 straightPos = p;\n    for(int i = 0; i < 3; i++) {\n        vec3 drooped = applyDroop(straightPos);\n        vec3 error = p - drooped;\n        straightPos += error * 0.7;\n    }\n    \n    vec2 spherical = cartesianToSpherical(straightPos);\n    float lat = spherical.x;\n    float lon = spherical.y;\n    \n    float lonSpacing = gridSpacing / max(sin(lat), 0.1);\n    \n    vec2 gridCell = vec2(\n        round(lat / gridSpacing),\n        round(lon / lonSpacing)\n    );\n    \n    return gridCell;\n}\n\nfloat map(vec3 p) {return sdSphere(p, 0.4);}\n\nfloat mapWithLines(vec3 p, float lineSpacing, float lineThickness) {\n    float innerSphere = sdSphere(p, 0.4);\n    float lines = sdRadialLine(p, lineSpacing, lineThickness);\n    return min(innerSphere, lines);\n}\n\nbool isBetweenSpheres(vec3 p) {\n    float distFromCenter = length(p);\n    return distFromCenter > 0.4 && distFromCenter < 1.0;\n}\n\nfloat getHairOpacity(vec3 p) {\n    vec3 straightPos = p;\n    for(int i = 0; i < 3; i++) {\n        vec3 drooped = applyDroop(straightPos);\n        vec3 error = p - drooped;\n        straightPos += error * 0.7;\n    }\n    \n    float radialDist = length(straightPos);\n    float normalizedRadius = (radialDist - 0.5) / 0.5;\n    return 1.0 - normalizedRadius * 0.8;\n}\n\nvec4 raymarchWithLines(vec3 ro, vec3 rd, float lineSpacing, float lineThickness) {\n    float t = 0.0;\n    \n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        \n        float d;\n        if(isBetweenSpheres(p)) {\n            d = mapWithLines(p, lineSpacing, lineThickness);\n        } else {\n            d = map(p);\n        }\n        \n        if(d < 0.001) {\n            float objectId = 0.0;\n            float opacity = 1.0;\n            vec2 hairID = getHairID(p, lineSpacing);\n            if(isBetweenSpheres(p)) {\n                float innerDist = sdSphere(p, 0.3);\n                float lineDist = sdRadialLine(p, lineSpacing, lineThickness);\n                \n                if(lineDist < innerDist) {\n                    objectId = 1.0;\n                    opacity = getHairOpacity(p);\n                }\n            }\n            \n            \n            return vec4(t, objectId, hash(hairID), opacity);\n        }\n        \n        t += d * 0.8;\n        \n        if(t > 10.0) break;\n    }\n    \n    return vec4(-1.0, -1.0, 0.0, 0.0);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r*r;\n    float h = b*b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float time = iTime * 0.5;\n    float radius = 3.0;\n    float height = sin(time * 0.7) * 0.5;\n    \n    vec3 ro = vec3(\n        radius * cos(time),\n        height,\n        radius * sin(time)\n    );\n    \n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    \n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n   \n    vec3 col = vec3(0.3);\n    \n    float lineSpacing = iMouse.x/iResolution.x/3.;\n    float lineThickness = iMouse.y/iResolution.y/50.;\n    \n    if(lineSpacing <= 0.) lineSpacing = 0.1;\n    if(lineThickness <= 0.) lineThickness = 0.002;\n    \n    vec2 outerHit = raySphere(ro, rd, 1.0);\n    \n    if(outerHit.x > 0.0) {\n        vec3 pEnter = ro + rd * outerHit.x;\n        \n        vec3 roInner = pEnter + rd * 0.001;\n        vec4 hit = raymarchWithLines(roInner, rd, lineSpacing, lineThickness);\n        \n        if(hit.x > 0.0) {\n            vec3 pHit = roInner + rd * hit.x;\n            vec3 nHit = normalize(pHit);\n            \n            vec3 lightPos = vec3(2.0, 2.0, -2.0);\n            vec3 lightPos2 = vec3(0.0, -3.0, -0.0);\n            vec3 lightDirInner = normalize(lightPos - pHit);\n            vec3 lightDirInner2 = normalize(lightPos2 - pHit);\n            float diffInner = max(dot(nHit, lightDirInner), 0.0);\n            float diffInner2 = max(dot(nHit, lightDirInner2), 0.0);\n            float ambient = 0.5;\n            \n            vec3 hitCol;\n            if(hit.y > 0.5) {\n                float hairRandom = hit.z;\n                vec3 haircolA = vec3(0.85, 0.6, 0.3);\n                vec3 haircolB = vec3(0.5, 0.4, 0.0);\n                vec3 hairBaseCol = mix(haircolA, haircolB, hairRandom);\n                hitCol = hairBaseCol * (diffInner + ambient);\n                hitCol += vec3(0.3,0,0) * (diffInner2 + ambient);\n                float spec = pow(max(dot(reflect(-lightDirInner, nHit), -rd), 0.0), 16.0);\n                hitCol += vec3(0.4) * spec;\n                float opacity = hit.w;\n                col = mix(col, hitCol, opacity);\n            } else {\n                hitCol = vec3(0.5);\n                col = hitCol;\n            }\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n// multisampling, from \"Weyl Supersample Any Shader\" by spalmer https://www.shadertoy.com/view/WXjXRt\n// (forked from from \"postprocess existing shaders\" by FabriceNeyret2 https://www.shadertoy.com/view/NdyfRz \nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = AA, k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n} ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3fsyzn",
    "date": "1755238131",
    "viewed": 259,
    "name": "Domain Repetition Hair/Fur 2",
    "description": "More developed version - more natural distribution of hair and light/shadow.\nMouse to rotate, also - 1x multisampling with mouse on the left, to 16x on the far right",
    "likes": 15,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "domainrepetition",
     "hair",
     "fur",
     "organic",
     "cat"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Domain Repetition Hair/Fur\" by Cotterzz. https://shadertoy.com/view/wfXczr\n// 2025-08-15 04:55:44\n\n// Lots added here, more params..\n// lighting/shadows which I think are expensive,\n// ..and with hair you can't have one without the other\n// The most imprtant though is offset so the hairs aren't in straight rows. :)\n\n// There seem to be a few artifacts with certain parameters.\n\n// Set multisampling to 0.0 to make it xmouse dependent - left to right is 1x to 16x\n// Or set it to 1. + for number of samples (so 1.0 is effectively off, 4.0 is 2x2 multisampling etc etc..)\n\nconst float MULTISAMPLING = 0.0;\nconst float THICKNESS = 0.01;\nconst float SPACING = 0.03;\nconst float INNER_RADIUS = 0.4;\nconst float OUTER_RADIUS = 0.9;\nconst float MAX_DROOP = 0.3;\nconst float CURVE = 0.1;\nconst float CURL_AMPLITUDE = 0.0;\nconst float CURL_FREQUENCY = 10.0;\nconst float UNEVEN_LENGTH = 0.0;\nconst float RANDOM_OFFSET = 0.45;\n\nvec3 straightPos;\nvec2 sphericalCoords;\nvec2 gridCell;\nfloat radialDistance;\nfloat normalizedRadius;\n\nfloat sphereSDF(vec3 p) {\n    return length(p) - INNER_RADIUS;\n}\n\nvec2 hash2(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat hash(vec2 p) {\n    p = fract(p * vec2(123.34, 456.78));\n    p += dot(p, p + 34.56);\n    return fract(p.x * p.y);\n}\n\nvec2 cartesianToSpherical(vec3 p) {\n    float r = length(p);\n    if (r < 0.001) return vec2(0.0);\n    vec3 n = p / r;\n    return vec2(acos(clamp(n.y, -1.0, 1.0)), atan(n.z, n.x));\n}\n\nvec3 applyDroop(vec3 p) {\n    float r = length(p);\n    float normalized = (r - INNER_RADIUS) / (OUTER_RADIUS - INNER_RADIUS);\n    float droopFactor = normalized * normalized;\n    \n    vec3 droopedPos = p;\n    droopedPos.y -= droopFactor * MAX_DROOP;\n    \n    vec3 toCenter = -normalize(vec3(p.x, 0.0, p.z));\n    droopedPos += toCenter * droopFactor * CURVE;\n    \n    return droopedPos;\n}\n\nvec3 inverseDroop(vec3 p) {\n    vec3 straight = p;\n    for (int i = 0; i < 4; i++) {\n        straight += (p - applyDroop(straight)) * 0.7;\n    }\n    return straight;\n}\n\nvoid getHairData(vec3 p) {\n    straightPos = inverseDroop(p);\n    sphericalCoords = cartesianToSpherical(straightPos);\n    radialDistance = length(straightPos);\n    normalizedRadius = (radialDistance - INNER_RADIUS) / (OUTER_RADIUS - INNER_RADIUS);\n    \n    float gridSpacing = 0.01;\n    float lonSpacing = gridSpacing / max(sin(sphericalCoords.x), 0.1);\n    gridCell = vec2(\n        round(sphericalCoords.x / gridSpacing),\n        round(sphericalCoords.y / lonSpacing)\n    );\n}\n\nfloat sdRadialLine(vec3 p, float spacing, float thickness) {\n    getHairData(p);\n    \n    vec2 latLon = sphericalCoords;\n    float lonSpacing = spacing / max(sin(latLon.x), 0.1);\n    float latIndex = round(latLon.x / spacing);\n    float lonIndex = round(latLon.y / lonSpacing);\n    \n    if (CURL_AMPLITUDE > 0.0) {\n        latLon.y += sin(length(p) * CURL_FREQUENCY) * CURL_AMPLITUDE;\n    }\n    \n    vec2 randomOffset = hash2(vec2(latIndex, lonIndex)) * RANDOM_OFFSET;\n    vec2 gridCenter = vec2(\n        latIndex * spacing + randomOffset.x * spacing,\n        lonIndex * lonSpacing + randomOffset.y * lonSpacing\n    );\n    \n    vec2 toLine = latLon - gridCenter;\n    toLine.y *= sin(latLon.x);\n    float distToLine = length(toLine);\n    \n    if (distToLine > spacing) return 1e10;\n    \n    float taperFactor = 1.0 - normalizedRadius;\n    float thicknessVariation = 0.4 + 0.8 * hash(vec2(latIndex, lonIndex));\n    float currentThickness = thickness * taperFactor * thicknessVariation;\n    \n    if (UNEVEN_LENGTH > 0.0) {\n        float hairLengthRandom = hash(vec2(latIndex, lonIndex) + 42.0);\n        float minLength = 1.0 / (1.0 + UNEVEN_LENGTH);\n        float maxLength = 0.97;// * (1.0 + UNEVEN_LENGTH);\n        float adjustedRadius = normalizedRadius / mix(minLength, maxLength, hairLengthRandom);\n        \n        if (adjustedRadius > 1.0) return 1e10;\n        \n        currentThickness *= (1.0 - normalizedRadius) * (1.0 - adjustedRadius);\n    }\n    \n    return distToLine - currentThickness;\n}\n\nvec4 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        float distFromCenter = length(p);\n        float d = sphereSDF(p);\n        \n        if (distFromCenter > INNER_RADIUS && distFromCenter < OUTER_RADIUS) {\n            d = min(d, sdRadialLine(p, SPACING, THICKNESS));\n        }\n        \n        if (d < 0.0005) {\n            float objectId = 0.0;\n            float opacity = 1.0;\n            \n            if (distFromCenter > INNER_RADIUS && distFromCenter < OUTER_RADIUS) {\n                if (sdRadialLine(p, SPACING, THICKNESS) < sphereSDF(p)) {\n                    objectId = 1.0;\n                    opacity = 1.0 - normalizedRadius * 0.8;\n                }\n            }\n            \n            return vec4(t, objectId, hash(gridCell), opacity);\n        }\n        \n        t += d * 0.8;\n        if (t > 20.0) break;\n    }\n    \n    return vec4(-1.0);\n}\n\nfloat mapScene(vec3 p) {\n    float distFromCenter = length(p);\n    if (distFromCenter > INNER_RADIUS && distFromCenter < OUTER_RADIUS) {\n        return min(sphereSDF(p), sdRadialLine(p, SPACING, THICKNESS));\n    }\n    return sphereSDF(p);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float res = 1.0;\n    float t = tmin;\n    \n    for (int i = 0; i < 6; i++) {\n        float h = mapScene(ro + rd * t);\n        res = min(res, 2.0 * h / t);\n        t += clamp(h, 0.02, 0.2);\n        if (res < 0.005 || t > tmax) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(vec3 p, float objectId) {\n    if (objectId < 0.5) {\n        return normalize(p);\n    }\n    \n    vec2 e = vec2(0.001, 0.0);\n    float base = mapScene(p);\n    return normalize(vec3(\n        mapScene(p + e.xyy) - base,\n        mapScene(p + e.yxy) - base,\n        mapScene(p + e.yyx) - base\n    ));\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\nvoid mainImage0(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec2 pan = -5.*((iMouse.xy/iResolution.xy)-0.5);// = iTime * 0.5;\n    float camRadius = 3.0;\n    float camHeight = pan.y;\n    \n    vec3 ro = vec3(camRadius * cos(pan.x), camHeight, camRadius * sin(pan.x));\n    vec3 target = vec3(0.0);\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    vec3 col = vec3(0.7);\n    vec3 lightPos = vec3(2.0, 1.0, 2.0);\n    \n    vec2 outerHit = raySphere(ro, rd, OUTER_RADIUS);\n    if (outerHit.x > 0.0) {\n        vec3 pEnter = ro + rd * outerHit.x + rd * 0.001;\n        vec4 hit = raymarch(pEnter, rd);\n        \n        if (hit.x > 0.0) {\n            vec3 pHit = pEnter + rd * hit.x;\n            vec3 normal = calcNormal(pHit, hit.y);\n            vec3 lightDir = normalize(lightPos - pHit);\n            \n            float diffuse = max(dot(normal, lightDir), 0.0);\n            float shadow = calcSoftShadow(pHit + normal * 0.001, lightDir, 0.001, length(lightPos - pHit));\n            diffuse *= shadow;\n            \n            float ambient = 0.4;\n            vec3 hitColor;\n            \n            if (hit.y > 0.5) {\n                vec3 hairColors[4] = vec3[4](\n                    vec3(0.95, 0.8, 0.4),\n                    vec3(0.8, 0.5, 0.3),\n                    vec3(0.9, 0.4, 0.4),\n                    vec3(0.5, 0.7, 0.9)\n                );\n                \n                int colorIndex = min(int(hit.z * 4.0), 3);\n                vec3 hairBaseColor = hairColors[colorIndex];\n                hitColor = hairBaseColor * (diffuse + ambient);\n                \n                vec3 viewDir = -rd;\n                vec3 halfDir = normalize(lightDir + viewDir);\n                float specular = pow(max(dot(normal, halfDir), 0.0), 8.0);\n                hitColor += specular * 0.4;\n                \n                col = mix(col, hitColor, hit.w*1.5);\n            } else {\n                col = vec3(0.9, 0.8, 0.8) * (diffuse + ambient);\n            }\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n// multisampling, from \"Weyl Supersample Any Shader\" by spalmer https://www.shadertoy.com/view/WXjXRt\n// (forked from from \"postprocess existing shaders\" by FabriceNeyret2 https://www.shadertoy.com/view/NdyfRz \nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float samples = MULTISAMPLING<1.?floor(max(1.,((iMouse.x/iResolution.x)*16.))):MULTISAMPLING;\n    vec2 jitter = vec2(0.5);\n    fragColor = vec4(0.0);\n    vec4 color;\n    \n    mainImage0(color, fragCoord);\n    for (float k = samples; k-- > 0.5;) {\n        mainImage0(color, fragCoord + jitter - 0.5);\n        fragColor += color;\n        jitter = fract(jitter + vec2(0.755, 0.57).yx);\n    }\n    \n    fragColor /= samples;\n    fragColor.a = 1.0;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tclcz8",
    "date": "1755335513",
    "viewed": 121,
    "name": "Magnetosphere adaptation",
    "description": "I was wondering if magnetic field lines would make for a better hair pattern, and that kinda led to this.",
    "likes": 13,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "domainrepetition",
     "earth",
     "fieldlines",
     "magnetosphere"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Domain Repetition Hair/Fur\" by Cotterzz. https://shadertoy.com/view/wfXczr\n// 2025-08-16 07:37:29\n\n// Also check out magnetosphere hair: https://www.shadertoy.com/view/3cfczN\n// And hair V2: https://www.shadertoy.com/view/3fsyzn\n\n#define AA 1.0\n#define LATSPACING 0.1\n#define AZISPACING 0.6\n#define LTHICKNESS 0.004\n\nfloat sdSphere(vec3 p, float r) {return length(p) - r;}\n\nvec3 getMagField(vec3 p) {\n   float r = length(p);\n   if(r < 0.001) return vec3(0,1,0);\n   vec3 rh = p / r;\n   float r3 = r * r * r, mdotr = rh.y;\n   return normalize((3.0 * mdotr * rh - vec3(0,1,0)) / r3);\n}\n\nvec2 getFieldParams(vec3 p) {\n   float r = length(p);\n   if(r < 0.001) return vec2(0);\n   float sinTheta = length(p.xz) / r, sinTheta2 = sinTheta * sinTheta;\n   return vec2(r / (sinTheta2 + 0.001), atan(p.z, p.x));\n}\n\nfloat LToLat(float L) {return asin(1.0 / sqrt(L));}\nfloat latToL(float lat) {float s = sin(lat); return 1.0 / (s*s + 0.001);}\n\nfloat sdMagLine(vec3 p, float latSpc, float aziSpc, float thick) {\n   vec2 prm = getFieldParams(p);\n   float L = prm.x, phi = prm.y;\n   if(L > 20.0) return 1e10;\n   \n   float lat = LToLat(L);\n   float nearLat = round(lat / latSpc) * latSpc;\n   float nearL = latToL(nearLat), nearPhi = round(phi / aziSpc) * aziSpc;\n   \n   float Ldiff = abs(L - nearL) / L;\n   float phiDiff = abs(phi - nearPhi) * sin(lat);\n   float dist = sqrt(Ldiff*Ldiff + phiDiff*phiDiff);\n   \n   float latFac = abs(p.y) / length(p), distFac = 0.4 / length(p);\n   return dist - thick * (1.0 + 2.0 * latFac) * (0.5 + distFac);\n}\n\nfloat hash(vec2 p) {\n   p = fract(p * vec2(123.34, 456.78));\n   p += dot(p, p + 34.56);\n   return fract(p.x * p.y);\n}\n\nvec2 getLineID(vec3 p, float latSpc, float aziSpc) {\n   vec2 prm = getFieldParams(p);\n   float lat = LToLat(prm.x);\n   return vec2(round(lat / latSpc), round(prm.y / aziSpc));\n}\n\nfloat map(vec3 p) {return sdSphere(p, 0.4);}\n\nfloat mapLines(vec3 p, float latSpc, float aziSpc, float thick) {\n   return min(sdSphere(p, 0.4), sdMagLine(p, latSpc, aziSpc, thick));\n}\n\nbool inMagnet(vec3 p) {float d = length(p); return d > 0.4 && d < 3.0;}\n\nfloat getOpacity(vec3 p) {\n   float r = length(p), nr = (r - 0.4) / 2.0, latFac = abs(p.y) / r;\n   return clamp((1.0 - nr * 0.5) * (0.5 + 0.5 * latFac), 0.3, 1.0);\n}\n\nvec4 raymarch(vec3 ro, vec3 rd, float latSpc, float aziSpc, float thick) {\n   float t = 0.0;\n   for(int i = 0; i < 100; i++) {\n       vec3 p = ro + rd * t;\n       float d = mapLines(p, latSpc, aziSpc, thick);\n       \n       if(d < 0.001) {\n           float objId = 0.0, opacity = 1.0;\n           vec2 lineID = getLineID(p, latSpc, aziSpc);\n           \n           if(inMagnet(p)) {\n               float innerD = sdSphere(p, 0.4);\n               float lineD = sdMagLine(p, latSpc, aziSpc, thick);\n               if(lineD < innerD) {objId = 1.0; opacity = getOpacity(p);}\n           }\n           return vec4(t, objId, hash(lineID), opacity);\n       }\n       t += d * 0.8;\n       if(t > 10.0) break;\n   }\n   return vec4(-1,-1,0,0);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, float r) {\n   float b = dot(ro, rd), c = dot(ro, ro) - r*r, h = b*b - c;\n   if(h < 0.0) return vec2(-1);\n   h = sqrt(h);\n   return vec2(-b - h, -b + h);\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n   vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n   \n   vec2 mouse = iMouse.xy / iResolution.xy;\n   if(length(iMouse.xy) < 0.001) mouse = vec2(0.5);\n   \n   float theta = (mouse.x - 0.5) * 6.28318;\n   float phi = (mouse.y - 0.5) * 3.14159;\n   float autoRot = iTime * 0.1;\n   if(iMouse.z > 0.0) autoRot = 0.0;\n   theta += autoRot;\n   \n   float radius = 3.5;\n   vec3 ro = vec3(radius * cos(theta) * cos(phi), radius * sin(phi),\n                  radius * sin(theta) * cos(phi));\n   \n   vec3 target = vec3(0), forward = normalize(target - ro);\n   vec3 right = normalize(cross(vec3(0,1,0), forward));\n   vec3 up = cross(forward, right);\n   vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n  \n   vec3 col = vec3(0.02, 0.05, 0.1);\n   \n   vec2 outerHit = raySphere(ro, rd, 3.0);\n   if(outerHit.x > 0.0) {\n       vec3 pEnter = ro + rd * outerHit.x;\n       vec3 roInner = pEnter + rd * 0.001;\n       vec4 hit = raymarch(roInner, rd, LATSPACING, AZISPACING, LTHICKNESS);\n       \n       if(hit.x > 0.0) {\n           vec3 pHit = roInner + rd * hit.x;\n           vec3 nHit = normalize(pHit);\n           vec3 lightDir = normalize(vec3(3,2,-3) - pHit);\n           float diff = max(dot(nHit, lightDir), 0.0), ambient = 0.4;\n           \n           if(hit.y > 0.5) {\n               vec3 lineColA = vec3(0.3, 0.7, 1.0);\n               vec3 lineColB = vec3(0.1, 1.0, 0.7);\n               vec3 lineCol = mix(lineColA, lineColB, hit.z);\n               vec3 hitCol = lineCol * (diff * 0.6 + ambient);\n               float glow = exp(-length(pHit) * 0.3);\n               hitCol += lineCol * glow * 0.3;\n               col = mix(col, hitCol, hit.w);\n           } else {\n               col = vec3(0.2, 0.4, 0.7) * (diff + ambient);\n           }\n       }\n   }\n   fragColor = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n   float s = AA, k; vec2 j = vec2(.5); o = vec4(0); vec4 c;\n   mainImage0(c, u);\n   for (k = s; k-- > .5; ) {\n       mainImage0(c, u + j - .5); o += c;\n       j = fract(j + vec2(.755, .57).yx);\n   };o /= s;o.a==1.;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cfczN",
    "date": "1755371188",
    "viewed": 106,
    "name": "Magnetosphere hair",
    "description": "I was wondering if magnetic field lines would make for a better hair pattern, this is the result applied to first prototype.\nHave a play with params, AA is broken",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "domainrepetition",
     "hair",
     "fur",
     "fieldlines",
     "magnetosphere"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Magnetosphere adaptation\" by Cotterzz. https://shadertoy.com/view/tclcz8\n// 2025-08-16 19:00:03\n\n// Fork of \"Domain Repetition Hair/Fur\" by Cotterzz. https://shadertoy.com/view/wfXczr\n// 2025-08-16 07:37:29\n\n// Also check out Hair V2 here: https://www.shadertoy.com/view/3fsyzn\n\n// I did two things here:\n// 1. Apply the magnetic field pattern back to the first hair prototype\n// 2. Try and fix the problem I had with hair where the semi transparent ends cause the ray to stop\n// when it should pass though and render the next thing.\n// (Maybe using transparecy as a tapering method is also not the way to go.)\n// It works, mostly, but not with AA, still figuring that out\n// I still have more to learn with raymarching SDFs.\n\n\n#define AA 1.0  // AA is broken, don't use.\n#define LATSPACING 0.02\n#define AZISPACING 0.04\n#define HAIRTHICK 0.01\n#define HAIRLENGTH 0.6\n#define INNER_RADIUS 0.4\n#define OUTER_RADIUS 0.8\n#define MAX_PASSES 4\n\nfloat sdSphere(vec3 p, float r) {return length(p) - r;}\n\nvec3 getHairField(vec3 p) {\n    float r = length(p);\n    if(r < 0.001) return vec3(0,-1,0);\n    vec3 rh = p / r;\n    float r3 = r * r * r;\n    float mdotr = -rh.y;\n    return normalize((3.0 * mdotr * rh + vec3(0,1,0)) / r3);\n}\n\nvec2 getHairParams(vec3 p) {\n    float r = length(p);\n    if(r < 0.001) return vec2(0);\n    float sinTheta = length(p.xz) / r, sinTheta2 = sinTheta * sinTheta;\n    return vec2(r / (sinTheta2 + 0.001), atan(p.z, p.x));\n}\n\nfloat LToLat(float L) {\n    if(L < 1.0) return 1.57;\n    return asin(clamp(1.0 / sqrt(L), -1.0, 1.0));\n}\nfloat latToL(float lat) {float s = sin(lat); return 1.0 / (s*s + 0.001);}\n\nfloat sdHairLine(vec3 p, float latSpc, float aziSpc, float thick) {\n    float r = length(p);\n    if(r < INNER_RADIUS || r > INNER_RADIUS + HAIRLENGTH) return 1e10; \n    vec2 prm = getHairParams(p);\n    float L = prm.x, phi = prm.y;\n    if(L < 0.1 ) return 1e10;\n    float lat = LToLat(L);\n    if(lat < 0.1) return 1e10;\n    float nearLat = round(lat / latSpc) * latSpc;\n    if(nearLat < 0.1) return 1e10;\n    float nearL = latToL(nearLat), nearPhi = round(phi / aziSpc) * aziSpc;\n    float Ldiff = abs(L - nearL) / L;\n    float phiDiff = abs(phi - nearPhi) * sin(lat);\n    float dist = sqrt(Ldiff*Ldiff + phiDiff*phiDiff);\n    float taper = 1.0 - smoothstep(INNER_RADIUS, INNER_RADIUS + HAIRLENGTH, r);\n    if(taper <= 0.0) return 1e10;\n    return dist - thick * taper;\n}\n\nfloat hash(vec2 p) {\n    p = fract(p * vec2(123.34, 456.78));\n    p += dot(p, p + 34.56);\n    return fract(p.x * p.y);\n}\n\nvec2 getHairID(vec3 p, float latSpc, float aziSpc) {\n    vec2 prm = getHairParams(p);\n    if(prm.x < 1.0) return vec2(0);\n    float lat = LToLat(prm.x);\n    return vec2(round(lat / latSpc), round(prm.y / aziSpc));\n}\n\nfloat map(vec3 p) {return sdSphere(p, INNER_RADIUS);}\n\nfloat mapHairs(vec3 p, float latSpc, float aziSpc, float thick) {\n    return min(sdSphere(p, INNER_RADIUS), sdHairLine(p, latSpc, aziSpc, thick));\n}\n\nbool inHairZone(vec3 p) {\n    float d = length(p);\n    return d > INNER_RADIUS && d < INNER_RADIUS + HAIRLENGTH;\n}\n\nfloat getHairOpacity(vec3 p) {\n    float r = length(p);\n    float fade = 1.0 - smoothstep(INNER_RADIUS, INNER_RADIUS + HAIRLENGTH, r);\n    return fade * 0.9;\n}\n\nvec3 getHairColor(vec3 p, float random, vec3 lightDir, vec3 lightDir2, vec3 viewDir) {\n    vec3 nHit = normalize(p);\n    float diff = max(dot(nHit, lightDir), 0.0);\n    float diff2 = max(dot(nHit, lightDir2), 0.0);\n    float ambient = 0.3;\n    vec3 hairColA = vec3(0.85, 0.6, 0.3);\n    vec3 hairColB = vec3(0.5, 0.4, 0.0);\n    vec3 hairCol = mix(hairColA, hairColB, random);\n    vec3 hitCol = hairCol * (diff + ambient);\n    hitCol += vec3(0.3,0,0) * (diff2 + ambient);\n    float spec = pow(max(dot(reflect(-lightDir, nHit), viewDir), 0.0), 16.0);\n    hitCol += vec3(0.4) * spec;\n    return hitCol;\n}\n\nvec3 raymarchVolume(vec3 ro, vec3 rd, float latSpc, float aziSpc, float thick) {\n    float t = 0.0;\n    vec3 col = vec3(0.9, 0.85, 0.8); \n    \n    vec3 lightDir = normalize(vec3(2,3,-2));\n    vec3 lightDir2 = normalize(vec3(-1,-2,1));\n    \n    for(int pass = 0; pass < MAX_PASSES; pass++) {\n        bool hitSomething = false;\n        \n        for(int i = 0; i < 150; i++) {\n            vec3 p = ro + rd * t;\n            float d = mapHairs(p, latSpc, aziSpc, thick);\n            \n            if(d < 0.001) {\n                float objId = 0.0, opacity = 1.0;\n                vec2 hairID = getHairID(p, latSpc, aziSpc);\n                \n                if(inHairZone(p)) {\n                    float innerD = sdSphere(p, INNER_RADIUS);\n                    float hairD = sdHairLine(p, latSpc, aziSpc, thick);\n                    if(hairD < innerD && hairD < 0.001) {\n                        objId = 1.0;\n                        opacity = getHairOpacity(p);\n                    }\n                }\n                \n                if(objId > 0.5) {\n                    // Hair hit - blend and continue if transparent\n                    vec3 hairCol = getHairColor(p, hash(hairID), lightDir, lightDir2, -rd);\n                    col = mix(col, hairCol, opacity);\n                    // If mostly opaque, stop here\n                    if(opacity > 0.8) return col;           \n                    // Continue ray slightly past this hit\n                    t += 0.001;\n                    hitSomething = true;\n                    break;\n                } else {\n                    // Hit solid head - fully opaque\n                    vec3 nHit = normalize(p);\n                    float diff = max(dot(nHit, lightDir), 0.0);\n                    float ambient = 0.3;\n                    col = vec3(0.6, 0.5, 0.4) * (diff + ambient);\n                    return col;\n                }\n            }\n            \n            t += d * 0.8;\n            if(t > 5.0) break;\n        }\n        \n        // If we didn't hit anything in this pass, we're done\n        if(!hitSomething) break;\n    }\n    \n    return col;\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(ro, rd), c = dot(ro, ro) - r*r, h = b*b - c;\n    if(h < 0.0) return vec2(-1);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(length(iMouse.xy) < 0.001) mouse = vec2(0.5);\n    \n    float theta = (mouse.x - 0.5) * 6.28318;\n    float phi = (mouse.y - 0.5) * 3.14159;\n    float autoRot = iTime * 0.2;\n    if(iMouse.z > 0.0) autoRot = 0.0;\n    theta += autoRot;\n    \n    float radius = 2.5;\n    vec3 ro = vec3(radius * cos(theta) * cos(phi), radius * sin(phi),\n                   radius * sin(theta) * cos(phi));\n    \n    vec3 target = vec3(0), forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n   \n    vec3 col = vec3(0.9, 0.85, 0.8);\n    \n    vec2 outerHit = raySphere(ro, rd, OUTER_RADIUS);\n    if(outerHit.x > 0.0) {\n        vec3 pEnter = ro + rd * outerHit.x;\n        vec3 roInner = pEnter + rd * 0.001;\n        col = raymarchVolume(roInner, rd, LATSPACING, AZISPACING, HAIRTHICK);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float s = AA, k; vec2 j = vec2(.5); o = vec4(0); vec4 c;\n    mainImage0(c, u);\n    for (k = s; k-- > .5; ) {\n        mainImage0(c, u + j - .5); o += c;\n        j = fract(j + vec2(.755, .57).yx);\n    };o /= s;o.a==1.;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wcfyzM",
    "date": "1755458213",
    "viewed": 236,
    "name": "Cat Eye Iris/Pupil texture",
    "description": "A quick 2D mockup of the eye turned out better than I expected.\nMouse over to dilate pupil",
    "likes": 27,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "sdf",
     "eye",
     "cat",
     "iris",
     "predator",
     "dilation",
     "vesica",
     "pupil"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "Xsf3Rr",
       "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Cat Eye SDF\" by Cotterzz. https://shadertoy.com/view/tXKXzV\n// 2025-08-17 19:10:26\n\nfloat sdCateye(vec2 p, float height, float dilation)\n{\n    float vrad = height/2.;\n    dilation = min(.999, max(0.01, dilation));\n    float rad = (vrad)/dilation;\n    float dist = sqrt((rad*rad)-(vrad*vrad));\n    p = abs(p);\n    vec2 center = vec2(-dist, 0.);\n    float tdist = distance(p, center);\n    float result = tdist - rad;\n    vec2 nearest = center+(p-center)*rad/tdist;\n    if(nearest.y>vrad){result=distance(p,vec2(0.,vrad));}\n\n    return result;\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p*=1.3;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float eHeight = 1.;\n    float eDilation = 0.4*(sin(iTime)+1.3);\n    \n    if( iMouse.z>0.001 ) {eHeight = 1.0;//iMouse.y/iResolution.y;\n        eDilation = iMouse.x/iResolution.x/0.9;}\n    eHeight*=1.5-(eDilation/6.);\n\tfloat dA = sdCateye( p, eHeight, 0.0);\n    float dB = sdCateye( p, eHeight, eDilation);\n    float d = dB-dA;\n    if(p.x<0.){d=-d;}\n    float cd = length(p*vec2(.9,1));\n    d = mix(d,0. , min(1.,max(0.,(cd-.8)*5.)));\n    float eb = distance(p, vec2(0.1, -0.6));\n    float el = distance(p, vec2(0.3, -1.2));\n    float et = distance(p, vec2(-.2, 0.6));\n    float ee = max(et, eb);\n    vec3 col = (dB>0.0) ? (texture(iChannel0, (p.xy+vec2(d,0))/6., 0.).rgb+0.2)/(0.7+dB): vec3(0);\n    col = mix(col*col*col, col, min(1.,dB*10.));\n    col = mix(vec3(0), col, min(1.,dB*45.));\n    dB = dB*dB;\n    col = contrast(col, 1.-(dB/5.));\n    col = gmc(col, 0.4+dB);\n    if(col.r<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    if(col.g<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    col = mix(col, vec3(0), max(0.,cd-.93 )*7.);\n    col = mix(col, vec3(0.9,1,1.0), min(1.,max(0.,cd-1.05 )*15.));\n    col = mix(col, col*vec3(.01,.015,.01), min(1.,max(0.,el-1.6 )*2.));\n    float ref = texture(iChannel1, (p.xy + vec2(-1.5,1))*vec2(-0.5,0.5), 0.).b;\n    ref=0.4+ref/2.;\n    if(ee<1.53){col = col+max(0.,(ref-0.8)*15.);}\n    col = mix(col, vec3(0.1,.11,0.1), min(1.,max(0.,ee-1.6 )*15.));\n    col.g*=1.5;\n\tfragColor = vec4(col,1.);\n}\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WfXcWn",
    "date": "1755512030",
    "viewed": 157,
    "name": "Cat Eye - Raymarched",
    "description": "A more realistic 3D version of a cat eye.\nUsing the texture animation from the 2D mockup.\nClick and drag.",
    "likes": 25,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "3d",
     "refraction",
     "eye",
     "cat",
     "iris",
     "realistic",
     "dilation",
     "pupil"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3Rr",
       "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Cat Eye Iris/Pupil texture\" by Cotterzz. https://www.shadertoy.com/view/wcfyzM\n// 2025-08-18 09:54:31\n// Fork of \"Cat Eye SDF\" by Cotterzz. https://shadertoy.com/view/tXKXzV\n// 2025-08-17 19:10:26\n\n#define AA 2.0\n#define MAX_STEPS 150\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n// Texture mapping and displacement parameters\n#define UV_SCALE_X 0.4\n#define UV_SCALE_Y 0.6\n#define UV_OFFSET 0.5\n#define DISPLACE_AMOUNT 0.02\n// Flatten parameters\n#define FLATTEN_ANGLE 0.7\n#define FLATTEN_DEPTH 0.5   \n#define LIGHTP vec3(1.0,1.0,-0.9)\n\nmat3 g_rotation;\nfloat g_lightIntensity = 0.0;\n\nfloat calculateIrisLightIntensity(mat3 rotation) {\n    \n    vec3 irisForward = rotation * vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = normalize(LIGHTP);\n    float intensity = max(0.0, dot(irisForward, lightDir));\n    intensity = pow(intensity, 2.0); \n    return intensity;\n}\n\n// iris texture functions from first shader\nfloat sdCateye(vec2 p, float height, float dilation)\n{\n    float vrad = height/2.;\n    dilation = min(.999, max(0.01, dilation));\n    float rad = (vrad)/dilation;\n    float dist = sqrt((rad*rad)-(vrad*vrad));\n    p = abs(p);\n    vec2 center = vec2(-dist, 0.);\n    float tdist = distance(p, center);\n    float result = tdist - rad;\n    vec2 nearest = center+(p-center)*rad/tdist;\n    if(nearest.y>vrad){result=distance(p,vec2(0.,vrad));}\n    return result;\n}\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);}\nvec3 gmc(vec3 colour, float gamma) {return pow(colour, vec3(1. / gamma));}\n\nvec4 eyeTexture(vec2 uv, float lightDilation) {\n    vec2 p = (uv*2.)-1.;\n    p.x/=iResolution.y/iResolution.x;\n    p*=1.3;\n    float eHeight = 1.;\n    float eDilation = mix(1.0, 0.15, 1.-lightDilation); \n    eHeight= 1.0 + eDilation/2.;\n\tfloat dA = sdCateye( p, eHeight, 0.0);\n    float dB = sdCateye( p, eHeight, eDilation);\n    float d = dB-dA;\n    if(p.x<0.){d=-d;}\n    float cd = length(p*vec2(.84,1)*1.06);\n    d = mix(d,0. , min(1.,max(0.,(cd-.8)*5.)));\n    float eb = distance(p, vec2(0.1, -0.6));\n    float el = distance(p, vec2(0.3, -1.2));\n    float et = distance(p, vec2(-.2, 0.6));\n    float ee = max(et, eb);\n    vec3 col = (dB>0.0) ? (texture(iChannel0, (p.xy+vec2(d,0))/6., 0.).rgb+0.2)/(0.7+dB): vec3(0);\n    col = mix(col*col*col, col, min(1.,dB*10.));\n    col = mix(vec3(0), col, min(1.,dB*45.));\n    dB = dB*dB;\n    col = contrast(col, 1.-(dB/5.));\n    col = gmc(col, 0.4+dB);\n    if(col.r<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    if(col.g<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    col = mix(col, vec3(0,0,0.1), max(0.,cd-.93 )*7.);\n    col.g*=1.5;\n    col = mix(col, vec3(1,1,1), min(1.,max(0.,cd-1.05 )*15.));\n    return vec4(col, 1.);\n}\n\nfloat sdEye(vec3 p, float r) {\n    \n    float d = length(p) - r;\n    float cutDepth = r * cos(FLATTEN_ANGLE);\n    float planeD = -p.z - cutDepth;\n    d = max(d, planeD);\n\n    float outerRadius = r * sin(FLATTEN_ANGLE);\n    float innerRadius = FLATTEN_DEPTH;\n    float distFromCenter = length(p.xy);\n    \n    if (p.z <= -cutDepth + 0.1 && distFromCenter <= outerRadius) {\n        vec2 uv;\n        uv.x = p.x * UV_SCALE_X + UV_OFFSET;\n        uv.y = p.y * UV_SCALE_Y + UV_OFFSET;\n        uv = clamp(uv, 0.0, 1.0);\n        \n        vec4 texCol = eyeTexture(uv, g_lightIntensity);\n        float darkness = 1.0 - (texCol.r * 0.299 + texCol.g * 0.587 + texCol.b * 0.114);\n        \n        float falloff = 1.0;\n        if (distFromCenter > innerRadius) {\n            falloff = 1.0 - smoothstep(innerRadius, outerRadius, distFromCenter);\n        }\n        \n        float displaceAmount = darkness * DISPLACE_AMOUNT * falloff;\n        d += displaceAmount;\n    }\n    \n    return d;\n}\n\nfloat sdLens(vec3 p, float r) {return abs(length(p) - r - 0.02) - 0.003; }\n\nvec3 getEyeNormal(vec3 p) {\n    float d = sdEye(p, 1.0);\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = d - vec3(\n        sdEye(p - e.xyy, 1.0),\n        sdEye(p - e.yxy, 1.0),\n        sdEye(p - e.yyx, 1.0)\n    );\n    \n    return normalize(n);\n}\n\nvec3 getLensNormal(vec3 p) {\n\n    return normalize(p); // Only works for a sphere centered at origin\n    // keep this in case we need it again\n    float d = sdLens(p, 1.0);\n    vec2 e = vec2(0.001, 0);\n    vec3 n = d - vec3(\n        sdLens(p - e.xyy, 1.0),\n        sdLens(p - e.yxy, 1.0),\n        sdLens(p - e.yyx, 1.0)\n    );\n    return normalize(n);\n    \n}\n\nfloat rayMarchEye(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdEye(p, 1.0);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat rayMarchLens(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdLens(p, 1.0);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 getTextureColor(vec3 p) {\n    if (p.z < 0.0) {\n        vec2 uv;\n        uv.x = p.x * UV_SCALE_X + UV_OFFSET;\n        uv.y = p.y * UV_SCALE_Y + UV_OFFSET;\n        uv = clamp(uv, 0.0, 1.0);\n        \n        return eyeTexture(uv, g_lightIntensity).rgb;\n    }\n    return vec3(0.8, 0.8, 0.8);\n}\n\nvec3 getEyeLight(vec3 p, vec3 rd) {\n\n    vec3 lightInEyeSpace = g_rotation * LIGHTP;\n    vec3 l = normalize(lightInEyeSpace - p);\n    vec3 n = getEyeNormal(p);\n    vec3 v = -rd;\n    vec3 r = reflect(-l, n);\n    vec3 albedo = getTextureColor(p);\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float spec = pow(max(dot(r, v), 0.0), 16.0);\n    vec3 ambient = albedo * 0.15;\n    vec3 diffuse = albedo * dif *0.5;\n    vec3 specular = vec3(1.0) * spec * 0.01;\n    return ambient + diffuse + specular;\n}\n\n\nvec3 getLensLight(vec3 p, vec3 rd) {\n    vec3 lightInEyeSpace = g_rotation * LIGHTP;\n    vec3 l = normalize(lightInEyeSpace - p);\n    vec3 n = getLensNormal(p);\n    vec3 v = -rd;\n    vec3 r = reflect(-l, n);\n    float spec = pow(max(dot(r, v), 0.0), 32.0);\n    float fresnel = pow(1.0 - abs(dot(v, n)), 1.0);\n    vec3 lensColor = vec3(0.95, 0.97, 1.0); \n    vec3 baseGlass = lensColor * 0.2; \n    vec3 specular = vec3(1.) * spec * 50.0; \n    vec3 fresnelColor = lensColor * fresnel *0.2;\n    \n    return baseGlass + specular + fresnelColor;\n}\n\n// Refraction using Snell's law\nvec3 refract_ray(vec3 incident, vec3 normal, float eta) {\n    float cosI = -dot(normal, incident);\n    float sinT2 = eta * eta * (1.0 - cosI * cosI);\n    if (sinT2 > 1.0) return vec3(0.0); // Total internal reflection\n    float cosT = sqrt(1.0 - sinT2);\n    return eta * incident + (eta * cosI - cosT) * normal;\n}\n\n\nvec4 renderWithRefraction(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.04, 0.04, 0.05);\n    float nearestD = MAX_DIST;\n    // First, check if we hit the lens\n    float lensD = rayMarchLens(ro, rd);\n    nearestD = min(nearestD, lensD);\n    if(lensD < MAX_DIST) {\n        vec3 lensP = ro + rd * lensD;\n        vec3 lensN = getLensNormal(lensP);\n        \n        // Calculate refraction\n        float eta = 1.0 / 1.1; // Air to glass (1.52 is typical for eye lens)\n        vec3 refractedRay = refract_ray(rd, lensN, eta);\n        \n        if(length(refractedRay) > 0.0) {\n            // Continue raymarching with refracted ray\n            vec3 newRo = lensP + refractedRay * 0.01; // Small offset to avoid self-intersection\n            // Check if refracted ray hits the eye\n            float eyeD = rayMarchEye(newRo, refractedRay);\n            \n            if(eyeD < MAX_DIST) {\n                vec3 eyeP = newRo + refractedRay * eyeD;\n                vec3 eyeCol = getEyeLight(eyeP, refractedRay);\n                \n                // Apply some color shift/distortion based on refraction angle\n                float refractionStrength = length(rd - refractedRay);\n                eyeCol = mix(eyeCol, eyeCol.gbr, refractionStrength * 0.1); // Slight chromatic aberration\n                \n                col = eyeCol;\n                \n                /* Additional check if we exit through the back of the lens\n                vec3 exitRo = eyeP;\n                vec3 exitRd = -refractedRay; // Ray going back\n                float exitD = rayMarchLens(exitRo, exitRd);\n                if(exitD < MAX_DIST) {\n                    vec3 exitP = exitRo + exitRd * exitD;\n                    vec3 exitN = -getLensNormal(exitP); // Inward normal\n                    vec3 exitRefracted = refract_ray(exitRd, exitN, 1.1); // Glass to air\n                    // Could add additional effects here\n                }*/\n            }\n        }\n        \n        // Add lens surface effects\n        vec3 lensCol = getLensLight(lensP, rd);\n        float fresnel = pow(1.0 - abs(dot(-rd, lensN)), 2.);\n        col = mix(col, lensCol, fresnel * 0.2); // Blend lens surface\n        \n    } else {\n        // No lens hit, render eye directly\n        float eyeD = rayMarchEye(ro, rd);\n        nearestD = min(nearestD, eyeD);\n        if(eyeD < MAX_DIST) {\n            vec3 eyeP = ro + rd * eyeD;\n            col = getEyeLight(eyeP, rd);\n        }\n    }\n    \n    return vec4(col, nearestD);\n}\n\n\nvoid mainMS(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = vec2(0.5+sin(iTime/4.)/5., 0.5+sin(iTime/1.5)/6.);\n    \n    if(iMouse.z>0.001){m = iMouse.xy / iResolution.xy;}\n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float angleY = (m.x - 0.5) * -6.28;\n    float angleX = (m.y - 0.5) * 3.14;\n    \n    mat3 rotY = mat3(\n        cos(angleY), 0, sin(angleY),\n        0, 1, 0,\n        -sin(angleY), 0, cos(angleY)\n    );\n    \n    mat3 rotX = mat3(\n        1, 0, 0,\n        0, cos(angleX), -sin(angleX),\n        0, sin(angleX), cos(angleX)\n    );\n    \n    g_rotation = rotY * rotX;\n    \n    g_lightIntensity = calculateIrisLightIntensity(g_rotation);\n    \n    ro = g_rotation * ro;\n    rd = g_rotation * rd;\n    \n    vec4 colPND = renderWithRefraction(ro, rd);\n    vec3 col = colPND.rgb;\n\n    float nearestD = colPND.a;\n    if(nearestD < MAX_DIST) {\n        col = mix(col, vec3(0.1, 0.1, 0.15), 1.0 - exp(-0.0005 * nearestD * nearestD));\n    }\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}\n\n// AA multisampling\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = AA, k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainMS(c, u); \n    for (k = s; k-- > .5; ) { \n        mainMS(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a=1.;\n} ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WfXcD7",
    "date": "1755687120",
    "viewed": 150,
    "name": "Cat Eye 3D w Fake Caustics",
    "description": "Several improvements:\nDelayed, nicer dilation, plus some fake caustic effects to match the refraction.\nNext I guess I need some subsurface lighting and then try a human eye...\nClick and drag.",
    "likes": 14,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "3d",
     "refraction",
     "eye",
     "cat",
     "iris",
     "realistic",
     "dilation",
     "pupil"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Cat Eye - Raymarched\" by Cotterzz. https://shadertoy.com/view/WfXcWn\n// 2025-08-20 10:11:08\n// Fork of \"Cat Eye Iris/Pupil texture\" by Cotterzz. https://www.shadertoy.com/view/wcfyzM\n// 2025-08-18 09:54:31\n// Fork of \"Cat Eye SDF\" by Cotterzz. https://shadertoy.com/view/tXKXzV\n// 2025-08-17 19:10:26\n\n\n// I had to put it in a buffer so I could store the light amount and have the pupil realistically dilate after a delay\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XsfGRn",
       "filepath": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "Xsf3Rr",
       "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define AA 1.0\n#define MBLUR 2.5\n#define MAX_STEPS 300\n#define MAX_DIST 120.0\n#define SURF_DIST 0.00001\n// Texture mapping and displacement parameters\n#define UV_SCALE_X 0.4\n#define UV_SCALE_Y 0.6\n#define UV_OFFSET 0.5\n#define DISPLACE_AMOUNT 0.03\n// Flatten parameters\n#define FLATTEN_ANGLE 0.8\n#define FLATTEN_DEPTH 0.5   \n#define LIGHTP vec3(1.0,1.3,-1.2)\n\n#define REFRACT 1.12  //1.0 is no refraction.\n// apparenty 1.52 is recommended for eye but is way too much, possibly because geometry\n\n// Light focusing parameters\n#define LENS_FOCUS_STRENGTH 6.0   // How much the lens focuses light\n#define LENS_CUTOFF_ANGLE 1.2     // ~80 degrees in radians - maximum angle for light to pass through lens\n#define BASE_BRIGHTNESS 1.5       // Overall brightness multiplier\n\nmat3 g_rotation;\nfloat g_lightIntensity = 0.0; // real time light intensity\nfloat r_lightIntensity = 0.0; // delayed value for pupil dilation\n\nfloat calculateIrisLightIntensity(mat3 rotation) {\n    \n    vec3 irisForward = rotation * vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = normalize(LIGHTP);\n    float intensity = max(0.0, dot(irisForward, lightDir));\n   intensity = pow(intensity,0.3); \n    return intensity;\n}\n\nfloat sdCateye(vec2 p, float height, float dilation)\n{\n    float vrad = height/2.;\n    dilation = min(.999, max(0.01, dilation));\n    float rad = (vrad)/dilation;\n    float dist = sqrt((rad*rad)-(vrad*vrad));\n    p = abs(p);\n    vec2 center = vec2(-dist, 0.);\n    float tdist = distance(p, center);\n    float result = tdist - rad;\n    vec2 nearest = center+(p-center)*rad/tdist;\n    if(nearest.y>vrad){result=distance(p,vec2(0.,vrad));}\n    return result;\n}\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);}\nvec3 gmc(vec3 colour, float gamma) {return pow(colour, vec3(1. / gamma));}\n\nvec4 eyeTexture(vec2 uv, float lightDilation) {\n    vec2 p = (uv*2.)-1.;\n    p.x/=iResolution.y/iResolution.x;\n    p*=1.3;\n    float eHeight = 1.;\n    float eDilation = mix(1.0, 0.15, 1.-lightDilation); \n    eHeight= 1.0 + eDilation/2.;\n\tfloat dA = sdCateye( p, eHeight, 0.0);\n    float dB = sdCateye( p, eHeight, eDilation);\n    float d = dB-dA;\n    if(p.x<0.){d=-d;}\n    float cd = length(p*vec2(.84,1)/1.07);\n    d = mix(d,0. , min(1.,max(0.,(cd-.8)*5.)));\n    float eb = distance(p, vec2(0.1, -0.6));\n    float el = distance(p, vec2(0.3, -1.2));\n    float et = distance(p, vec2(-.2, 0.6));\n    float ee = max(et, eb);\n    vec2 tuv =  (p.xy+vec2(0.2,-0.3)+vec2(d,0))/6.;\n    vec3 tcol = (texture(iChannel0, tuv.yx, 0.).rgb + texture(iChannel2, tuv.yx, 0.).rgb)/2.4;\n    vec3 col = (dB>0.0) ? (tcol+0.2)/(0.7+dB): vec3(0);\n    col = mix(col*col*col, col, min(1.,dB*20.));\n    col = mix(vec3(0), col, min(1.,dB*25.));\n    dB = dB*dB;\n    col = contrast(col, 1.-(dB/5.));\n    col = gmc(col, 0.4+dB);\n    if(col.r<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    if(col.g<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    col = mix(col, vec3(0,0,0.1), max(0.,cd-.93 )*7.);\n    col.g*=1.5;\n    col = mix(col, vec3(1,1,1), min(1.,max(0.,cd-1.05 )*15.));\n    return vec4(col, 1.);\n}\n\nfloat sdEye(vec3 p, float r) {\n    \n    float d = length(p) - r;\n    float cutDepth = r * cos(FLATTEN_ANGLE);\n    float planeD = -p.z - cutDepth;\n    d = max(d, planeD);\n\n    float outerRadius = r * sin(FLATTEN_ANGLE);\n    float innerRadius = FLATTEN_DEPTH;\n    float distFromCenter = length(p.xy);\n    \n    if (p.z <= -cutDepth + 0.1 && distFromCenter <= outerRadius) {\n        vec2 uv;\n        uv.x = p.x * UV_SCALE_X + UV_OFFSET;\n        uv.y = p.y * UV_SCALE_Y + UV_OFFSET;\n        uv = clamp(uv, 0.0, 1.0);\n        \n        vec4 texCol = eyeTexture(uv, r_lightIntensity);\n        float darkness = 1.0 - (texCol.r * 0.299 + texCol.g * 0.587 + texCol.b * 0.114);\n        \n        float falloff = 1.0;\n        if (distFromCenter > innerRadius) {\n            falloff = 1.0 - smoothstep(innerRadius, outerRadius, distFromCenter);\n        }\n        \n        float displaceAmount = darkness * DISPLACE_AMOUNT * falloff;\n        d += displaceAmount;\n    }\n    \n    return d;\n}\n\nfloat sdLens(vec3 p, float r) {return abs(length(p) - r - 0.02) - 0.003; }\n\nvec3 getEyeNormal(vec3 p) {\n    float d = sdEye(p, 1.0);\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = d - vec3(\n        sdEye(p - e.xyy, 1.0),\n        sdEye(p - e.yxy, 1.0),\n        sdEye(p - e.yyx, 1.0)\n    );\n    \n    return normalize(n);\n}\n\nvec3 getLensNormal(vec3 p) {\n\n    return normalize(p); // Only works for a sphere centered at origin\n    // keep this in case we need it again\n    float d = sdLens(p, 1.0);\n    vec2 e = vec2(0.001, 0);\n    vec3 n = d - vec3(\n        sdLens(p - e.xyy, 1.0),\n        sdLens(p - e.yxy, 1.0),\n        sdLens(p - e.yyx, 1.0)\n    );\n    return normalize(n);\n    \n}\n\nfloat rayMarchEye(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdEye(p, 1.0);\n        dO += dS/4.;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat rayMarchLens(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdLens(p, 1.0);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 getTextureColor(vec3 p) {\n    if (p.z < 0.0) {\n        vec2 uv;\n        uv.x = p.x * UV_SCALE_X + UV_OFFSET;\n        uv.y = p.y * UV_SCALE_Y + UV_OFFSET;\n        uv = clamp(uv, 0.0, 1.0);\n        \n        return eyeTexture(uv, r_lightIntensity).rgb;\n    }\n    return vec3(1.0);\n}\n\n// Calculate focused light intensity for iris - like a torch beam at angle\nfloat calculateLensFocusedLight(vec3 irisPoint, vec3 lightPos) {\n    // Eye forward direction (where lens is pointing)\n    vec3 eyeForward = vec3(0.0, 0.0, -1.0);\n    \n    // Light direction from eye center\n    vec3 lightDir = normalize(lightPos);\n    \n    // Angle between eye forward and light\n    float lightAngle = acos(clamp(dot(eyeForward, lightDir), -1.0, 1.0));\n    \n    // Cut off light if angle is too large - with smooth transition\n    if (lightAngle > LENS_CUTOFF_ANGLE) {\n        return 0.0;\n    }\n    \n    // Smooth cutoff transition\n    float angleFade = 1.0 - smoothstep(LENS_CUTOFF_ANGLE * 0.8, LENS_CUTOFF_ANGLE, lightAngle);\n    \n    float normalizedAngle = lightAngle / LENS_CUTOFF_ANGLE;\n    \n    // Calculate where the focused light beam hits the iris\n    // The beam center moves opposite to light direction (projected onto iris plane)\n    vec2 beamCenter = -lightDir.xy * normalizedAngle * 0.5;\n    \n    // Distance from iris point to beam center\n    vec2 irisPos2D = irisPoint.xy;\n    vec2 toBeam = irisPos2D - beamCenter;\n    \n    float na2 = pow(normalizedAngle, 3.0);\n    // Beam gets more elongated and focused as angle increases\n    float stretch = 1.0 + normalizedAngle * 3.0; // Elongation factor\n    float beamWidth = 0.4 * (1.0 - na2 * 0.7); // Gets narrower with angle\n    \n    // Apply stretching along the light direction\n    vec2 lightDir2D = normalize(lightDir.xy + vec2(0.001)); // Avoid division by zero\n    vec2 perpDir = vec2(-lightDir2D.y, lightDir2D.x);\n    \n    // Transform to stretched coordinates\n    float alongLight = dot(toBeam, lightDir2D) / stretch;\n    float perpToLight = dot(toBeam, perpDir);\n    \n    float distToBeamAxis = sqrt(alongLight * alongLight + perpToLight * perpToLight);\n    \n    // Gaussian falloff for the focused beam\n    float beamIntensity = exp(-distToBeamAxis * distToBeamAxis / (beamWidth * beamWidth));\n    \n    // Increase intensity as angle increases (lens focusing effect)\n    float focusMultiplier = 1.0 + normalizedAngle * LENS_FOCUS_STRENGTH;\n    \n    // Smooth blend between uniform and focused lighting based on angle\n    // At angle 0: uniform lighting (intensity = 1.0)\n    // At higher angles: focused beam lighting\n    float focusAmount = smoothstep(0.0, 0.3, normalizedAngle);\n    float uniformLighting = 1.0 + normalizedAngle * LENS_FOCUS_STRENGTH * 0.2;\n    float focusedLighting = beamIntensity * focusMultiplier;\n    \n    float finalIntensity = mix(uniformLighting, focusedLighting, focusAmount);\n    \n    return finalIntensity * angleFade * BASE_BRIGHTNESS;\n}\n\nvec3 getEyeLight(vec3 p, vec3 rd) {\n    vec3 lightInEyeSpace = g_rotation * LIGHTP;\n    vec3 l = normalize(lightInEyeSpace - p);\n    vec3 n = getEyeNormal(p);\n    vec3 v = -rd;\n    vec3 r = reflect(-l, n);\n    vec3 albedo = getTextureColor(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    // Check if we're on the iris\n    float cutDepth = cos(FLATTEN_ANGLE);\n    float outerRadius = sin(FLATTEN_ANGLE);\n    bool isIris = p.z <= -cutDepth + 0.1 && length(p.xy) <= outerRadius;\n    \n    // Apply lens focusing effect only to iris\n    if (isIris) {\n        float lensFocus = calculateLensFocusedLight(p, lightInEyeSpace);\n        dif *= lensFocus;\n    }\n    \n    float spec = pow(max(dot(r, v), 0.0), 16.0);\n    vec3 ambient = albedo * 0.15;\n    vec3 diffuse = albedo * dif * 0.5;\n    vec3 specular = vec3(1.0) * spec * albedo.g * albedo.r *albedo.b;\n    \n    return ambient + diffuse + specular;\n}\n\n\nvec3 getLensLight(vec3 p, vec3 rd) {\n    vec3 lightInEyeSpace = g_rotation * LIGHTP;\n\n    vec3 l = normalize(lightInEyeSpace - p);\n    vec3 n = getLensNormal(p);\n    vec3 v = -rd;\n    vec3 r = reflect(-l, n);\n    float spec = pow(max(dot(r, v), 0.0), 32.0);\n    float fresnel = pow(1.0 - abs(dot(v, n)), 1.0);\n    vec3 lensColor = vec3(0.95, 0.97, 1.0); \n    vec3 baseGlass = lensColor * 0.2; \n    vec3 specular = vec3(1.) * spec * 50.0; \n    vec3 fresnelColor = lensColor * fresnel *0.2;\n    \n    return baseGlass + specular + fresnelColor;\n}\n\n/* Refraction using Snell's law - not needed because refract()\nvec3 refract_ray(vec3 incident, vec3 normal, float eta) {\n    float cosI = -dot(normal, incident);\n    float sinT2 = eta * eta * (1.0 - cosI * cosI);\n    if (sinT2 > 1.0) return vec3(0.0); // Total internal reflection\n    float cosT = sqrt(1.0 - sinT2);\n    return eta * incident + (eta * cosI - cosT) * normal;\n}\n*/\n\nvec4 renderWithRefraction(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.04, 0.04, 0.05);\n    float nearestD = MAX_DIST;\n    // First, check if we hit the lens\n    float lensD = rayMarchLens(ro, rd);\n    nearestD = min(nearestD, lensD);\n    if(lensD < MAX_DIST) {\n        vec3 lensP = ro + rd * lensD;\n        vec3 lensN = getLensNormal(lensP);\n        \n        // Calculate refraction\n        float eta = 1.0 / REFRACT;\n        vec3 refractedRay = refract(rd, lensN, eta);\n        \n        if(length(refractedRay) > 0.0) {\n            // Continue raymarching with refracted ray\n            vec3 newRo = lensP + refractedRay * 0.01; // Small offset to avoid self-intersection\n            // Check if refracted ray hits the eye\n            float eyeD = rayMarchEye(newRo, refractedRay);\n            \n            if(eyeD < MAX_DIST) {\n                vec3 eyeP = newRo + refractedRay * eyeD;\n                vec3 eyeCol = getEyeLight(eyeP, refractedRay);\n                \n                // Apply slight chromatic aberration based on refraction angle :)\n                float refractionStrength = length(rd - refractedRay);\n                eyeCol = mix(eyeCol, eyeCol.gbr, refractionStrength * 0.1);\n                \n                col = eyeCol;\n            }\n        }\n        \n        // Add lens surface effects\n        vec3 lensCol = getLensLight(lensP, rd);\n        float fresnel = pow(1.0 - abs(dot(-rd, lensN)), 2.);\n        col = mix(col, lensCol, fresnel * 0.2); // Blend lens surface\n        \n    } else {\n        // No lens hit, render eye directly\n        float eyeD = rayMarchEye(ro, rd);\n        nearestD = min(nearestD, eyeD);\n        if(eyeD < MAX_DIST) {\n            vec3 eyeP = ro + rd * eyeD;\n            col = getEyeLight(eyeP, rd);\n        }\n    }\n    \n    return vec4(col, nearestD);\n}\n\n\nvoid mainMS(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = vec2(0.5);\n    \n    vec2 pa = vec2 (sin (floor( iTime ) * 57.678)/10., sin (floor( iTime ) * 97.678)/10.);\n    vec2 pb = vec2 (sin (floor( iTime+1. ) * 57.678)/10., sin (floor( iTime+1. ) * 97.678)/10.);\n    \n    vec2 pm = mix (pa, pb, pow( (  max(0.,fract(iTime)-0.9)  *10.), 4.));\n    \n    m+= pm;\n    \n    if(iMouse.z>0.001){m = iMouse.xy / iResolution.xy;} \n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float angleY = (m.x - 0.5) * -6.28;\n    float angleX = (m.y - 0.5) * 3.14;\n    \n    mat3 rotY = mat3(\n        cos(angleY), 0, sin(angleY),\n        0, 1, 0,\n        -sin(angleY), 0, cos(angleY)\n    );\n    \n    mat3 rotX = mat3(\n        1, 0, 0,\n        0, cos(angleX), -sin(angleX),\n        0, sin(angleX), cos(angleX)\n    );\n    \n    g_rotation = rotY * rotX;\n    \n    g_lightIntensity = calculateIrisLightIntensity(g_rotation);\n    \n    ro = g_rotation * ro;\n    rd = g_rotation * rd;\n    \n    vec4 colPND = renderWithRefraction(ro, rd);\n    vec3 col = colPND.rgb;\n\n    float nearestD = colPND.a;\n    if(nearestD < MAX_DIST) {\n        col = mix(col, vec3(0.1, 0.1, 0.15), 1.0 - exp(-0.0005 * nearestD * nearestD));\n    }\n    \n   col = pow(col, vec3(0.4545));\n    \n    \n    float getli = texture(iChannel1, vec2(0), 0.).r;\n    r_lightIntensity = (g_lightIntensity+getli+getli)/3.;\n    \n    if(fragCoord.x<2. && fragCoord.y<2.) {col.r = r_lightIntensity;}\n    fragColor = (texture(iChannel1, fragCoord/iResolution.xy, 0.)*MBLUR + vec4(col, 1.0))/(1.+MBLUR);\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = AA, k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainMS(c, u); \n    for (k = s; k-- > .5; ) { \n        mainMS(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a=1.;\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tcfczf",
    "date": "1755882458",
    "viewed": 106,
    "name": "Buffer feedback real time",
    "description": "I finally got this working in real time.\nAll it does is draw one line then draws its own buffer twice.\nCan be improved loads.\nClick and drag.",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "line",
     "tree",
     "recursive",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Another feedback fractal\" by Cotterzz. https://shadertoy.com/view/3cVGzm\n// 2025-08-22 16:54:07\n\n// (Also inspired by: \"Dancy Tree Doodle  by wyatt. \"https://www.shadertoy.com/view/wslGz7 )\n\n// Fork of \"Koch with hexagons\" by Cotterzz. https://shadertoy.com/view/tfd3Ds\n// 2025-05-22 15:34:19\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 18:21:33\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float capsuleSDF(in vec2 P,in vec2 B,in vec2 E,in float R)\n{\n    vec2 BP = P - B;\n    vec2 BE = E - B;\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n    vec2 K = BP - BE * t;\n    return sqrt(dot(K, K)) - R;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(.9+sin(iTime/3.)/8., .4+cos(iTime/2.5)/9.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .01);\n    vec3 col = vec3(mix(0.,1., csdf*500.));\n    float angd = .2;\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float ancl = ano-angd+and;\n    float ancr = ano-angd-and;\n    float len = length(rv);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*1.2;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*1.2;\n    col = min(col, texture(iChannel0, tcl, 0.).rgb);\n    col = min(col, texture(iChannel0, tcr, 0.).rgb);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(1.0);}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cXcRs",
    "date": "1755924850",
    "viewed": 113,
    "name": "Buffer feedback weirdness",
    "description": "This went in an odd direction. Two different patterns.\nAll this from drawing a line and copying the buffer. I think the translation angle of the buffer is doing something here.\nClick and drag.",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "line",
     "tree",
     "recursive",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Buffer feedback real time\" by Cotterzz. https://shadertoy.com/view/tcfczf\n// 2025-08-23 04:43:55\n\n// Fork of \"Another feedback fractal\" by Cotterzz. https://shadertoy.com/view/3cVGzm\n// 2025-08-22 16:54:07\n\n// (Also inspired by: \"Dancy Tree Doodle  by wyatt. \"https://www.shadertoy.com/view/wslGz7 )\n\n// Fork of \"Koch with hexagons\" by Cotterzz. https://shadertoy.com/view/tfd3Ds\n// 2025-05-22 15:34:19\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 18:21:33\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float co = distance(uv, vec2(0.5));\n    vec3 colA = texture(iChannel0, fragCoord/iResolution.xy, 0.).rgb;\n    vec3 colB = texture(iChannel1, fragCoord/iResolution.xy, 0.).rgb;\n    colA = hsl2rgb(vec3((colA.r/3.)-co, 1., colA.r/3.));\n    colB = hsl2rgb(vec3(colB.r/2.5, 1., colB.r/2.));\n    fragColor = vec4(colA+colB, 1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime/1.1)/8.), .25+cos(iTime/1.3)/20.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);\n    pb.x = ar/2.+0.15-(pb.x-ar/2.);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .01);\n    vec3 col = vec3(mix(1.,0., csdf*50.));\n\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float ang = abs(uv.x-.5)*3.;\n    \n    float ancl = ano-ang;\n    float ancr = ano+ang;\n    float len = length(rv);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*1.3;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*1.3;\n    col = max(col, texture(iChannel0, tcl, 0.).rgb);\n    col = max(col, texture(iChannel0, tcr, 0.).rgb);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nfloat capsuleSDF(in vec2 P,in vec2 B,in vec2 E,in float R)\n{\n    vec2 BP = P - B;\n    vec2 BE = E - B;\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n    vec2 K = BP - BE * t;\n    return sqrt(dot(K, K)) - R;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime/1.3)/-8.), .25+cos(iTime/2.9)/20.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .01);\n    vec3 col = vec3(mix(1.,0., csdf*150.));\n\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float ang = pow(abs(uv.x-.5),.4);\n    float ancl = ano-ang;\n    float ancr = ano+ang;\n    float len = length(rv);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*1.3;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*1.3;\n    col = max(col, texture(iChannel0, tcl, 0.).rgb);\n    col = max(col, texture(iChannel0, tcr, 0.).rgb);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfsyWB",
    "date": "1756029395",
    "viewed": 85,
    "name": "Buffer feedback swap",
    "description": "What happens if the two trees copy each others buffers.. what then?\nExperiment commenting/uncommenting lines 27-30 in buffers A and B\nClick and drag.",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "line",
     "tree",
     "recursive",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Buffer feedback weirdness\" by Cotterzz. https://shadertoy.com/view/3cXcRs\n// 2025-08-24 09:49:35\n\n// Fork of \"Buffer feedback real time\" by Cotterzz. https://shadertoy.com/view/tcfczf\n// 2025-08-23 04:43:55\n\n// Fork of \"Another feedback fractal\" by Cotterzz. https://shadertoy.com/view/3cVGzm\n// 2025-08-22 16:54:07\n\n// (Also inspired by: \"Dancy Tree Doodle  by wyatt. \"https://www.shadertoy.com/view/wslGz7 )\n\n// Fork of \"Koch with hexagons\" by Cotterzz. https://shadertoy.com/view/tfd3Ds\n// 2025-05-22 15:34:19\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 18:21:33\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float co = distance(uv, vec2(0.5));\n    vec3 colA = texture(iChannel0, fragCoord/iResolution.xy, 0.).rgb;\n    vec3 colB = texture(iChannel1, fragCoord/iResolution.xy, 0.).rgb;\n    colA = hsl2rgb(vec3((colA.r/3.)-co, 1., colA.r/3.));\n    colB = hsl2rgb(vec3(colB.r/2.5, 1., colB.r/2.));\n    fragColor = vec4(colA+colB, 1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime/1.1)/8.), .25+cos(iTime/1.3)/20.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);\n    pb.x = ar/2.+0.15-(pb.x-ar/2.);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .01);\n    vec3 col = vec3(mix(1.,0., csdf*50.));\n\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float ang = abs(uv.x-.5)*3.;\n    \n    float ancl = ano-ang;\n    float ancr = ano+ang;\n    float len = length(rv);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*1.2;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*1.2;\n    //col = max(col, texture(iChannel1, tcl, 0.).rgb);\n   col = max(col, texture(iChannel0, tcr, 0.).rgb);\n  //col = max(col, texture(iChannel0, tcl, 0.).rgb);\n   col = max(col, texture(iChannel1, tcr, 0.).rgb);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nfloat capsuleSDF(in vec2 P,in vec2 B,in vec2 E,in float R)\n{\n    vec2 BP = P - B;\n    vec2 BE = E - B;\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n    vec2 K = BP - BE * t;\n    return sqrt(dot(K, K)) - R;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime/1.3)/-8.), .25+cos(iTime/2.9)/20.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .01);\n    vec3 col = vec3(mix(1.,0., csdf*150.));\n\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float ang = pow(abs(uv.x-.5),.4);\n    float ancl = ano-ang;\n    float ancr = ano+ang;\n    float len = length(rv);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*1.2;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*1.2;\n  col = max(col, texture(iChannel1, tcl, 0.).rgb);\n    col = max(col, texture(iChannel0, tcr, 0.).rgb);\n   // col = max(col, texture(iChannel0, tcl, 0.).rgb);\n   // col = max(col, texture(iChannel1, tcr, 0.).rgb);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cXcW2",
    "date": "1756048246",
    "viewed": 162,
    "name": "Buffer feedback trees",
    "description": "More experimenting with buffer feedback trees.\nClick and drag.",
    "likes": 16,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "line",
     "tree",
     "recursive",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Buffer feedback swap\" by Cotterzz. https://shadertoy.com/view/wfsyWB\n// 2025-08-24 15:04:05\n\n// Fork of \"Buffer feedback weirdness\" by Cotterzz. https://shadertoy.com/view/3cXcRs\n// 2025-08-24 09:49:35\n\n// Fork of \"Buffer feedback real time\" by Cotterzz. https://shadertoy.com/view/tcfczf\n// 2025-08-23 04:43:55\n\n// Fork of \"Another feedback fractal\" by Cotterzz. https://shadertoy.com/view/3cVGzm\n// 2025-08-22 16:54:07\n\n// (Also inspired by: \"Dancy Tree Doodle  by wyatt. \"https://www.shadertoy.com/view/wslGz7 )\n\n// Fork of \"Koch with hexagons\" by Cotterzz. https://shadertoy.com/view/tfd3Ds\n// 2025-05-22 15:34:19\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 18:21:33\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float co = distance(uv, vec2(0.5));\n    vec3 colA = texture(iChannel0, fragCoord/iResolution.xy, 0.).rgb;\n    vec3 colB = texture(iChannel1, fragCoord/iResolution.xy, 0.).rgb;\n    colA = hsl2rgb(vec3((colA.r/2.5)-co, 1., colA.r/2.));\n    colB = hsl2rgb(vec3((colB.r/2.5)+co, 1., colB.r/2.));\n    fragColor = vec4((colA+colB)*2.5, 1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime*1.15)/-5.), .18+cos(iTime*2.3)/-21.);\n    pb.y += .03 + pow(abs(pb.x-(ar*.5)),2.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);\n    pb.x = ar/2. - (pb.x-ar/2.);\n    }\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .001);\n    vec3 col = vec3(mix(1.,0., csdf*200.));\n\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float anga = abs(uv.x-.5)*3.;\n    float ang = pow(abs(uv.x-.5),.4);\n    \n    float ancl = ano-ang;\n    float ancr = ano+anga;\n    float len = length(rv);\n    float tlen = 1. + length(pd);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*tlen;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*tlen;\n    col = max(col, texture(iChannel1, tcl, 0.).rgb*fade);\n   col = max(col, texture(iChannel0, tcr, 0.).rgb*fade);\n  col = max(col, texture(iChannel0, tcl, 0.).rgb*fade);\n   col = max(col, texture(iChannel1, tcr, 0.).rgb*fade);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nfloat fade  = 0.9;\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nfloat capsuleSDF(in vec2 P,in vec2 B,in vec2 E,in float R)\n{\n    vec2 BP = P - B;\n    vec2 BE = E - B;\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n    vec2 K = BP - BE * t;\n    return sqrt(dot(K, K)) - R;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime*1.15)/5.), .18+cos(iTime*2.3)/-21.);\n    pb.y += .03 + pow(abs(pb.x-(ar*.5)),2.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .001);\n    vec3 col = vec3(mix(1.,0., csdf*200.));\n    \n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float anga = abs(uv.x-.5)*3.;\n    float ang = pow(abs(uv.x-.5),.4);\n    \n\n    float ancr = ano-anga;\n    float ancl = ano+ang;\n    float len = length(rv);\n    float tlen = 1. + length(pd);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*tlen;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*tlen;\n  col = max(col, texture(iChannel1, tcl, 0.).rgb*fade);\n    col = max(col, texture(iChannel0, tcr, 0.).rgb*fade);\n    col = max(col, texture(iChannel0, tcl, 0.).rgb*fade);\n    col = max(col, texture(iChannel1, tcr, 0.).rgb*fade);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wc2cWK",
    "date": "1757103835",
    "viewed": 112,
    "name": "Wooden Block 3D Texture",
    "description": "Texture is fixed in space to see different grain cuts\nThere is a lot that could be improved/added to this, eg combining it with [url=https://www.shadertoy.com/view/tcScWy]this[/url] approach.\n..but it's a nice starting point.",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "wood",
     "grain",
     "3dtexture"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nmat3 rotation;\n\nmat3 rotateX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(1,0,0, 0,c,-s, 0,s,c);\n}\n\nmat3 rotateY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c,0,s, 0,1,0, -s,0,c);\n}\n\nmat3 rotateZ(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c,-s,0, s,c,0, 0,0,1);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdDodecahedron(vec3 p, float r) {\n    const vec3 n = normalize(vec3(1.0, 1.618, 0.0)); // Golden ratio\n    p = abs(p);\n    float a = dot(p, n.xyz);\n    float b = dot(p, n.zxy);\n    float c = dot(p, n.yzx);\n    return (max(max(a, b), c) - r) * 0.57735; \n}\n\nfloat getDist(vec3 p) {\n    vec2 mouse = (iMouse.xy / iResolution.xy - 0.5) * 2.0;\n    float rotY = mouse.x * 3.14159;\n    float rotX = mouse.y * 3.14159;\n    rotation = rotateY(rotY) * rotateX(rotX);\n    \n    // Apply rotation to the entire scene first\n    vec3 rotatedP = rotation * p;\n\n    // Center box (2x2x4, so half-extents are 1x1x2)\n    float box = sdBox(rotatedP, vec3(1.0, 1.0, 2.0));\n    \n    // Center box (2x2x4, so half-extents are 1x1x2)\n    float board = sdBox(rotatedP - vec3(0., 2., 0.0), vec3(5.0, .3, 2.));\n    \n    // Left sphere (radius 1, positioned at x = -4.5)\n    float sphere = sdSphere(rotatedP - vec3(-3., 0.0, 0.0), 1.3);\n    \n    // Right dodecahedron (radius 1, positioned at x = 4.5)\n    float dodeca = sdDodecahedron(rotatedP - vec3(3., 0.0, 0.0), 1.0);\n    \n    // Return minimum distance (union of all objects)\n    return min(min(min(box, board), sphere), dodeca);\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        \n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nvec3 getWoodTexture(vec3 worldPos, out float darkness) {\n\n    // UNCOMMENT TO FIX TEXTURE TO OBJECTS\n    // worldPos = rotation*worldPos; \n\n    float distFromYAxis = length(worldPos.xz);\n    float angleFromAxis = atan(worldPos.z, worldPos.x);\n    \n    distFromYAxis  += (hash(vec2(floor(angleFromAxis*1200.), 0.)) + hash(vec2(0.,floor(angleFromAxis*700.))))*(0.1/max(1.,distFromYAxis*distFromYAxis));\n    \n    for(int i = 0; i < 10; i++) {\n        // Generate pseudo-random knot parameters\n        vec2 seed = vec2(float(i) * 12.345, float(i) * 67.89);\n        float knotAngle = hash(seed) * 6.28318;\n        float knotSize = 0.25 + hash(seed*2.) * 0.3;\n        float knotDist = 2.0 + hash(seed + vec2(1.5, 0.0)) * 0.5; \n        float knotY = -1.5 + hash(seed + vec2(1.0, 0.0)) * 2.0; \n        \n    \n        vec2 knotCenter = vec2(cos(knotAngle) * knotDist, sin(knotAngle) * knotDist);\n        float distFromKnot = length(worldPos.xz - knotCenter);\n        \n        //float yFalloff = exp(-abs(worldPos.y - knotY) * 0.8);\n        \n        // Modify the main distance field with knot influence\n        if(distFromKnot < knotSize ) {\n            // Create a \"well\" around the knot - negative values make it a new grain center\n            float knotInfluence = (knotSize - distFromKnot) / knotSize; // 1.0 at center, 0.0 at edge\n            //knotInfluence *= yFalloff;\n            \n            // Subtract from distance field to create negative regions (knot centers)\n            distFromYAxis -= (knotInfluence * knotInfluence *3.5);\n        }\n    }\n    \n    // Add some noise for more realistic wood grain\n    float noise = sin(worldPos.x * 4.0) * 0.05 + sin(worldPos.z * 4.0) * 0.05;\n    distFromYAxis += noise*distFromYAxis*0.9;\n    \n    \n    \n    // Now calculate ALL grain from this single modified distance field\n    // Main rings\n    float rings = fract(distFromYAxis * distFromYAxis *1.5);\n    \n    \n    float mainGrain = smoothstep(0.0, 0.3, rings) - smoothstep(0.7, 1.0, rings);\n     \n    \n    \n    // Sub-grain - faint lines between main lines\n    float subRings = fract(distFromYAxis * 30.0); // Higher frequency\n    float subGrain = smoothstep(0.1*mainGrain, 0.2*mainGrain, subRings) - smoothstep(0.7*mainGrain, 0.8*mainGrain, subRings);\n    subGrain *= 0.4;\n    \n    float combinedGrain = mainGrain + subGrain;\n        // Output darkness factor for specular modulation\n    darkness = 1.0 - (combinedGrain * 0.5 + 0.5); // Keep in 0-1 range for lighting\n\n    vec3 darkWood = vec3(0.65, 0.45, 0.15);\n    vec3 lightWood = vec3(0.85, 0.65, 0.35);\n    vec3 knotWood = vec3(0.4, 0.3, 0.1)+(distFromYAxis/10.); \n    \n    vec3 woodColor;\n    if(distFromYAxis < 0.0) {\n        woodColor = mix(knotWood, darkWood, combinedGrain * 0.5);\n        darkness +=0.5;\n    } else {\n        // Normal grain regions\n        woodColor = mix(darkWood, lightWood, combinedGrain);\n        \n    }\n    \n\n    \n    return woodColor;\n}\n\nvec3 getLight(vec3 p, vec3 normal, vec3 viewDir, vec3 albedo, float darkness) {\n    vec3 lightPos = vec3(5.0, 8.0, 10.0);\n    vec3 lightDir = normalize(lightPos - p);\n    \n    vec3 ambient = albedo * 0.2;\n\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = (albedo * diff) *0.8;\n    \n    // Variable specular - stronger where texture is darker\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 8.0);\n    float specularStrength = 0.1 + darkness * 0.7;\n    vec3 specular = vec3(specularStrength) * spec;\n    \n\n    float shadow = 1.0;\n    float shadowDist = rayMarch(p + normal * SURF_DIST * 2.0, lightDir);\n    if(shadowDist < length(lightPos - p)) {\n        shadow = 0.3;\n    }\n    \n    return ambient + (diffuse + specular) * shadow;\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0, 0, 10); \n    vec3 rd = normalize(vec3(uv, -1)); \n    float d = rayMarch(ro, rd);\n    vec3 col = vec3(0.1, 0.1, 0.2); \n    \n    if(d < MAX_DIST) {\n\n        vec3 p = ro + rd * d;\n        vec3 normal = getNormal(p);\n        float darkness;\n        vec3 albedo = getWoodTexture(p, darkness);\n        vec3 viewDir = normalize(-rd);\n        col = getLight(p, normal, viewDir, albedo, darkness);\n    }\n    \n    col = pow(col, vec2(0.4545).xxx);\n    fragColor = vec4(col, 1.0);\n}\n\n// multisampling, from \"Weyl Supersample Any Shader\" by spalmer https://www.shadertoy.com/view/WXjXRt\n// (forked from from \"postprocess existing shaders\" by FabriceNeyret2 https://www.shadertoy.com/view/NdyfRz \nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 4., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n} ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcsBWB",
    "date": "1758020116",
    "viewed": 381,
    "name": "Ortho Spiral Random shaders",
    "description": "I saw this stereo spiral shader posted and thought it would work well with my random shaders.",
    "likes": 29,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "spiral",
     "random",
     "generative",
     "stereo",
     "code",
     "geometry",
     "moebius",
     "ortho"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"I heard yall like Ortho spiral?\" by frisk256. https://shadertoy.com/view/3fffRs\n// 2025-09-16 10:45:13\n// Fork of \"Angry geometry god\" by Cotterzz. https://shadertoy.com/view/tftGD4\n// 2025-09-16 10:44:50\n\n#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n\nint PALETTE = 9;\n\nfloat rand(float n){return fract(cos(n*89.42)*343.42);}\nvec2 shake() {\n    return vec2(\n        sin(iTime*1e2),\n        cos(iTime*2e2)\n    ) * max(0.,1.2-iTime)/20.;\n}\nfloat nz(vec2 nv){\n    float o = 0.;\n    for (float i = .2; i < 2.;\n    o += abs(dot(sin(nv * i * 64.), vec2(.05))) / i,\n    i *= 1.4142);\n    return mix(o,  distance(vec2(0), nv), 0.5 + (sin(iTime)/2.));\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?nz(vec2(a,b)):s>0.3?b/(a==0.?0.01:a):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\n\nvec3 gpc(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = contrast(gpc(num),1.7);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n        return col;\n    } else {\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        return col;\n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., dc.r);\n    dc.g = min(1., dc.g);\n    dc.b = min(1., dc.b);\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\nvec3 mainAgg(vec2 uv, float seed){\n   // uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    uv += shake();\n    float zoom = 4. + (3.*(sin(iTime/1.5)+1.));\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    float o = nz(guv);\n   // float seed = floor(iTime/1.0);\n    PALETTE = int(floor(float(8)*rand(seed+66.)));\n    const int v = 24;\n    vec3 col = vec3(0);\n    float cn = 1.;\n    float values[v];\n    values[0] = 1.0;\n    values[1] = 10.0;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = 2.;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = 3.14159;\n   values[21] = atan(x, y)*4.;\n   values[22] = o;\n   values[23] = distance(vec2(x,y), vec2(0))*sin(atan(x, y));\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 30; int mini = 5;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n        }\n        if(abs(sub)<1.){seed+=100.;PALETTE = int(floor(float(8)*rand(seed+66.)));}\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            col += addColor(total, seed+float(i), values[21]);\n            cn+=1.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    return col;\n}\n\n\nvoid mainImage0(out vec4 c, vec2 p) {\n    vec2 r = iResolution.xy;\n    vec2 h = (p / r * 2. - 1.) * sqrt(r / r.yx);\n    vec3 g = vec3(1, h.yx) / (dot(h, h) + 1.) + vec3(-.5, 0, .5);\n    h = g.xy / dot(g, g);\n    h = vec2(atan(h.x, h.y), log(length(h))) / 6.28;\n    h += iTime * .1;\n    h *= mat2(8, 5, -5, 8);\n    \n    // Get the cell coordinates (which cell we're in)\n    vec2 cellID = floor(h);\n    \n    //--------thx to chronos for this seam fix.------\n    cellID = mod(cellID, vec2(8,5));\n    \n    // Get local UV within the cell (0 to 1)\n    vec2 cellUV = fract(h);\n    \n    // Create a unique seed from cell coordinates\n    // Simple hash - you can make this more sophisticated if needed\n    float seed = cellID.x + cellID.y * 10.0;\n    // Or better hash:\n    // float seed = dot(cellID, vec2(127.1, 311.7));\n    // seed = fract(sin(seed) * 43758.5453);\n    \n    // Now call your pattern function:\n    // vec3 pattern = yourPatternFunction(cellUV, seed);\n    \n    // Example visualization showing the UVs and cell IDs:\n    vec3 col = mainAgg(cellUV, seed);\n    \n    // Or keep the original square pattern:\n    // c = vec4(max(abs(cellUV.x - .5), abs(cellUV.y - .5)) * 2.);\n    \n    c = vec4(col, 1.0)-pow(vec4(max(abs(cellUV.x - .5), abs(cellUV.y - .5)) * 2.),vec4(6.))/2.;\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 3., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cBfDw",
    "date": "1758650315",
    "viewed": 373,
    "name": "Pumpkin Carver V1",
    "description": "Carve your own pumpkin, see code for instructions and info.\nThanks to Diatribes for the Sky and TheTurk for the 3D noise",
    "likes": 45,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarch",
     "sdf",
     "halloween",
     "pumpkin",
     "october",
     "jackolantern"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// ABOUT\n// I wanted to make an interactive pumpkin carving shader for halloween.\n// This is my first attempt at a basic prototype, and it went a lot further than originally planned.\n// Using a drawn texture to postively displace a sphere SDF and then subtracting that from the main pumpkin.\n// The texture also provides an easy route to volumetric light.\n// --\n// It was a lot of fun to make and as a prototype/proof of concept it's a success that turned out better than expected\n// However - it has plenty of issues and will benefit from a complete rebuild.\n// Performance, compile time, messy code, untidy carve subtraction and the overall scene rendering could all be improved a lot.\n// --\n// I'm now working on the next version.\n\n// LICENSE\n// Permission required for use outside shadertoy.\n\n\n// INSTRUCTIONS\n// Click and drag on pumpkin to carve.\n// Select mirror mode (second button down on the left) to draw symmetrical patterns.\n// Inverse mode to draw/fill pumpkin back in.\n// Inverse mirror for both.\n// Top button to set back to regualr carving.\n// Brush size slider on the left.\n// FPS indicator top right, blue/green is good, red is bad, adjust quality settings.\n// Quality settings on the bottom right, Antialiasing, volumetric light, smoke and skies.\n// up is higher quality but more GPU intensive.\n// Watch the FPS indicator, you really need it in the green (55+ frames per second) if possible.\n// Right-click and save-as to save image, hit rewind to reset.\n\n\n// ---- Fast Improved Perlin Noise by TheTurk: https://www.shadertoy.com/view/slB3z3\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;uint h = seed;uint k = x;k *= m;k ^= k >> 24;\n    k *= m;h *= m;h ^= k;h ^= h >> 13;h *= m;h ^= h >> 15;return h;\n}\n\nuint hash(uvec3 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint h = seed;uint k = x.x; \n    k *= m;k ^= k >> 24;k *= m;h *= m;h ^= k;\n    k = x.y;k *= m;k ^= k >> 24;k *= m;h *= m;h ^= k;\n    k = x.z;k *= m;k ^= k >> 24;k *= m;h *= m;h ^= k;\n    h ^= h >> 13;h *= m;h ^= h >> 15;\n    return h;\n}\n\nvec3 gradientDirection(uint hash) {\n    vec3 r = vec3(0,1,-1);switch (int(hash) & 15) {\n    case 0:return r.yyx;case 1:return r.zxy;\n    case 2:return r.yzx;case 3:return r.zzx;\n    case 4:return r.yyx;case 5:return r.zxy;\n    case 6:return r.yxz;case 7:return r.zxz;\n    case 8:return r.xyy;case 9:return r.xzy;\n    case 10:return r.xzz;case 11:return r.xyz;\n    case 12:return r.yyx;case 13:return r.zxy;\n    case 14:return r.xzy;case 15:return r.xzz;\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {\n    return mix(mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y), t.z);\n}\n\nvec3 fade(vec3 t) {return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);}\n\nfloat perlinNoise(vec3 position, uint seed) {\n    vec3 floorPosition = floor(position);\n    vec3 fractPosition = position - floorPosition;\n    uvec3 cellCoordinates = uvec3(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));\n    float value5 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));\n    float value6 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));\n    float value7 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));\n    float value8 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));\n    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));\n}\n\nfloat perlinNoise(vec3 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;float amplitude = 1.0;float currentFrequency = float(frequency);uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\n\n// --- Main Shader Code by Cotterzz\n\nint AA = 0;\nint VOLUMETRIC = 2;\nint SMOKE = 2;\nint SKIES = 2;\n\n// store rd and ro for volumetric without AA\nvec3 sro;\nvec3 srd;\n\n// UI Helper functions\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat drawSquiggly(vec2 p, bool mirrored) {\n    if (mirrored) p.x = -p.x;\n    \n    // Smaller squiggly line\n    float y = sin(p.x * 190.0) * 0.007;\n    float line = abs(p.y - y) - 0.002;\n    return line;\n}\n\n// Draw mode button - returns color mixing factor\nvec3 drawModeButton(vec2 uv, vec2 center, bool invers, bool mirrored, bool selected) {\n    // Button color scheme\n    vec3 regularColor = vec3(0.5, 0.2, 0.0);\n    vec3 inverseColor = vec3(1.0, 1.0, 0.5);\n    \n    vec2 p = uv - center;\n    float buttonSize = 0.048; // 60% of 0.08\n    \n    // Main circle\n    float mainCircle = sdCircle(p, buttonSize);\n    \n    // Selection highlight\n    float highlight = selected ? sdCircle(p, buttonSize + 0.006) : 1.0; // 60% of 0.01\n    \n    // Return background if outside button\n    if (mainCircle > 0.0 && (!selected || highlight > 0.0)) {\n        return vec3(-1.0); // Signal: no button here\n    }\n    \n    // Selection highlight (blue border)\n    if (selected && highlight < 0.0 && mainCircle > 0.0) {\n        return vec3(0.3, 0.5, 1.0); // Blue highlight\n    }\n    \n    // Button interior\n    if (mainCircle < 0.0) {\n        \n        if (mirrored) {\n            // Mirror mode: show two sets of icons with center line\n            \n            // Thinner center mirror line\n            float centerLine = abs(p.x) - 0.0006; // 60% of 0.001\n            if (centerLine < 0.0) {\n                return invers ? regularColor : inverseColor; // Mirror line color\n            }\n            \n            // Left side icons\n            vec2 leftOffset = vec2(-0.021, 0.024); // 60% scaling\n            float leftSmallCircle = sdCircle(p - leftOffset, 0.007); // 60% of 0.012\n            \n            // Left squiggly line - only on left side\n            vec2 leftSquigglyPos = p - vec2(-0.021, 0); // 60% of -0.035\n            float leftSquiggly = drawSquiggly(leftSquigglyPos.yx, false);\n            // Clip squiggly to left side only\n            if (leftSquigglyPos.y > 0.021) leftSquiggly = 1.0; // 60% of 0.035\n            \n            // Right side icons (mirrored)\n            vec2 rightOffset = vec2(0.021, 0.024); // 60% scaling\n            float rightSmallCircle = sdCircle(p - rightOffset, 0.007); // 60% of 0.012\n            \n            // Right squiggly line - only on right side\n            vec2 rightSquigglyPos = p - vec2(0.021, 0); // 60% of 0.035\n            float rightSquiggly = drawSquiggly(rightSquigglyPos.yx, true);\n            // Clip squiggly to right side only\n            if (rightSquigglyPos.y > 0.021) rightSquiggly = 1.0; // 60% of 0.035\n            \n            // Check for any icon element\n            if (leftSmallCircle < 0.0 || rightSmallCircle < 0.0 || \n                leftSquiggly < 0.0 || rightSquiggly < 0.0) {\n                return invers ? regularColor : inverseColor; // Icon color\n            }\n            \n        } else {\n            // Regular mode: single set of icons\n            \n            // Small circle\n            vec2 smallOffset = vec2(0.018, 0.012); // 60% scaling\n            float smallCircle = sdCircle(p - smallOffset, 0.009); // 60% of 0.015\n            \n            // Squiggly line\n            vec2 squigglyPos = p - vec2(0.0, 0.012); // 60% of 0.02\n            float squiggly = drawSquiggly(squigglyPos, false);\n            if (squigglyPos.x > 0.021) squiggly = 1.0; // 60% of 0.035\n            // Check for icon elements\n            if (smallCircle < 0.0 || squiggly < 0.0) {\n                return invers ? regularColor : inverseColor; // Icon color\n            }\n        }\n        \n        // Main button background\n        return invers ? inverseColor : regularColor;\n    }\n    \n    return vec3(-1.0); // No button\n}\n\n// Draw quality slider - returns color\nvec3 drawQualitySlider(vec2 uv, vec2 center, float value, bool selected) {\n    vec2 p = uv - center;\n    \n    // Slider track (vertical)\n    float trackWidth = 0.008;\n    float trackHeight = 0.08;\n    float track = max(abs(p.x) - trackWidth, abs(p.y) - trackHeight);\n    \n    // Slider button (square, positioned based on value 0-4)\n    float buttonY = (value / 4.0 - 0.5) * trackHeight * 1.8;\n    vec2 buttonPos = vec2(0.0, buttonY);\n    float buttonSize = 0.012;\n    float button = max(abs(p.x - buttonPos.x) - buttonSize, abs(p.y - buttonPos.y) - buttonSize);\n    \n    if (track < 0.0 && button > 0.0) {\n        return vec3(0.3, 0.3, 0.3); // Track color\n    }\n    \n    if (button < 0.0) {\n        return selected ? vec3(0.2, 0.6, 1.0) : vec3(0.8, 0.8, 0.8); // Button color\n    }\n    \n    return vec3(-1.0); // No slider\n}\n\n// Draw brush slider - returns color  \nvec3 drawBrushSlider(vec2 uv, vec2 center, float brushSize, bool selected) {\n    vec2 p = uv - center;\n    \n    // Slider track (vertical)\n    float trackWidth = 0.008;\n    float trackHeight = 0.15;\n    float track = max(abs(p.x) - trackWidth, abs(p.y) - trackHeight);\n    \n    // Map brush size (0.03 to 0.15) to slider position\n    float normalizedSize = (brushSize - 0.03) / (0.15 - 0.03);\n    float buttonY = (normalizedSize - 0.5) * trackHeight * 1.8;\n    \n    // Round button that scales with brush size\n    vec2 buttonPos = vec2(0.0, buttonY);\n    float buttonRadius = 0.008 + (normalizedSize * 0.015); // Grows with brush size\n    float button = length(p - buttonPos) - buttonRadius;\n    \n    // Larger hit area for interaction (but don't show visually)\n    float hitRadius = max(buttonRadius, 0.025); // Minimum hit area\n    float hitArea = length(p - buttonPos) - hitRadius;\n    \n    if (track < 0.0 && button > 0.0) {\n        return vec3(0.3, 0.3, 0.3); // Track color\n    }\n    \n    if (button < 0.0) {\n        return selected ? vec3(0.2, 0.6, 1.0) : vec3(0.8, 0.8, 0.8); // Button color\n    }\n    \n    return vec3(-1.0); // No slider\n}\n\n// Draw FPS indicator\nvec3 drawFPSIndicator(vec2 uv, vec2 center, float fps) {\n    vec2 p = uv - center;\n    float size = 0.01;\n    \n    if (abs(p.x) < size && abs(p.y) < size) {\n        // Color code based on FPS\n        if (fps >= 100.0) return vec3(0.4, 0.8, 1.0);      // Light blue\n        else if (fps >= 55.0) return vec3(0.0, 1.0, 0.0);  // Green\n        else if (fps >= 25.0) return vec3(1.0, 1.0, 0.0);  // Yellow\n        else if (fps >= 15.0) return vec3(1.0, 0.5, 0.0);  // Orange\n        else return vec3(1.0, 0.0, 0.0);                   // Red\n    }\n    \n    return vec3(-1.0); // No indicator\n}\n\n// Sample the carving texture\nfloat getCarvingDepth(vec3 p) {\n\n    vec3 np = normalize(p);\n    float theta = atan(np.z, np.x);\n    float phi = acos(clamp(np.y, -1.0, 1.0));\n    vec2 uv;\n    uv.x = (theta + 3.14159) / (2.0 * 3.14159);\n    uv.y = 1.0 - phi / 3.14159;\n    return texture(iChannel0, uv).r;\n}\n\n// Utility functions\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec2 fold(vec2 p,float s){float a=3.142/s-atan(p.x,p.y),n=6.283/s;p*=rot(floor(a/n)*n);return p;}\nfloat sminCubic(float a,float b,float k){float h=max(k-abs(a-b),0.)/k;return min(a,b)-h*h*h*k*(1./6.);}\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// SDF functions\nfloat sdTorus(vec3 p,vec2 t){return length(vec2(length(p.yz)-t.x,p.x))-t.y;}\nfloat sdCube(vec3 p){vec3 q=abs(p)-.5;return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);}\nfloat sdCappedCylinder(vec3 p,float h,float r){vec2 d=abs(vec2(length(p.xz),p.y))-vec2(h,r);return min(max(d.x,d.y),0.)+length(max(d,0.));}\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// Realistic pumpkin shape with ridges\nfloat sdPumpkin(vec3 p, float r) {\n    // Main pumpkin body - flattened sphere\n    vec3 bodyScale = vec3(1.0, 0.85, 1.0);\n    float body = sdEllipsoid(p, bodyScale * r);\n    \n    // Add vertical ridges\n    float angle = atan(p.z, p.x);\n    float ridgeCount = 12.0;\n    float ridgePhase = sin(angle * ridgeCount) * 0.15;\n    \n    // Modulate the ridges based on height\n    float heightFactor = smoothstep(-0.6, 0.4, p.y);\n    ridgePhase *= heightFactor;\n    \n    body += ridgePhase * r * 0.1;\n    \n    // Add slight indentation at top and bottom\n    float topIndent = smoothstep(0.3, 0.5, p.y) * 0.2 * r;\n    float bottomIndent = smoothstep(-0.5, -0.3, p.y) * 0.03 * r;\n    \n    return body+ topIndent + bottomIndent;\n}\n\n// Pumpkin stem\nfloat sdStem(vec3 p) {\n    vec3 stemPos = p - vec3(0.0, 0.45, 0.0);\n    \n    // Curved stem\n    stemPos.x += sin(stemPos.y * 3.0) * 0.1;\n    stemPos.z += cos(stemPos.y * 2.5) * 0.08;\n    \n    float stem = sdCappedCylinder(stemPos, 0.05, 0.19);\n    \n    // Add some bumps to the stem\n    float noise = sin(stemPos.y * 15.0) * sin(stemPos.x * 20.0) * 0.01;\n    return stem + noise;\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n// Candle flame SDF\nfloat sdFlame(vec3 p) {\n    p.x = abs(p.x)*2.5;\n    vec3 flamePos = p - vec3(0.45, -0.05, 0.0);\n    float it = iTime+p.x;\n    // Flame shape - teardrop\n    float flameHeight = 0.02;\n    float flameWidth = 0.02;\n    \n    // Add flickering animation\n    float flicker = sin(it * 19.0) * 0.02 + cos(it * 37.0) * 0.015;\n    flamePos.y += flicker;\n    flamePos.x += sin(it * 13.) * sin(it * 1.9) *0.02;\n    \n    // Flame SDF - teardrop shape\n    float flame = length(vec2(length(flamePos.xy) - flameHeight * (1.0 - flamePos.y/flameHeight), \n                             flamePos.y)) - flameWidth;\n    flame = max(flame, -flamePos.y);\n    flame = max(flame, flamePos.y - flameHeight);\n    \n    return flame;\n}\n\n\n// Main pumpkin SDF (solid shell only)\nfloat map(vec3 p) {\n    float outer = sdPumpkin(p, 0.6);\n    float inner = sdSphere(p, 0.5);\n    float shell = max(outer, -inner);\n    \n    // Enhanced carving system - subtract carved areas\n    float carving = getCarvingDepth(p);\n    if (carving > 0.3) {\n        float carveIntensity = smoothstep(0.3, 1.0, carving);\n        float expandedInner = sdSphere(p, 0.5 + carveIntensity * 0.2);\n        shell = max(shell, -expandedInner);\n    }\n    \n    // Add stem\n    float stem = sdStem(p);\n    shell = smin(shell, stem, 0.02);\n    \n    return shell;\n}\n\n// Ground plane SDF\nfloat sdGround(vec3 p) {\n    return p.y + 0.8; // Ground at y = -0.8\n}\n\n// Map function that includes flame and ground for rendering\nfloat mapWithFlame(vec3 p) {\n    float pumpkinDist = map(p);\n    float flameDist = sdFlame(p);\n    float groundDist = sdGround(p);\n    \n    // Only render flame if inside pumpkin\n    float inner = sdSphere(p, 0.45);\n    if (inner < 0.0) {\n        return min(min(pumpkinDist, flameDist), groundDist);\n    }\n    \n    return min(pumpkinDist, groundDist);\n}\n\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\n// Simple raymarch\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapWithFlame(p);\n        \n        if (abs(d) < 0.0001) return t;\n        if (t > 10.0) break;\n        \n        t += d * 0.4;\n    }\n    return t;\n}\n\n// Simple volumetric light extending from pumpkin surface\nvec3 renderVolumetricLayers(vec3 ro, vec3 rd, float startDist) {\n    vec3 volumetricColor = vec3(0.0);\n    \n    // Candle light properties\n    vec3 candlePos = vec3(0.0, -0.1, 0.0);\n    float flicker = 0.7 + 0.07 * sin(iTime*37.) + 0.06 * sin(iTime * 19.);\n    vec3 lightColor = vec3(1.5, 1.0, 0.5) * flicker;\n    \n    // Start from pumpkin surface and extend toward camera\n     int numSteps = VOLUMETRIC * 12;\n    float maxDist = 0.3 + float(VOLUMETRIC)*0.3;\n    float stepSize = maxDist / float(numSteps);\n    \n    // Go FROM surface TOWARD camera (negative direction)\n    float t = startDist - 0.02;\n    \n    for (int i = 0; i < numSteps; i++) {\n        //if (t <= 0.0) break; // Don't go behind camera\n        \n        vec3 p = ro + rd * t;\n        float carving = getCarvingDepth(p);\n        \n        if (carving > 0.3) {\n            float carveIntensity = smoothstep(0.3, 1.0, carving);\n            \n            float distToCandle = length(p - candlePos);\n            float attenuation = 1.0 / (1.0 + distToCandle * distToCandle * 0.8);\n            \n            // Distance from surface (how far light has traveled)\n            float distanceFromSurface = startDist - t;\n            float falloff = exp(-distanceFromSurface * 1.5);\n            \n            // Layer effect - expanding shells that move outward\n            float layerSpeed = 2.0;\n            float layerSpacing = 0.3;\n            float expandingLayers = sin((distanceFromSurface - iTime * layerSpeed) / layerSpacing) * 0.4 + 1.0;\n            \n            float contribution = carveIntensity * attenuation * falloff * expandingLayers * 0.06;\n            float smoke;\n            if (SMOKE>0){\n            vec3 sp = p;\n            sp+=1.;\n            sp.x+=iTime/10.;\n            sp*=10.;\n            if (SMOKE>1){\n            smoke = perlinNoise(sp, 1, (SMOKE*2)-2, 0.5, 2.0, 123456u);\n            }else{\n            smoke = perlinNoise(sp, 123456u);\n            }\n            smoke = (smoke + 1.0) * 0.5;\n            contribution*=smoke;\n            }\n            \n            volumetricColor += lightColor * contribution;\n        }\n        \n        t -= stepSize; // Move toward camera\n    }\n    if (SMOKE>0){\n    volumetricColor*=3.;\n    }\n    return volumetricColor;\n}\n\n\n// Get subsurface scattering color based on depth from center\nvec3 getSubsurfaceColor(float distFromCenter) {\n    // Interior glow color - warm candlelight\n    vec3 innerGlow = vec3(1.2, 0.8, 0.3);\n    \n    // Outer pumpkin color\n    vec3 outerColor = vec3(0.8, 0.35, 0.05);\n    \n    // Map distance to depth (0 = inside, 1 = outside surface)\n    float depth = (distFromCenter - 0.4) / 0.2; // 0.6 to 0.7 range\n    depth = clamp(depth, 0.0, 1.0);\n    \n    // Create gradient\n    vec3 subsurfaceColor = mix(innerGlow, outerColor, depth);\n    \n    // Add transmission falloff\n    float transmission = exp(-depth * 5.0);\n    \n    return subsurfaceColor * (0.5 + transmission * 0.5);\n}\n\n\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord, vec4 bg) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Static camera setup - moved pumpkin down slightly (compromise position)\n    vec3 ro = vec3(0.0, 0.1, -2.5);\n    vec3 rd = normalize(vec3(uv, 1.5));\n    \n    // Background\n    vec3 col = bg.rgb;\n    \n    // Raymarch solid surfaces\n    float t = raymarch(ro, rd);\n    \n    if (t < 10.0) {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);\n        float distFromCenter = length(p);\n        float carving = getCarvingDepth(p);\n        \n        // Check if we hit the flame\n        float flameDist = sdFlame(p);\n        float groundDist = sdGround(p);\n        bool isFlame = flameDist < 0.01 && sdSphere(p, 0.45) < 0.0;\n        bool isGround = groundDist < 0.01;\n        \n        if (isFlame) {\n            // Render flame\n            float flameIntensity = 1.0 - smoothstep(0.0, 0.04, flameDist);\n            float flicker = 0.8 + 0.2 * sin(iTime * 37.0) + 0.15 * sin(iTime * 19.0);\n            \n            // Flame color gradient from blue at base to yellow-orange at tip\n            float heightGradient = (p.y + 0.1) / 0.15;\n            vec3 flameColor = mix(\n                vec3(1.0, 0.9, 0.8),  // Blue base\n                vec3(0.3, 0.1, 0.0),  // Orange tip\n                heightGradient\n            );\n            \n            col = flameColor * flameIntensity * flicker * 3.0;\n        } else if (isGround) {\n            // Render ground\n            vec3 groundColor = vec3(0.3, 0.8, 0.3); // Dark earth tone\n            \n            // Key light - strong moonlight from above-behind-side\n            vec3 keyLightDir = normalize(vec3(-0.7, 1.2, -0.8));\n            vec3 keyLightColor = vec3(0.7, 0.8, 1.0) * 1.5;\n            \n            // Simple ground lighting\n            float keyDiff = max(dot(n, keyLightDir), 0.0);\n            vec3 keyDiffuse = groundColor * keyLightColor * keyDiff * 0.6;\n            \n            // Ambient for ground\n            vec3 ambient = groundColor * vec3(0.02, 0.03, 0.05);\n            \n            // Subtle glow from pumpkin onto ground\n            vec3 pumpkinPos = vec3(0.0, 0.0, 0.0);\n            float distToPumpkin = length(p - pumpkinPos);\n            float pumpkinGlow = exp(-distToPumpkin * 1.5) * 0.1;\n            vec3 pumpkinLightColor = vec3(1.0, 0.6, 0.2);\n            \n            col = ambient + keyDiffuse + pumpkinLightColor * pumpkinGlow;\n        } else {\n            // Enhanced lighting system with key light\n            vec3 candlePos = vec3(0.0, -0.3, 0.0);\n            vec3 candleLight = normalize(candlePos - p);\n            vec3 viewDir = normalize(ro - p);\n            \n            // Key light - strong moonlight from above-behind-side\n            vec3 keyLightDir = normalize(vec3(-0.7, 1.2, -0.8));;//normalize(vec3(0.5, 0.7, 2.5));\n            vec3 keyLightColor = vec3(0.8, 0.9, 1.0) * 1.5; // Cool blue moonlight\n            // Key light contribution\n            float keyDiff = max(dot(n, keyLightDir), 0.0);\n            // Flickering candle light intensity\n            float flicker = 0.8 + 0.07 * sin(iTime * 37.0) + 0.06 * sin(iTime * 19.0);\n            vec3 candleLightColor = vec3(1.2, 0.8, 0.4) * flicker;\n            \n            // Are we in a carved area?\n            if (carving > 0.6) {\n                // Enhanced subsurface scattering for carved areas\n                vec3 subsurfaceCol = getSubsurfaceColor(distFromCenter);\n                \n                // Distance-based light falloff\n                float lightDist = length(candlePos - p);\n                float attenuation = 1.5/ (2.0 + lightDist * 2.0);\n                \n                // Inner glow effect\n                float innerGlow = exp(-lightDist * 3.0);\n                \n                col = subsurfaceCol * candleLightColor * (attenuation + innerGlow * 1.5);\n                \n                // Enhanced rim lighting\n               // float rim = 2.0 - abs(dot(viewDir, n));\n                //col += candleLightColor * 4.8 * attenuation * flicker;\n                col*=1.2;\n            } else {\n                // Enhanced pumpkin surface material\n                vec3 pumpkinColor = vec3(0.9, 0.4, 0.05);\n               \n                // Add surface variation based on ridges\n                float angle = atan(p.z, p.x);\n                float ridgePhase = sin(angle * 12.0) * 0.4 + 0.5;\n                ridgePhase += ridgePhase-keyDiff; ridgePhase*=.55;\n                pumpkinColor *= 0.5 + candleLightColor * pow(ridgePhase, 8.);\n                pumpkinColor += (pumpkinColor*=pumpkinColor)/5.;\n                pumpkinColor +=  vec3(1.0, 0.3, 0.02); \n                \n                if(p.z>0.0){pumpkinColor *=1.3;} else { pumpkinColor *=0.5;}\n                // Stem coloring\n                if (p.y > 0.38) {\n                    pumpkinColor = mix(vec3(0.9, 0.4, 0.05), vec3(0.3, 0.5, 0.2), smoothstep(0.5, 0.7, p.y));\n                }\n                \n               \n                vec3 keyDiffuse = pumpkinColor * keyLightColor * keyDiff * 0.8;\n                \n                // Candle light contribution\n                float lightDist = length(candlePos - p);\n                float attenuation = 1.0 / (1.0 + lightDist * lightDist * 0.5);\n                float candleDiff = max(dot(n, candleLight), 0.0);\n                vec3 candleDiffuse = pumpkinColor * candleLightColor * candleDiff * attenuation * 0.6;\n                \n                // Ambient lighting\n                vec3 ambient = pumpkinColor * vec3(0.05, 0.08, 0.15);\n                \n                // Specular highlights from key light\n                vec3 keyHalfDir = normalize(keyLightDir + viewDir);\n                float keySpec = pow(max(dot(n, keyHalfDir), 0.0), 16.0);\n                vec3 keySpecular = keyLightColor * keySpec * 0.3;\n                \n                // Specular highlights from candle\n                vec3 candleHalfDir = normalize(candleLight + viewDir);\n                float candleSpec = pow(max(dot(n, candleHalfDir), 0.0), 8.0);\n                vec3 candleSpecular = candleLightColor * candleSpec * 0.3 * attenuation;\n                \n                col = ambient + keyDiffuse + candleDiffuse + keySpecular + candleSpecular;\n            }\n        }\n    }\n   \n   \n   sro=ro;\n   srd=rd;\n    \n    // Add UI buttons overlay\n    vec2 screenUV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // UI button positions (moved further left)\n    vec2 buttonPos1 = vec2(-0.78, 0.42);   // Regular mode\n    vec2 buttonPos2 = vec2(-0.78, 0.31);   // Mirror mode  \n    vec2 buttonPos3 = vec2(-0.78, 0.20);   // Inverse mode\n    vec2 buttonPos4 = vec2(-0.78, 0.09);   // Mirror + Inverse mode\n    \n    // Read current mode state from BufferA\n    bool currentInverse = texelFetch(iChannel0, ivec2(38,0), 0).x > 0.5;\n    bool currentMirror = texelFetch(iChannel0, ivec2(39,0), 0).x > 0.5;\n    int currentMode = (currentMirror ? 2 : 0) + (currentInverse ? 1 : 0);\n    \n    // Read quality settings and brush size from BufferA and update global variables\n    AA = int(floor(texelFetch(iChannel0, ivec2(40,0), 0).x * 5.0));\n    VOLUMETRIC = int(floor(texelFetch(iChannel0, ivec2(41,0), 0).x * 5.0));\n    SMOKE = int(floor(texelFetch(iChannel0, ivec2(42,0), 0).x * 5.0));\n    \n    \n    float aaQuality = float(AA);\n    float volumetricQuality = float(VOLUMETRIC);\n    float smokeQuality = float(SMOKE);\n    float skiesQuality = float(SKIES);\n    float brushSize = 0.03 + texelFetch(iChannel0, ivec2(44,0), 0).x * (0.15 - 0.03);\n    \n    // Calculate FPS using stored frame timing data\n    //float currentTime = iTime;\n    //float lastFrameTime = texelFetch(iChannel0, ivec2(45,0), 0).x;\n    float deltaTime = texelFetch(iChannel0, ivec2(47,0), 0).x;\n    float fps = (deltaTime > 0.0) ? 1.0 / deltaTime : 60.0;\n    \n    // Quality slider positions (moved up from bottom)\n    vec2 aaSliderPos = vec2(0.71, -0.37);\n    vec2 volumetricSliderPos = vec2(0.76, -0.37);\n    vec2 smokeSliderPos = vec2(0.81, -0.37);\n    vec2 skiesSliderPos = vec2(0.86, -0.37);\n    \n    // Brush slider position (moved down by half its length)\n    vec2 brushSliderPos = vec2(-0.78, -0.155);\n    \n    // FPS indicator position (between original and current)\n    vec2 fpsPos = vec2(0.85, 0.465);\n    \n    // Draw mode buttons\n    vec3 btn1 = drawModeButton(screenUV, buttonPos1, false, false, currentMode == 0);\n    if (btn1.x >= 0.0) col = btn1;\n    \n    vec3 btn2 = drawModeButton(screenUV, buttonPos2, false, true, currentMode == 2);\n    if (btn2.x >= 0.0) col = btn2;\n    \n    vec3 btn3 = drawModeButton(screenUV, buttonPos3, true, false, currentMode == 1);\n    if (btn3.x >= 0.0) col = btn3;\n    \n    vec3 btn4 = drawModeButton(screenUV, buttonPos4, true, true, currentMode == 3);\n    if (btn4.x >= 0.0) col = btn4;\n    \n    // Draw quality sliders\n    vec3 aaSlider = drawQualitySlider(screenUV, aaSliderPos, aaQuality, false);\n    if (aaSlider.x >= 0.0) col = aaSlider;\n    \n    vec3 volumetricSlider = drawQualitySlider(screenUV, volumetricSliderPos, volumetricQuality, false);\n    if (volumetricSlider.x >= 0.0) col = volumetricSlider;\n    \n    vec3 smokeSlider = drawQualitySlider(screenUV, smokeSliderPos, smokeQuality, false);\n    if (smokeSlider.x >= 0.0) col = smokeSlider;\n    \n    vec3 skiesSlider = drawQualitySlider(screenUV, skiesSliderPos, skiesQuality, false);\n    if (skiesSlider.x >= 0.0) col = skiesSlider;\n    \n    // Draw brush slider\n    vec3 brushSlider = drawBrushSlider(screenUV, brushSliderPos, brushSize, false);\n    if (brushSlider.x >= 0.0) col = brushSlider;\n    \n    // Draw FPS indicator\n    vec3 fpsIndicator = drawFPSIndicator(screenUV, fpsPos, fps);\n    if (fpsIndicator.x >= 0.0) col = fpsIndicator;\n    \n    fragColor = vec4(col, 1.0);\n}\n\nvec4 mainImageBG(vec2 u) {\nSKIES = int(floor(texelFetch(iChannel0, ivec2(43,0), 0).x * 5.0));\n    float d, // total distance marched\n          n, // noise iterator\n          i, // raymarch iterator\n          s, // signed distance\n          t = iTime/6.;\n    vec3  p = iResolution;    \n    \n    // scale coords\n    u = -(u-p.xy/2.)/p.y;\n    \n    vec4 o = vec4(0);\n    for(; i++<float(SKIES)*24.;) {\n        \n        p = vec3(u*d,d+t);\n        \n        p.z *= .4;\n        \n        p.y += 4.;\n        \n        p.y += sin(.2*t+p.x*.2);\n\n        // noise loop start, march\n        for (n = .01; n < 1.+float(SKIES)/2.; n += n)\n            p += abs(dot(cos(p.x*.1 + p.z *.3+  t + p / n ), vec3(.33))) * n;\n            d += s = .2 + .7 * abs(p.y),\n            o += 1./s;\n        \n    }\n    o = vec4(0.2,0.2,0.3,0)*o/1e2;\n    o = max(o, vec4(0));\n    return o;\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    vec4 b = mainImageBG(u);\n   \n    vec2 j = vec2(.5); \n    o = vec4(0);\n    vec4 c;\n    mainImage0(c, u, b); \n     float s = pow(2.,float(AA)), k;\n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5, b); \n        o+=c;\n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n    \n    // volumetric light after AA\n    if (VOLUMETRIC>0){\n    vec3 volumetricLight = renderVolumetricLayers(sro, srd, 1.99);\n    o.rgb += volumetricLight;\n    }\n    // gamma correction after AA\n       o.rgb = pow(o.rgb, vec3(0.6));\n       \n       //o= texture(iChannel0, u.xy/iResolution.xy, 0.);\n    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "\nvoid draw( inout vec4 pre , in vec2 muv, in vec2 uv){\n// Static camera setup matching main image\n        vec3 ro = vec3(0.0, 0.1, -2.5);\n        vec3 rd = normalize(vec3(muv, 1.5));\n        \n        bool inverted = false;\n        bool mirrored = false;\n        \n        if(texture( iChannel0, vec2(38.5/iResolution.x, 0.5/iResolution.y)).x>0.5){inverted = true;}\n        if(texture( iChannel0, vec2(39.5/iResolution.x, 0.5/iResolution.y)).x>0.5){mirrored = true;}\n        \n        // Intersect ray with pumpkin shape (approximate with ellipsoid)\n        vec3 scale = vec3(1.0, 0.85, 1.0) * 0.6;\n        \n        // Transform ray to ellipsoid space\n        vec3 roScaled = ro / scale;\n        vec3 rdScaled = rd / scale;\n        \n        float a = dot(rdScaled, rdScaled);\n        float b = 2.0 * dot(roScaled, rdScaled);\n        float c = dot(roScaled, roScaled) - 1.0;\n        float discriminant = b*b - 4.0*a*c;\n        \n        if (discriminant > 0.0) {\n            float t = (-b - sqrt(discriminant)) / (2.0 * a);\n            if (t > 0.0) {\n                vec3 hitPoint = (ro + rd * t);\n                \n                // Convert hit point to spherical coordinates\n                vec3 np = normalize(hitPoint);\n                float hitTheta = atan(np.z, np.x);\n                float hitPhi = acos(clamp(np.y, -1.0, 1.0));\n                \n                // Current texel in spherical coords\n                float texTheta = uv.x * 2.0 * 3.14159 - 3.14159;\n                float texPhi = (1.0 - uv.y) * 3.14159;\n                \n                // Calculate angular distance with better accuracy\n                vec3 p1 = vec3(sin(texPhi) * cos(texTheta), cos(texPhi), sin(texPhi) * sin(texTheta));\n                vec3 p2 = vec3(sin(hitPhi) * cos(hitTheta), cos(hitPhi), sin(hitPhi) * sin(hitTheta));\n                \n                float dist = acos(clamp(dot(p1, p2), -1.0, 1.0));\n                \n                // Enhanced brush system with pressure sensitivity\n                float brushSize = 0.03 + texture(iChannel0, vec2(44.5/iResolution.x, 0.5/iResolution.y)).x * (0.15 - 0.03);\n                \n                if (dist < brushSize) {\n                    // Smooth falloff for natural carving\n                    float falloff = inverted ? smoothstep(0.0, brushSize, dist) : 1.0 - smoothstep(0.0, brushSize, dist);\n                    float newCarve = falloff;\n                    \n                    // Blend with existing carving\n                    // Normal mode: max (additive carving), Inverse mode: min (subtractive carving)\n                    pre.r = inverted ? min(pre.r, newCarve) : max(pre.r, newCarve);\n                }\n            }\n        }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 screenUV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec4 prev = texture(iChannel0, uv);\n    \n    // UI button positions (moved further left)\n    vec2 buttonPos1 = vec2(-0.78, 0.42);   // Regular mode\n    vec2 buttonPos2 = vec2(-0.78, 0.31);   // Mirror mode  \n    vec2 buttonPos3 = vec2(-0.78, 0.20);   // Inverse mode\n    vec2 buttonPos4 = vec2(-0.78, 0.09);   // Mirror + Inverse mode\n    \n    // Read current mode state from previous frame\n    bool currentInverse = texture(iChannel0, vec2(38.5/iResolution.x, 0.5/iResolution.y)).x > 0.5;\n    bool currentMirror = texture(iChannel0, vec2(39.5/iResolution.x, 0.5/iResolution.y)).x > 0.5;\n    \n    // Quality slider positions (moved up from bottom)\n    vec2 aaSliderPos = vec2(0.71, -0.37);\n    vec2 volumetricSliderPos = vec2(0.76, -0.37);\n    vec2 smokeSliderPos = vec2(0.81, -0.37);\n    vec2 skiesSliderPos = vec2(0.86, -0.37);\n    \n    // Brush slider position (moved down by half its length)\n    vec2 brushSliderPos = vec2(-0.78, -0.155);\n    \n    // Handle button clicks\n    bool buttonClicked = false;\n    if (iMouse.z > 0.0) {\n        vec2 mouseScreen = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n        \n        // Check button clicks first (using smaller button size)\n        if (length(mouseScreen - buttonPos1) < 0.048) {\n            // Regular mode: mirror=false, inverse=false\n            buttonClicked = true;\n            if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 0.0; // inverse = false\n            if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 0.0; // mirror = false\n        }\n        else if (length(mouseScreen - buttonPos2) < 0.048) {\n            // Mirror mode: mirror=true, inverse=false  \n            buttonClicked = true;\n            if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 0.0; // inverse = false\n            if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 1.0; // mirror = true\n        }\n        else if (length(mouseScreen - buttonPos3) < 0.048) {\n            // Inverse mode: mirror=false, inverse=true\n            buttonClicked = true;\n            if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 1.0; // inverse = true\n            if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 0.0; // mirror = false\n        }\n        else if (length(mouseScreen - buttonPos4) < 0.048) {\n            // Mirror + Inverse mode: mirror=true, inverse=true\n            buttonClicked = true;\n            if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 1.0; // inverse = true\n            if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 1.0; // mirror = true\n        }\n        \n        // Check for slider interactions\n        else if (abs(mouseScreen.x - aaSliderPos.x) < 0.02 && abs(mouseScreen.y - aaSliderPos.y) < 0.08) {\n            // AA Quality slider\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - aaSliderPos.y + 0.08) / 0.16, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(40,0)) prev.r = sliderValue;\n        }\n        else if (abs(mouseScreen.x - volumetricSliderPos.x) < 0.02 && abs(mouseScreen.y - volumetricSliderPos.y) < 0.08) {\n            // Volumetric Quality slider\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - volumetricSliderPos.y + 0.08) / 0.16, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(41,0)) prev.r = sliderValue;\n        }\n        else if (abs(mouseScreen.x - smokeSliderPos.x) < 0.02 && abs(mouseScreen.y - smokeSliderPos.y) < 0.08) {\n            // Smoke Quality slider\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - smokeSliderPos.y + 0.08) / 0.16, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(42,0)) prev.r = sliderValue;\n        }\n        else if (abs(mouseScreen.x - skiesSliderPos.x) < 0.02 && abs(mouseScreen.y - skiesSliderPos.y) < 0.08) {\n            // Skies Quality slider\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - skiesSliderPos.y + 0.08) / 0.16, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(43,0)) prev.r = sliderValue;\n        }\n        else if (abs(mouseScreen.x - brushSliderPos.x) < 0.04 && abs(mouseScreen.y - brushSliderPos.y) < 0.18) {\n            // Brush size slider (bigger hit area)\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - brushSliderPos.y + 0.15) / 0.3, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(44,0)) prev.r = sliderValue;\n        }\n        \n        // Only do pumpkin carving if no button or slider was clicked\n        if (!buttonClicked) {\n            vec2 mouseUV = mouseScreen;\n            \n            // Use current brush size for carving\n            float currentBrushSize = 0.03 + texture(iChannel0, vec2(44.5/iResolution.x, 0.5/iResolution.y)).x * (0.15 - 0.03);\n            draw(prev, mouseUV, uv);\n            \n            // Apply mirroring if enabled\n            if(currentMirror){\n                mouseUV.x = -mouseUV.x;\n                draw(prev, mouseUV, uv);\n            }\n        }\n    }\n    \n    // Note: UI rendering moved to main image shader\n    // BufferA only handles button interaction logic and data storage\n    \n    // FPS calculation - update timing data\n    if (ivec2(fragCoord) == ivec2(45,0)) {\n        // Store current time in pixel 45\n        prev.r = iTime;\n    }\n    else if (ivec2(fragCoord) == ivec2(46,0)) {\n        // Calculate and store delta time in pixel 46\n        float currentTime = iTime;\n        float lastFrameTime = texture(iChannel0, vec2(45.5/iResolution.x, 0.5/iResolution.y)).x;\n        float deltaTime = currentTime - lastFrameTime;\n        prev.r = deltaTime;\n    }else if (ivec2(fragCoord) == ivec2(47,0)) {\n        // Calculate and store delta time in pixel 46\n        float currentTime = iTime;\n        float lastFrameTime = texture(iChannel0, vec2(45.5/iResolution.x, 0.5/iResolution.y)).x;\n        float deltaTime = currentTime - lastFrameTime;\n        float lastDelta = texture(iChannel0, vec2(46.5/iResolution.x, 0.5/iResolution.y)).x;\n        float lastDeltab = texture(iChannel0, vec2(47.5/iResolution.x, 0.5/iResolution.y)).x;\n        prev.r = lastDeltab - (lastDeltab - lastDelta)/15.;\n    }\n    \n    // Clear on rewind - initialize default state\n    if (iFrame < 2) {\n        prev = vec4(0.0);\n        // Set default mode (regular: no mirror, no inverse)\n        if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 0.0; // inverse = false\n        if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 0.0; // mirror = false\n        \n        // Set default quality values (matching original defines)\n        if (ivec2(fragCoord) == ivec2(40,0)) prev.r = 0.0 / 4.0; // AA = 0\n        if (ivec2(fragCoord) == ivec2(41,0)) prev.r = 2.0 / 4.0; // VOLUMETRIC = 2\n        if (ivec2(fragCoord) == ivec2(42,0)) prev.r = 2.0 / 4.0; // SMOKE = 2\n        if (ivec2(fragCoord) == ivec2(43,0)) prev.r = 2.0 / 4.0; // SKIES = 2\n        \n        // Set default brush size (0.09 normalized to 0-1 range)\n        if (ivec2(fragCoord) == ivec2(44,0)) prev.r = (0.09 - 0.03) / (0.15 - 0.03); // Default brush size\n        \n        // Initialize timing data\n        if (ivec2(fragCoord) == ivec2(45,0)) prev.r = iTime; // Current time\n        if (ivec2(fragCoord) == ivec2(46,0)) prev.r = 1.0/60.0; // Initial delta time (60 FPS)\n        if (ivec2(fragCoord) == ivec2(47,0)) prev.r = 1.0/60.0; // Initial delta time (60 FPS)\n    }\n    \n    fragColor = prev;\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfBfRG",
    "date": "1758721348",
    "viewed": 127,
    "name": "Texture Drawing to SDF",
    "description": "Very crude method for drawing a dynamic 2D SDF with a texture.\nI need this for version 2 of my [url=https://shadertoy.com/view/WfffR8]Pumpkin Carver[/url]\nThere are other, better ways to do this like [url=https://shadertoy.com/view/McByRd]Jump Flood[/url]",
    "likes": 7,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "sdf",
     "texture",
     "drawing"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n    float d = data.a;\n    d *= 3.0;\n    vec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);\n    col *= 1.0 - exp(-6.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(150.0 * d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.005, abs(d)));\n    fragColor = vec4(col, 1.0);\n    //fragColor = pow(texture(iChannel1, fragCoord.xy/iResolution.xy, 0.)*3., vec4(.7)); //view buffer A\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n    float inside = 0.02;\n    float dist = tex.r;\n    float newDist;\n    \n    if(iMouse.z > 0.0)\n    {\n        newDist = (distance(iMouse.xy, fragCoord.xy)/iResolution.x) - inside;\n        \n        if(tex.b == 0.1) {\n            newDist = min(dist, newDist);\n        }\n        \n        // Store distance in R, final corrected in G, state in B\n        fragColor = vec4(newDist, tex.g, 0.1, 1.0);\n    } \n    else if(tex.b != 0.1) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } \n    else {\n        fragColor = tex;\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 pixelSize = 1.0/iResolution.xy;\n    \n    vec4 drawn = texture(iChannel1, uv, 0.);\n    vec4 prev = texture(iChannel0, uv, 0.);\n    \n    // If mouse is pressed, keep working with drawn data but preserve corrected\n    if(iMouse.z > 0.0) {\n        // Pass through drawn distance, but keep the corrected value\n        fragColor = vec4(drawn.r, prev.g, drawn.b, 1.0);\n        fragColor.a = (fragColor.r<0.) ? prev.g == 0.0? drawn.r:prev.g : fragColor.r;\n        return;\n    }\n    \n    float currentDist = prev.r;\n    float correctedDist = prev.g; // Final corrected distance\n    float state = prev.b;\n    \n    // Pixel-relative boundary threshold\n    float boundaryThreshold = pixelSize.x;\n    \n    // Initialize: mark pixels near boundary as correct\n    if(state == 0.1 && abs(currentDist) < boundaryThreshold) {\n        state = 0.5;\n        correctedDist = currentDist;\n    }\n    \n    // If this pixel needs fixing (not yet corrected)\n    if(state == 0.1 && currentDist < 0.0) {\n        \n        float bestDist = currentDist;\n        bool foundCorrect = false;\n        \n        // Larger kernel for faster initial propagation\n        const int kernelSize = 5; // Adjust this: 1=3x3, 2=5x5, 4=9x9, 8=17x17\n        \n        for(int y = -kernelSize; y <= kernelSize; y++) {\n            for(int x = -kernelSize; x <= kernelSize; x++) {\n                if(x == 0 && y == 0) continue;\n                \n                vec2 offset = vec2(x, y) * pixelSize;\n                vec4 neighbor = texture(iChannel0, uv + offset, 0.);\n                \n                if(neighbor.b >= 0.5) {\n                    float nDist = neighbor.g; // Use corrected distance from neighbor\n                    float stepDist = length(vec2(x, y)) * pixelSize.x;\n                    float proposedDist = nDist - stepDist;\n                    \n                    if(!foundCorrect || proposedDist > bestDist) {\n                        bestDist = proposedDist;\n                        foundCorrect = true;\n                    }\n                }\n            }\n        }\n        \n        if(foundCorrect) {\n            correctedDist = bestDist;\n            state = 0.5;\n        }\n    }\n    \n    // Corrected pixels: refine distance and apply smoothing\n    else if(state >= 0.5 && state < 1.0 && currentDist < 0.0) {\n        \n        float bestDist = correctedDist;\n        \n        // Still use larger kernel for refinement (or reduce to 1 for accuracy)\n        const int refineKernel = 2; // 5x5 for refinement phase\n        \n        for(int y = -refineKernel; y <= refineKernel; y++) {\n            for(int x = -refineKernel; x <= refineKernel; x++) {\n                if(x == 0 && y == 0) continue;\n                \n                vec2 offset = vec2(x, y) * pixelSize;\n                vec4 neighbor = texture(iChannel0, uv + offset, 0.);\n                \n                if(neighbor.b >= 0.5) {\n                    float nDist = neighbor.g; // Use corrected distance\n                    float stepDist = length(vec2(x, y)) * pixelSize.x;\n                    float proposedDist = nDist - stepDist;\n                    \n                    if(proposedDist > bestDist) {\n                        bestDist = proposedDist;\n                    }\n                }\n            }\n        }\n        \n        correctedDist = bestDist;\n        \n        // Apply smoothing\n        if(state > 0.5 && state < 0.9) {\n            float sumDist = 0.0;\n            float sumWeight = 0.0;\n            \n            for(int y = -1; y <= 1; y++) {\n                for(int x = -1; x <= 1; x++) {\n                    vec2 offset = vec2(x, y) * pixelSize;\n                    vec4 neighbor = texture(iChannel0, uv + offset, 0.);\n                    \n                    if(neighbor.b >= 0.5) {\n                        float nDist = neighbor.g; // Use corrected distance\n                        float weight = 1.0 / (1.0 + length(vec2(x, y)));\n                        sumDist += nDist * weight;\n                        sumWeight += weight;\n                    }\n                }\n            }\n            \n            if(sumWeight > 0.0) {\n                float smoothedDist = sumDist / sumWeight;\n                float smoothStrength = 0.3 * (1.0 - (state - 0.5) / 0.4);\n                correctedDist = mix(correctedDist, smoothedDist, smoothStrength);\n            }\n        }\n        \n        state = min(state + 0.009, 1.0);\n    }\n    \n    // Store: R = current/working distance, G = corrected distance, B = state\n    fragColor = vec4(currentDist, correctedDist, state, 1.0);\n    fragColor.a = (fragColor.r<0.) ? fragColor.g : fragColor.r;\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "W3XyRn",
    "date": "1759182567",
    "viewed": 832,
    "name": "sin (sin (x) + cos (y)) =",
    "description": "Plot of sin (sin (x) + cos (y)) = cos (sin (x*y) + cos (x))\nFrom [url=https://x.com/jshguo/status/1972564708525064688]here[/url]",
    "likes": 21,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sin",
     "cos",
     "graph",
     "equation",
     "twitter",
     "maths"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// sin (sin (x) + cos (y)) = cos (sin (x*y) + cos (x))\n\n// from Joshua Guo on x: https://x.com/jshguo/status/1972564708525064688\n\n// mouse x to zoom\n\n// mouse y to change view mode\n\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv *= iMouse.z!=0.?pow((iMouse.x/iResolution.x)*8., 2.5):12.;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \n    // Implicit equation rearranged to f(x,y) = 0\n    float f = sin(sin(x) + cos(y)) - cos(sin(x*y) + cos(x));\n    \n    // Mode A: Simple zero contour\n    vec3 colorA = mix(vec3(0.1, 0.1, 0.2), vec3(1.0, 0.5, 0.0), smoothstep(0.05, 0.0, abs(f)));\n    \n    // Mode B: Grid-based\n    vec2 grid = abs(fract(uv) - 0.5);\n    float gridLine = smoothstep(0.02, 0.0, min(grid.x, grid.y));\n    float curve = smoothstep(0.03, 0.0, abs(f));\n    vec3 bgColor = vec3(0.05, 0.05, 0.1);\n    vec3 gridColor = vec3(0.2, 0.2, 0.3);\n    vec3 curveColor = vec3(1.0, 0.8, 0.2);\n    vec3 colorB = mix(bgColor, gridColor, gridLine * 0.5);\n    colorB = mix(colorB, curveColor, curve);\n    \n    // Mode C: Contour with positive/negative regions\n    float contour = sin(f * 20.0) * 0.5 + 0.5;\n    vec3 colorC;\n    if (f > 0.0) {\n        colorC = mix(vec3(0.2, 0.1, 0.4), vec3(1.0, 0.3, 0.1), contour);\n    } else {\n        colorC = mix(vec3(0.1, 0.2, 0.4), vec3(0.1, 0.7, 1.0), contour);\n    } \n    colorC = mix(colorC, vec3(1.0), smoothstep(0.02, 0.0, abs(f)));\n    \n    // Mode D: Heat map visualization\n    vec3 colorD = vec3(0.5) + 0.5 * cos(6.28 * f + vec3(0, 1, 2));\n    colorD = mix(colorD, vec3(1.0), curve);\n    \n    // Blend modes based on mouse Y position\n    float mouseY = iMouse.z != 0. ? iMouse.y / iResolution.y : 0.25;\n    float blendParam = mouseY * 3.0; \n    vec3 finalColor;\n    if (blendParam < 1.0) {\n        finalColor = mix(colorA, colorB, smoothstep(0.0, 1.0, blendParam));\n    } else if (blendParam < 2.0) {\n        finalColor = mix(colorB, colorC, smoothstep(1.0, 2.0, blendParam));\n    } else {\n        finalColor = mix(colorC, colorD, smoothstep(2.0, 3.0, blendParam));\n    }\n    fragColor = vec4(finalColor, 1.0);\n}\n\n// multisampling\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 64., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  \n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXfyRH",
    "date": "1759259006",
    "viewed": 294,
    "name": "Pumpkin Carver V2",
    "description": "This is a fork of P-Malin's amazing [url=https://shadertoy.com/view/MdBXR3]Jack-o'-lantern[/url]\nAfter [url=https://shadertoy.com/view/3cBfDw]version 1[/url], I wanted to test a different approach to the carving using a better scene with convincing SSS",
    "likes": 33,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fork",
     "halloween",
     "drawing",
     "pumpkin",
     "carving",
     "october",
     "jackolantern"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGRn",
       "filepath": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGRn",
       "filepath": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Jack-o'-lantern\" by P_Malin. https://shadertoy.com/view/MdBXR3\n// and \"Texture Drawing SDF\" by Cotterzz. https://shadertoy.com/view/3cfBzj\n// and \"Pumpkin Carver V1\" by Cotterzz. https://shadertoy.com/view/3cBfDw\n\n// I was just mucking about with this shader to see if this approach would work for version 2\n// But it turned out so well I just kept it as-is and started work on version 3\n\n// Instead of using a texture to displace an SDF and then subtracting it.\n// Using 2D SDF extrusion is a lot cleaner. (P_Malin's original shader already used this technique to cut out the face.)\n// All I needed to do was convert a brush-drawn texture into 2D SDF first, then I could still use a drawing texture like before.\n// Luckily there is a quick hack for this - comparing minimum distance with mouse position to effectively draw an SDF.\n// It's very crude, but for a single path it does a near perfect job in the positive distance.\n// And is drawn for very little performance cost in real time, so no conversion passes.\n\n#define kRaymarchMaxIter 64\n\n#define kBounceCount 1\n\nfloat kFarClip=100.0;\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\nfloat GetCarving2dDistance(const in vec2 vPos );\n\nvec3 vLightPos = vec3(0.0,0.0, 0.5);\t\t\t\nvec3 vLightColour = vec3(1.0, 0.8, 0.4);\n\nfloat fCarving = 1.0;\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\n    vLightColour *= hash(iTime) * 0.2 + 0.8;\n    \n    float fDist = 5.5;\n    float fAngle = 3.141;\n    float fHeight = 1.0;\n    \n    if(iTime < 1.5)\n    {\n        fDist += pow(abs(iTime - 1.5), 3.);\n    }\n        if(iTime < 3.)\n    {\n        fHeight += pow(abs(iTime -3.), 2.)/5.;\n    }\n    \n\tvec2 vMouse = iMouse.xy / iResolution.xy;\n    \n\tvec3 vCameraPos = vec3(sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist);\n\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n\n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t    \n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\t\n\tfragColor = vec4(vFinal, 1.0);\n}\n\n// CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 1.5);\n\n\treturn vDir;\n}\n\n// POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.95;\n\tconst float kPower = 1.5;\n\n\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(1.0 - fDist, kPower));\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n\tfloat kExposure = 1.0;\n    \n    if(iTime < 2.0)\n    {\n        kExposure = iTime / 2.0;\n    }\n    \t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0/kGamma));\t\n}\n\nvec3 ApplyBlackLevel( const in vec3 vColour )\n{\n    float fBlackLevel = 0.1;\n    return vColour / (1.0 - fBlackLevel) - fBlackLevel;\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = ApplyTonemap(vTemp);\n\t\n\tvTemp = ApplyGamma(vTemp);\t\t\n    \n    vTemp = ApplyBlackLevel(vTemp);\n    \n    return vTemp;\n}\n\t\n// RAYTRACE\n\nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n\tvec3 vUVW;\n\tfloat fObjectId;\n};\n\n\nfloat GetCarving2dDistance(const in vec3 vPos) // Note: take full vec3\n{\n    float frontZ = -2.7; // front of pumpkin\n    vec2 surfaceXY = vPos.xy * (frontZ / vPos.z); // perspective correct projection\n    \n    vec2 uv = surfaceXY * vec2(.15,.25) + vec2(.5,.45); \n\n    float userCarving = texture(iChannel2, uv).r-texture(iChannel2, uv).g;\n    userCarving = (userCarving) * 2.0;\n    \n    return userCarving;\n}\n\nfloat GetCarvingDistance(const in vec3 vPos )\n{\n\tfloat fDist = (length(vPos * vec3(1.0, 1.4, 1.0)) - 2.7) / 1.5;\n\n    float fFaceDist = GetCarving2dDistance(vPos);\n    \n\tfloat fRearDist = vPos.z;\n\t\n\tif(fRearDist > fFaceDist)\n\t{\n\t\tfFaceDist = fRearDist;\n\t}\t\n\t\n\tif(fFaceDist < fDist )\n\t{\n\t\tfDist = fFaceDist;\n\t}\n\n    float fR = length(vPos.xz);\n   \n    float fLidDist = dot( vec2(fR, vPos.y), normalize(vec2(1.0, -1.3)));\n    \n    fLidDist = abs(fLidDist) - 0.03;\n\tif(fLidDist < fDist )\n\t{\n\t\tfDist = fLidDist;\n\t}\n   \n\treturn fDist;\n}\n\nfloat GetPumpkinDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n    vec3 vSphereOrigin = vec3(0.0, 0.0, 0.0);\n    float fSphereRadius = 3.0;\n\n\tvec3 vOffset = vPos - vSphereOrigin;\n\tfloat fFirstDist = length(vOffset);\n\t\n\tfloat fOutDist;\n\tif(fFirstDist > 3.5)\n\t{\n\t\tfOutDist = fFirstDist - fSphereRadius;\n\t}\n\telse\n\t{\n\t\tfloat fAngle1 = atan(vOffset.x, vOffset.z);\n\t\tfloat fSin = sin(fAngle1 * 10.0);\n\t\tfSin = 1.0 - sqrt(abs(fSin));\n\t\tvOffset *= 1.0 + fSin * vec3(0.05, 0.025, 0.05);\n\t\tvOffset.y *= 1.0 + 0.5 * (fSphereRadius - length(vOffset.xz)) / fSphereRadius;\n\t\tfOutDist = length(vOffset) - fSphereRadius;\n\t}\n\t\n\n\tvec4 vSphere1UVW_Id = vec4(normalize(vPos - vSphereOrigin), 3.0);\n\tvOutUVW_Id = vSphere1UVW_Id;\n\t\n\tvec3 vStalkOffset = vPos;\n\tvStalkOffset.x += -(vStalkOffset.y - fSphereRadius) * 0.1;\n\tfloat fDist2d = length(vStalkOffset.xz);\n\tfloat fStalkDist = fDist2d - 0.2;\n\tfStalkDist = max(fStalkDist, vPos.y - 2.5 + vPos.x * 0.25);\n\tfStalkDist = max(fStalkDist, -vPos.y);\n\tif( fStalkDist < fOutDist )\n\t{\n\t\tfOutDist = fStalkDist;\n\t\tvOutUVW_Id = vSphere1UVW_Id;\n\t\tvOutUVW_Id.w = 2.0;\n\t}\n\n\treturn fOutDist;\n}\n\nfloat GetSceneDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n\tfloat fFloorDist = vPos.y + 2.0;\n\tvec4 vFloorUVW_Id = vec4(vPos.xz, 0.0, 1.0);\n\n\t\n\tvec3 vPumpkinDomain = vPos;\n    \n\tfloat fOutDist = fFloorDist;\n\tvOutUVW_Id = vFloorUVW_Id;\n\n\tvec4 vPumpkinUVW_Id;\n\tfloat fPumpkinDist = GetPumpkinDistance( vPumpkinUVW_Id, vPumpkinDomain );\n\n\tfloat fCarvingDist = GetCarvingDistance( vPumpkinDomain );\n\t\n\tif(-fCarvingDist > fPumpkinDist)\n\t{\n\t\tfPumpkinDist = -fCarvingDist;\n\t\tvPumpkinUVW_Id = vec4(4.0);\n\t}\n\n\t\n\tif(fPumpkinDist < fOutDist)\n\t{\n\t\tfOutDist = fPumpkinDist;\n\t\tvOutUVW_Id = vPumpkinUVW_Id;\n\t}\n\t\n\treturn fOutDist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n\tvec4 vUnused;\n    float f1 = GetSceneDistance( vUnused, vPos + vOffset1 );\n    float f2 = GetSceneDistance( vUnused, vPos + vOffset2 );\n    float f3 = GetSceneDistance( vUnused, vPos + vOffset3 );\n    float f4 = GetSceneDistance( vUnused, vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * f1 + vDir2 * f2 + vDir3 * f3 + vDir4 * f4;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec4 vUVW_Id = vec4(0.0);\t\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.01;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tvPos = vOrigin + vDir * t;\n\t\tfloat fDist = GetSceneDistance(vUVW_Id, vPos);\t\t\n\t\tt += fDist;\n\t\tif(abs(fDist) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > 100.0)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tvPos = vOrigin + vDir * t;\n\t\t\tvUVW_Id = vec4(0.0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vPos;\n\toutIntersection.vNormal = GetSceneNormal(vPos);\n\toutIntersection.vUVW = vUVW_Id.xyz;\n\toutIntersection.fObjectId = vUVW_Id.w;\n}\n\n\nfloat TraceShadow( const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n    C_Intersection shadowIntersection;\n\tTraceScene(shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fDist < fDist) \n\t{\n\t\treturn 0.0;\t\t\n\t}\n\t\n\treturn 1.0;\n}\n\nfloat GetSSS( const in vec3 vPos, const in vec3 vLightPos )\n{\n    vec3 vLightToPos = vPos - vLightPos;\n    vec3 vDir = normalize(vLightToPos);\n    \n\tC_Intersection intersection;\n\tTraceScene(intersection, vLightPos, vDir);\n\tfloat fOpticalDepth = length(vLightToPos) - intersection.fDist;\n\n    fOpticalDepth = max(0.00001, fOpticalDepth);\n    \n\treturn exp2( fOpticalDepth * -8.0 );\n}\n\n// LIGHTING\n\nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\tfloat fNDotV = clamp(dot(-vViewDir, vNormal), 0.0, 1.0);\n\tfloat fNDotH = clamp(dot(vNormal, vH), 0.0, 1.0);\n\t\n\tfloat alpha = 1.0 - fSmoothness;\n\talpha = alpha * alpha;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNDotH * fNDotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = GIV(fNDotL, k) * GIV(fNDotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;\n\tvSpecularLight += vLightColour * fSpecularIntensity;\n\n\tvDiffuseLight += vLightColour * fNDotL;\n}\n\nvoid AddPointLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nfloat AddDirectionalLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n    \n    return fShadowFactor;\n}\n\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir), 0.0, 1.0);\n\tfloat kSpreadPower = 4.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower);\n}\n\n// SCENE MATERIALS\n\nvoid GetSurfaceInfo(out vec3 vOutAlbedo, out vec3 vOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n\t\n\tif(intersection.fObjectId == 1.0)\n\t{\n\t\tvec2 vUV = intersection.vUVW.xy * 0.1;\n\t\tvOutAlbedo = texture(iChannel0, vUV).rgb;\n\t\tfloat fBumpScale = 10.0;\n\t\t\n\t\tvec2 vRes = iChannelResolution[0].xy;\n\t\tvec2 vDU = vec2(1.0, 0.0) / vRes;\n\t\tvec2 vDV = vec2(0.0, 1.0) / vRes;\n\t\t\n\t\tfloat fSampleW = texture(iChannel0, vUV - vDU).r;\n\t\tfloat fSampleE = texture(iChannel0, vUV + vDU).r;\n\t\tfloat fSampleN = texture(iChannel0, vUV - vDV).r;\n\t\tfloat fSampleS = texture(iChannel0, vUV + vDV).r;\n\t\t\n\t\tvec3 vNormalDelta = vec3(0.0);\n\t\tvNormalDelta.x += \n\t\t\t( fSampleW * fSampleW\n\t\t\t - fSampleE * fSampleE) * fBumpScale;\n\t\tvNormalDelta.z += \n\t\t\t(fSampleN * fSampleN\n\t\t\t - fSampleS * fSampleS) * fBumpScale;\n\t\t\n\t\tvOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\t\tfOutSmoothness = clamp((0.8 - vOutAlbedo.r * 4.0), 0.0, 1.0);\n\t\t\n\t\tvOutR0 = vec3(0.01) * vOutAlbedo.g;\n\t}\n\telse if(intersection.fObjectId == 2.0)\n\t{\n\t\tvOutAlbedo = vec3(0.5, 0.5, 0.2);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.05);\n\t}\n\telse if(intersection.fObjectId == 3.0)\n\t{\n        float fAngle = atan(intersection.vUVW.x, intersection.vUVW.z);\n        vec2 vUV = vec2(fAngle, intersection.vUVW.y) * vec2(1.0, 0.2) * 8.0;\n\t\tvOutAlbedo = texture(iChannel1, vUV).rgb;\n\t\tfOutSmoothness = clamp(1.0 - vOutAlbedo.r * vOutAlbedo.r * 2.0, 0.0, 1.0);\t\t\t\n\t\tvec3 vCol1 = vec3(1.0, 0.5, 0.0);\n\t\tvec3 vCol2 = vec3(0.5, 0.06, 0.0);\n\t\tvOutAlbedo = mix(vCol1, vCol2, vOutAlbedo.r * 0.5).rgb;\n\t\tvOutR0 = vec3(0.05);\n\t}\n\telse if(intersection.fObjectId == 4.0)\n    {\n\t\tvOutAlbedo = vec3(1.0, 0.824, 0.301);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.05);\n\t}\n}\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\t\n\tvec3 vResult = mix(vec3(0.02, 0.04, 0.06), vec3(0.1, 0.5, 0.8), abs(vDir.y));\n\t\n\treturn vResult;\t\n}\n\nfloat GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.025;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 GetFogColour(const in vec3 vDir)\n{\n\treturn vec3(0.01);\t\t\n}\n\nvec3 vSunLightColour = vec3(0.1, 0.2, 0.3) * 5.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\n\t\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\n{\t\t\n\tfloat fFogFactor = GetFogFactor(fDist);\n\tvec3 vFogColour = GetFogColour(vRayDir);\t\t\t\n\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\n\t\n\tvColour = mix(vFogColour, vColour, fFogFactor);\t\n}\n\n// TRACING LOOP\n\n\t\nvec3 GetSceneColour( in vec3 _vRayOrigin,  in vec3 _vRayDir )\n{\n    vec3 vRayOrigin = _vRayOrigin;\n    vec3 vRayDir = _vRayDir;\n\tvec3 vColour = vec3(0.0);\n\tvec3 vRemaining = vec3(1.0);\n\t\n    float fLastShadow = 1.0;\n    \n\tfor(int i=0; i<kBounceCount; i++)\n\t{\t\n\t\tvec3 vCurrRemaining = vRemaining;\n\t\tfloat fShouldApply = 1.0;\n\t\t\n\t\tC_Intersection intersection;\t\t\t\t\n\t\tTraceScene( intersection, vRayOrigin, vRayDir );\n\n\t\tvec3 vResult = vec3(0.0);\n\t\tvec3 vBlendFactor = vec3(0.0);\n\t\t\t\t\t\t\n\t\tif(intersection.fObjectId == 0.0)\n\t\t{\n\t\t\tvBlendFactor = vec3(1.0);\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tvec3 vR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, vR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n            fLastShadow = AddDirectionalLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\n            vec3 vPointLightPos = vLightPos;\n          \n            \n\t\t\tAddPointLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vPointLightPos, vLightColour);\t\t\t\t\t\t\t\t\n          \n            if(intersection.fObjectId >= 3.0)\n            {\n                vDiffuseLight += GetSSS(intersection.vPos+vec3(0,0.0,0), vPointLightPos) * vLightColour;\n            } else\n            {\n                vec3 vToLight = vPointLightPos - intersection.vPos;\n                float fNdotL = dot(normalize(vToLight), vBumpNormal) * 0.5 + 0.5;\n\t\t\t\tvDiffuseLight += max(0.0, 1.0 - length(vToLight)/5.0) * vLightColour * fNdotL;                \n            }\n\n\t\t\tfloat fSmoothFactor = fSmoothness * 0.9 + 0.1;\n            float fFresnelClamp = 0.25; // too much fresnel produces sparkly artefacts\n            float fNdotD = clamp(dot(vBumpNormal, -vRayDir), fFresnelClamp, 1.0);\n\t\t\tvec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - fNdotD, 5.0) * fSmoothFactor;\n\n            \n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, vFresnel);\t\t\n\t\t\tvBlendFactor = vFresnel;\n\t\t\t\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\t\t\n\t\t\t\n\t\t\tvRemaining *= vBlendFactor;\t\t\t\t\n\t\t\tvRayDir = normalize(reflect(vRayDir, vBumpNormal));\n\t\t\tvRayOrigin = intersection.vPos;\n\t\t}\t\t\t\n\n\t\tvColour += vResult * vCurrRemaining * fShouldApply;\t\n\t}\n\n\tvec3 vSkyColor = GetSkyColour(vRayDir);\n\t\n\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir);\t\t\n\t\n    // Hack for this scene when using 1 bounce.\n    // remove final sky reflection when in shadow\n    vSkyColor *= fLastShadow; \n    \n\tvColour += vSkyColor * vRemaining;\n    // Face glow\n    float t = -(_vRayOrigin.z + 2.8) / _vRayDir.z;\n    \n    if( t > 0.0 )\n    {\n        vec3 vPos = _vRayOrigin + _vRayDir * t;\n\n        float fDist = abs(GetCarving2dDistance(vec3(vPos.xy * vec2(1.0, 1.0), -2.5)));\n        float fDot = max(0.0, _vRayDir.z);\n        fDot = fDot * fDot;\n        vColour += exp2(-fDist * 10.0) * fDot * vLightColour * 0.25;\n    }\n\treturn vColour;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n    float inside = 0.015;\n    float dist = tex.r-tex.g;\n    float newDist ;\n    if(iMouse.z > 0.0)\n    {\n        newDist = (distance(iMouse.xy, fragCoord.xy)/iResolution.x) - inside;\n        \n        if(tex.b==0.1){newDist = min(dist, newDist);} // if drawing has happened compare with existing distance\n        \n        fragColor = vec4(max(newDist,0.),-min(newDist,0.),0.1,1.0);\n        \n    } else if(tex.b!=0.1){fragColor = vec4(0.5,0,0.1,1.);} else {\n        fragColor = tex;\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "t3XcRH",
    "date": "1759259735",
    "viewed": 168,
    "name": "Pumpkin Moebius",
    "description": "I needed to make a more procedural pumpkin for the next version of the pumpkin carver.\nIt is based on this desmos pumpkin equation: [url]https://www.desmos.com/3d/afwrvhoa9n[/url]\nI thought I'd have some fun with it here.",
    "likes": 21,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "procedural",
     "spiral",
     "animation",
     "halloween",
     "pumpkin",
     "moebius",
     "october",
     "jackolantern"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// rewind or resize to change the random seed\n\n// AA setting in buffer B\n\n// SDF based on:   https://www.desmos.com/3d/afwrvhoa9n\n// Fork of \"Balatro-like Shader\"              by hatenal. https://shadertoy.com/view/t3syRH\n// Fork of \"Pumpkin Carver C du\"           by Nguyen2007. https://shadertoy.com/view/wcsBDl\n// Fork of \"Pumpkin Carver V1\"               by Cotterzz. https://shadertoy.com/view/3cBfDw\n// Fork of \"Ortho Spiral Random shaders\"     by Cotterzz. https://shadertoy.com/view/WcsBWB\n// Fork of \"I heard yall like Ortho spiral?\" by frisk256. https://shadertoy.com/view/3fffRs\n\n// Credits\n// Nguyen2007/a random guy for helping fix the rotation projection issue.\n// ArmandB/Big Chungus for the Desmos pumpkin equation\n// frisk256 for the original moebius code\n// spalmer and FabriceNeyret for the multisampling code\n// chronos/Helios Hyperium for the seam fix\n// diatribes for spotting the pow issue on firefox/linux/opengl\n// vipitis/jakel101, AHSEN/01000001, kaiavintr, kukovisuals for general inspiration and ideas\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv , 0.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Simple hash function\nfloat hash(float seed) {\n    return fract(sin(seed * 12.9898) * 43758.5453);\n}\n\n// Get 2D sdf data from font texture\nfloat GetCharacter(ivec2 ch, vec2 cuv, float th) {\n    cuv = clamp(cuv, vec2(0), vec2(1));\n    float tx = (cuv.x/16.) + (float(ch.x)*(1./16.));\n    float ty = (cuv.y/16.) + (float(ch.y)*(1./16.));\n    return (-.5*th) + texture(iChannel0, vec2(tx, ty)).a;\n}\n\nfloat char2DSDFRotated(vec2 p, vec2 scale, ivec2 ch, float angle, float th) {\n    float c = cos(angle);\n    float s = sin(angle);\n    vec2 rotP = vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n    vec2 uv = rotP / scale + 0.5;\n    return GetCharacter(ch, uv, th);\n}\n\nfloat eyesSDF(vec2 p, float scale, int index) {\n    ivec2 echars = ivec2(0);\n    float erotation = 0.;\n    vec2 escale = vec2(2,1) * scale;\n    vec2 eoffset = vec2(0,-0.4) * scale;\n    float ethickness = 1.0;\n\n    switch (index) {\n        case 0: echars = ivec2(5,15); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); erotation = -3.141; break;\n        case 1: echars = ivec2(14,14); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); erotation = -3.141; break;\n        case 2: echars = ivec2(4,15); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); escale = vec2(1,1) * scale; erotation = -3.141; break;\n        case 3: echars = ivec2(3,15); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); escale = vec2(1,1) * scale; erotation = -3.141; break;\n        case 4: echars = ivec2(12,14); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); escale = vec2(1,1) * scale; erotation = -3.141; break;\n        case 5: echars = ivec2(10,13); eoffset += vec2(-0.5,-0.2)*scale; p.x = abs(p.x); erotation = -3.141; break;\n        case 6: echars = ivec2(11,13); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); erotation = -3.141; break;\n        case 7: echars = ivec2(12,13); eoffset += vec2(-0.4,-0.4)*scale; p.x = abs(p.x); escale = vec2(2) * scale; break;\n        case 8: echars = ivec2(5,15); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); erotation = -3.141; break;\n    }\n    return char2DSDFRotated(p + eoffset, escale, echars, erotation, ethickness);\n}\n\nfloat mouthSDF(vec2 p, float scale, int index) {\n    ivec2 mchars = ivec2(0);\n    float mrotation = 0.;\n    vec2 mscale = vec2(2,1) * scale;\n    vec2 moffset = vec2(0,0.3) * scale;\n    float mthickness = 1.0;\n\n    switch (index) {\n        case 0: mchars = ivec2(6,10); p.x = abs(p.x)<0.5?(fract(p.x * 6.)-0.5)/3.:p.x; break;\n        case 1: mchars = ivec2(15,6); moffset += vec2(-0.4,0)*scale; p.x = abs(p.x); mrotation = -.2; break;\n        case 2: mchars = ivec2(7,8); break;\n        case 3: mchars = ivec2(7,10); break;\n        case 4: mchars = ivec2(13,10); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 5: mchars = ivec2(13,8); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 6: mchars = ivec2(9,13); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 7: mchars = ivec2(8,13); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 8: mchars = ivec2(11,10); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 9: mchars = ivec2(6,10); p.x = abs(p.x)<0.35?(fract(p.x * 6.)-0.5)/3.:p.x; break;\n        case 10: mchars = ivec2(6,10); p.x = abs(p.x)<0.65?(fract(p.x * 6.)-0.5)/3.:p.x; break;\n        case 11: mchars = ivec2(15,5); moffset += vec2(0,0.3)*scale; break;\n        case 12: mchars = ivec2(3,15); mscale = vec2(2.5,1) * scale; break;\n        case 13: mchars = ivec2(3,15); mscale = vec2(1.5,1.5) * scale; break;\n    }\n    \n    return char2DSDFRotated(p + moffset, mscale, mchars, mrotation, mthickness);\n}\n\nfloat faceSDF(vec2 p, float scale, float mouthSliderA, float mouthSliderB, float mouthSliderC, float eyeSliderA) {\n    int mouthTypes = 10;\n    int eyeTypes = 8;\n    \n    float mouthA = mouthSDF(p, scale, int(floor(mouthSliderA * float(mouthTypes))));\n    float mouthB = mouthSDF(p, scale, 1+int(floor(mouthSliderA * float(mouthTypes))));\n    float mouthC = mouthSDF(p, scale, 13);\n    float mouthD = mouthSDF(p, scale, 12);\n    float mouthE = mouthSDF(p, scale, 11);\n    float mouth = mix(mouthA, mouthB, fract(mouthSliderA * float(mouthTypes)));\n    mouth -= (0.5-abs(fract(mouthSliderA * float(mouthTypes)) - 0.5))/15.;\n    float mouthF = mouthSliderB<0.5 ? mix(mouthC, mouthD, mouthSliderB*2.) : mix(mouthD, mouthE, (mouthSliderB-0.5)*1.6);\n    mouth = mix(mouth, mouthF, mouthSliderC);\n    \n    float eyesA = eyesSDF(p, scale, int(floor(eyeSliderA * float(eyeTypes))));\n    float eyesB = eyesSDF(p, scale, 1+int(floor(eyeSliderA * float(eyeTypes))));  \n    float eyes = mix(eyesA, eyesB, fract(eyeSliderA * float(eyeTypes)));\n    \n    return min(mouth, eyes);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Check resolution change from top-left pixel\n    vec4 storedData = texture(iChannel1, vec2(0.5) / iResolution.xy);\n    float storedWidth = storedData.b * 4096.0;\n    float storedHeight = storedData.a * 4096.0;\n    bool resolutionChanged = abs(storedWidth - iResolution.x) > 0.5 || \n                            abs(storedHeight - iResolution.y) > 0.5;\n    if(fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n            fragColor = vec4(0.0, 0.0, iResolution.x / 4096.0, iResolution.y / 4096.0);\n            return;\n        }\n    // Redraw if first 2 frames OR resolution changed\n    if(iFrame < 10 || resolutionChanged) {\n        // Top-left pixel stores resolution metadata\n        \n        \n        vec2 cellCoord = floor(fragCoord / (iResolution.xy / vec2(8.0, 5.0)));\n        vec2 cellUV = fract(fragCoord / (iResolution.xy / vec2(8.0, 5.0)));   \n        vec2 p = (cellUV * 2.0 - 1.0) * 1.5;\n        float sec = mod(iDate.w,3600.);\n        float randomSeed = cellCoord.x + (cellCoord.y / 10.0) + sec;\n        float mouthSliderA = hash(randomSeed + 0.7);\n        float mouthSliderB = hash(randomSeed + 0.8);\n        float mouthSliderC = hash(randomSeed + 0.9);\n        mouthSliderC *= mouthSliderC*mouthSliderC*mouthSliderC; // bias to lower values\n        //mouthSliderC = 1.-mouthSliderC;\n        float eyeSliderA = hash(randomSeed + 1.1);\n        if(cellCoord==vec2(0)){\n            mouthSliderA = 0.6;\n            mouthSliderB = 0.7;\n            mouthSliderC = 0.5;\n            eyeSliderA = 0.37;\n        }\n        float scale = 1.0;\n        float dist = faceSDF(p, scale, mouthSliderA, mouthSliderB, mouthSliderC, eyeSliderA);\n        float mask = smoothstep(0.02, -0.02, dist);\n        \n        fragColor = vec4(dist * 0.5 + 0.5, mask, 0.0, 1.0);\n    } else {\n        // Keep previous frame\n        fragColor = texture(iChannel1, fragCoord.xy / iResolution.xy);\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#if HW_PERFORMANCE == 0\n#define AA 1\n#else\n#define AA 3\n#endif\n\n// set to 1 to disable antialiasing, higher numbers for smooth gfx at the expense of FPS.\n\nfloat randomSeed = 0.0;\nvec4 guv;\nvec2 bguv;\nvec2 cellID;\nfloat shadow = 0.;\n// Pumpkin shape parameters\nfloat n0, m0, k0, n1, m1, k1, n2, m2, k2;\nfloat g, p, h;\n\n// Lid parameters\nfloat thickness;\nfloat cutSphereRadius;\nfloat cutSphereY;\nfloat lidRaise;\nfloat lidTiltX;\nfloat lidTiltZ;\nfloat lidGap;\n\n// Stalk parameters\nfloat stalkRadius;\nint stalkStarN;\nfloat stalkStarM;\nfloat stalkHeight;\nfloat stalkTwist;\nfloat stalkBend;\nfloat stalkTaper;\nfloat stalkBulbHeight;\nfloat stalkBulbRadius;\nfloat stalkHeightOffset;\n\n// Face parameters\nfloat faceScale;\nfloat faceDepth;\nfloat faceZ;\nfloat stemSubtract;\nfloat mouthSliderA;\nfloat mouthSliderB;\nfloat mouthSliderC;\nfloat eyeSliderA;\nint mouthTypes = 10;\nint eyeTypes = 8;\n\n// Simple hash function\nfloat hash(float seed) {\n    return fract(sin(seed * 12.9898) * 43758.5453);\n}\nvec2 hash2(float n) {\n    return vec2(hash(n), hash(n * 1.7));\n}\n// Parameter mapping functions\nfloat mapParam(float t, float minVal, float maxVal) {\n    return mix(minVal, maxVal, t);\n}\n\nfloat mapFloor(float t, float minVal, float maxVal) {\n    return floor(mix(minVal, maxVal, clamp(t, 0.0, 1.0)));\n}\n\n// SDF Operations\nfloat opOnion(float sdf, float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat sphereSDF(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\n// 2D Star SDF\nfloat sdStar(vec2 p, float r, int n, float m) {\n    float an = 3.141593 / float(n);\n    float en = 3.141593 / m;\n    vec2 acs = vec2(cos(an), sin(an));\n    vec2 ecs = vec2(cos(en), sin(en));\n\n    float bn = mod(atan(p.y, p.x), 2.0 * an) - an;\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\nfloat faceSDF(vec2 p, float scale) {\n    // Calculate which cell in the atlas to use\n    vec2 atlasSize = vec2(8.0, 5.0);\n    vec2 atlasCellA = mod(cellID, atlasSize);\n    vec2 atlasCellB = mod(vec2(0), atlasSize);\n    // Convert p from world space to atlas UV space\n    vec2 atlasUVA = (p / scale + 1.0) * 0.5; // -1..1 to 0..1\n    atlasUVA = (atlasUVA + atlasCellA) / atlasSize;\n     // Convert p from world space to atlas UV space\n    vec2 atlasUVB = (p / scale + 1.0) * 0.5; // -1..1 to 0..1\n    atlasUVB = (atlasUVB + atlasCellB) / atlasSize;   \n    // Sample the pre-rendered face\n    vec4 tex = mix(texture(iChannel0, atlasUVB), texture(iChannel0, atlasUVA), guv.w);\n    float sdfValue = mix(1.- tex.g, tex.r, guv.w); // Use iChannel1 for Buffer A\n    \n    // Convert back from normalized range\n    return (sdfValue - 0.5) / 5.0;\n}\n\n// Extrude a 2D SDF along Z axis\nfloat extrudeSDF(vec3 pos, float char2D, float halfDepth) {\n    vec2 w = vec2(char2D, abs(pos.z) - halfDepth);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// Twisting operation\nvec3 opTwist(vec3 p, float k) {\n    float c = cos(k * p.y);\n    float s = sin(k * p.y);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\n// Bending operation\nvec3 opBend(vec3 p, float k) {\n    float bendAmount = k * p.y * p.y / stalkHeight;\n    return vec3(p.x + bendAmount, p.y, p.z);\n}\n\n// Rotation matrices\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n\n// Convert Cartesian to spherical coordinates\nvec3 cartesianToSpherical(vec3 pos) {\n    float rho = length(pos);\n    float theta = atan(pos.z, pos.x);\n    float phi = acos(pos.y / rho);\n    return vec3(rho, theta, phi);\n}\n\nfloat pown(float f, float p){\n    return pow(abs(f), p);\n}\n\n// Pumpkin equation SDF\nfloat pumpkinSDF(vec3 pos) {\n    vec3 spherical = cartesianToSpherical(pos);\n    float theta = spherical.y;\n    float phi = spherical.z;\n    \n    float sin_term0 = sin(n0 * theta + m0);\n    float sin_term1 = sin(n1 * theta + m1);\n    float sin_term2 = sin(n2 * theta + m2);\n    \n    float part1 = (1.0 - pown(sin_term0, 4.0)) * (k0 / n0) +\n                  (1.0 - sin_term1) * (k1 / n1) +\n                  (1.0 - sin_term2) * (k2 / n2);\n    \n    float cos_2phi = cos(2.0 * phi);\n    float part2 = pown((1.0 - cos_2phi) / 2.0, 2.0);\n    float part3 = exp(-pown(phi - 3.14159 / 2.0, 2.0)) + p;\n    float part4 = 1.0 - h * cos_2phi;\n    \n    float target_rho = (part1 * part2 + g) * part3 * part4;\n    \n    return length(pos) - target_rho;\n}\n\n// Stalk SDF\nfloat stalkSDF(vec3 pos) {\n    vec3 stalkPos = pos;\n    stalkPos.y -= lidRaise;\n    stalkPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * stalkPos;\n    stalkPos = stalkPos - vec3(0.0, stalkHeightOffset + (g * p * 1.2) - (h/3.), 0.0);\n    \n    vec3 twistedPos = opTwist(stalkPos, stalkTwist / stalkHeight);\n    vec3 bentPos = opBend(twistedPos, stalkBend / stalkHeight);\n    \n    float heightFactor = clamp((bentPos.y) / stalkHeight, 0.0, 1.0);\n    float bulbFactor = 1.0 - smoothstep(0.0, stalkBulbHeight, bentPos.y);\n    float bulbRadius = mix(stalkRadius, stalkBulbRadius, bulbFactor);\n    float taperedRadius = bulbRadius * (1.0 - stalkTaper * heightFactor);\n    \n    float starDist = sdStar(bentPos.xz, taperedRadius, stalkStarN, stalkStarM);\n    float heightDist = (abs(bentPos.y - stalkHeight * 0.5) - stalkHeight * 0.5);\n    \n    vec2 w = vec2(starDist, heightDist);\n    float stalkBase = min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n\n    return opSubtraction(stemSubtract, stalkBase);\n}\n\n// Hollow pumpkin with top cut off\nfloat hollowPumpkinSDF(vec3 pos) {\n    float pumpkin = pumpkinSDF(pos);\n    float hollow = opOnion(pumpkin, thickness);\n    \n    vec3 cutSpherePos = pos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius + lidGap);\n    \n    return opSubtraction(cuttingSphere, hollow);\n}\n\n// Lid SDF\nfloat lidSDF(vec3 pos) {\n    vec3 lidPos = pos;\n    lidPos.y -= lidRaise;\n    lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n    \n    float pumpkin = pumpkinSDF(lidPos);\n    stemSubtract = pumpkin;\n    \n    float hollow = opOnion(pumpkin, thickness);\n    \n    vec3 cutSpherePos = lidPos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius);\n    \n    return max(hollow, cuttingSphere);\n}\n\n// Main scene SDF\nfloat sceneSDF(vec3 pos) {\n    float hollowPumpkin = hollowPumpkinSDF(pos);\n    float lid = lidSDF(pos);\n    float stalk = stalkSDF(pos);\n    \n    float faceShape = faceSDF(pos.xy, faceScale*1.4);\n    vec3 facePos = pos - vec3(0.0, 0.0, faceZ);\n    float faceCutout = extrudeSDF(facePos, faceShape, faceDepth);\n    \n    hollowPumpkin = opSubtraction(faceCutout, hollowPumpkin);\n    \n    return opUnion(opUnion(hollowPumpkin, lid), stalk);\n}\n\n// Raymarching\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = sceneSDF(pos);\n        if (d < 0.0005) break;\n        t += d * .9;\n        if (t > 50.0) break;\n    }\n    return t;\n}\n\n// Calculate normal\nvec3 getNormal(vec3 pos) {\n    float eps = 0.001;\n    vec3 n = vec3(\n        sceneSDF(pos + vec3(eps, 0, 0)) - sceneSDF(pos - vec3(eps, 0, 0)),\n        sceneSDF(pos + vec3(0, eps, 0)) - sceneSDF(pos - vec3(0, eps, 0)),\n        sceneSDF(pos + vec3(0, 0, eps)) - sceneSDF(pos - vec3(0, 0, eps))\n    );\n    return normalize(n);\n}\n\n// Subsurface scattering\nfloat calculateSubsurface(vec3 pos, vec3 interiorLightPos, float probeDistance) {\n    vec3 toLightDir = normalize(interiorLightPos - pos);\n    float toLightDist = distance(interiorLightPos , pos);\n    vec3 probePos = pos + toLightDir * (probeDistance + 0.15);\n    float d = sceneSDF(probePos);\n    \n    // Only apply subsurface if we're actually inside the object\n    // and not just in free space\n    float surfaceDist = sceneSDF(pos);\n    if (surfaceDist > 0.001) return 0.0;  // We're not on the surface\n    \n    return clamp(max(0., (d*3.)/(toLightDist*toLightDist)), 0.0, 1.0);\n}\n\nvec3 lighting(vec3 pos, vec3 normal, vec3 viewDir, float subsurfaceDistance, float subsurfaceAttenuation, mat3 cameraMatrix) {\n    float flicker = 0.9 + hash(randomSeed) + 0.4 * sin(iTime * 37.0) + 0.2 * sin(iTime * 71.0) * (0.5 + hash(randomSeed));\n    \n    vec3 worldKeyLightDir = normalize( mix(vec3(0,1,0) , vec3(-1.,.7,-1.) , guv.x) );  // Original direction\n    vec3 keyLightDir = normalize(cameraMatrix * worldKeyLightDir);  // Transform to camera space\n    vec3 keyLightColor = mix(vec3(1) ,vec3(.1, 0.7, 1.0), guv.x);\n\n    vec3 interiorLightPos = vec3(0.0, 0.0, 0.0);\n    vec3 interiorLightColor = vec3(1.2, .8, 0.2);\n    float interiorLightIntensity = mix( 0. , flicker , guv.w);\n    \n    vec3 ambient = vec3(0.7, 0.5, 0.4)-guv.w/2.5;\n\n    float keyDiff = max(dot(normal, keyLightDir), 0.0);\n    vec3 keyDiffuse = keyDiff * keyLightColor;\n    \n    vec3 keyReflectDir = reflect(-keyLightDir, normal);\n    float keySpec = pow(max(dot(viewDir, keyReflectDir), 0.0), 32.0);\n    vec3 keySpecular = keySpec * keyLightColor;\n    \n    vec3 toInteriorLight = interiorLightPos - pos;\n    float interiorLightDist = length(toInteriorLight);\n    vec3 interiorLightDir = toInteriorLight / interiorLightDist;\n    \n    float attenuation = interiorLightIntensity / (1.0 + 0.3 * interiorLightDist * interiorLightDist);\n\n    float interiorDiff = max(dot(normal, interiorLightDir), 0.0);\n    vec3 interiorDiffuse = interiorDiff * interiorLightColor * attenuation * guv.w;\n    \n    vec3 diffuse = keyDiffuse + interiorDiffuse;\n    \n    float hollowDist = hollowPumpkinSDF(pos);\n    float lidDist = lidSDF(pos);\n    float stalkDist = stalkSDF(pos);\n    \n    vec3 materialColor;\n    float fleshSpecular = 1.0;\n    \n    if (stalkDist < hollowDist && stalkDist < lidDist) {\n        materialColor = vec3(0.36, 0.57, 0.13);\n    } else if (lidDist < hollowDist) {\n        vec3 lidPos = pos;\n        lidPos.y -= lidRaise;\n        lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n        \n        float originalLidPumpkin = pumpkinSDF(lidPos);\n        float fleshDepth = max(0.0, -originalLidPumpkin + thickness);\n        \n        if (fleshDepth > 0.001) {\n            float depthFactor = clamp(fleshDepth / 0.1, 0.0, 1.0);\n            vec3 fleshColor = mix(vec3(1.2, 0.9, 0.4), vec3(0.8, 0.4, 0.1), depthFactor);\n            materialColor = fleshColor;\n            fleshSpecular = max(0., mix(0.8, 0.1, depthFactor * 20.));\n        } else {\n            materialColor = vec3(0.8, 0.4, 0.12);\n        }\n    } else {\n        float originalPumpkin = pumpkinSDF(pos);\n        float fleshDepth = max(0.0, -originalPumpkin + (thickness));\n        shadow = clamp(7.* clamp(-originalPumpkin, 0.01, 10.5) * (1.-guv.w), 0., 0.6);\n\n        if (fleshDepth > 0.001) {\n            float depthFactor = clamp(fleshDepth / 0.1, 0.0, 1.0);\n            vec3 fleshColor = mix(vec3(1.2, 0.9, 0.4), vec3(0.8, 0.4, 0.1), depthFactor);\n\n            materialColor = fleshColor;\n            fleshSpecular = max(0., mix(0.8, 0.1, depthFactor * 20.));\n        } else {\n            materialColor = vec3(0.9, 0.45, 0.15);\n        }\n    }\n    \n    float subsurfaceDistance_val = calculateSubsurface(pos, interiorLightPos, subsurfaceDistance);\n    float subsurfaceFactor = subsurfaceDistance_val > 0.0 ? clamp(subsurfaceDistance_val, 0.0, 1.0) : 0.0;\n    vec3 subsurfaceLight = subsurfaceFactor * interiorLightColor * guv.w;\n    \n    return (materialColor * (ambient + diffuse + subsurfaceLight - shadow) + fleshSpecular * keySpecular) ;\n}\n\nfloat sinS(float x, float skip_count) {\n    float period_length = 2.0 * 3.14159265359;\n    float period_number = floor(x / period_length);\n    float period_mod = mod(period_number, skip_count);\n    \n    if (period_mod >= skip_count - 1.0) {\n        return -cos(x);\n    } else {\n        return -1.0;\n    }\n}\nvec2 simulateCursorOrganic(float time) {\n    float changeInterval = 2.0;\n    float currentIndex = floor(time / changeInterval);\n    \n    // Generate multiple waypoints for more complex paths\n    vec2 p0 = hash2(currentIndex - 1.0);\n    vec2 p1 = hash2(currentIndex);\n    vec2 p2 = hash2(currentIndex + 1.0);\n    vec2 p3 = hash2(currentIndex + 2.0);\n    \n    float localTime = fract(time / changeInterval);\n    \n    // Elastic easing for \"darting\" with slight overshoot\n    float t = localTime;\n    if (t < 0.3) {\n        // Quick dart phase\n        t = pow(t / 0.3, 2.0);\n    } else {\n        // Settle with slight oscillation\n        t = 1.0 - pow(1.0 - (t - 0.3) / 0.7, 3.0) * 0.05 * \n            cos((t - 0.3) * 20.0);\n    }\n    \n    // Catmull-Rom spline for smoother path\n    vec2 cursor = 0.5 * (\n        (2.0 * p1) +\n        (-p0 + p2) * t +\n        (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t * t +\n        (-p0 + 3.0 * p1 - 3.0 * p2 + p3) * t * t * t\n    );\n    \n    return clamp(cursor, 0.0, 1.0);\n}\nvec2 simulateCursorAdvanced(float time, float ji) {\n    float jumpInterval = 1.+4.*ji;\n    float jumpIndex = floor(time / jumpInterval);\n    float jumpProgress = fract(time / jumpInterval);\n    \n    // Multiple movement phases:\n    // 0.0-0.1: hold at start position\n    // 0.1-0.4: dart to new position\n    // 0.4-1.0: hold at end position\n    \n    float moveProgress;\n    if (jumpProgress < 0.1) {\n        moveProgress = 0.0; // Hold\n    } else if (jumpProgress < 0.4) {\n        // Quick dart motion\n        float t = (jumpProgress - 0.1) / 0.3;\n        moveProgress = 1.0 - pow(1.0 - t, 2.0); // Ease-out\n    } else {\n        moveProgress = 1.0; // Hold at destination\n    }\n    \n    vec2 fromPos = hash2(jumpIndex);\n    vec2 toPos = hash2(jumpIndex + 1.0);\n    \n    // Add some slight wobble at destination\n    if (moveProgress >= 1.0) {\n        toPos += sin(time * 10.0) * 0.01;\n    }\n    \n    return mix(fromPos, toPos, moveProgress);\n}\nvec3 mainImage1(vec2 uv, vec2 id) {\n    // Set random seed based on cell\n    randomSeed = id.x + (id.y / 10.);\n    \n    // Generate all parameters from random seed\n    float anim = (2. + randomSeed / 2.)*3.;\n    float anims = 10.;\n    float tiltPhase = 1. - fract(  ( (iTime - 0.1 + (anim * 3.)) * anims /15. ) / (2.0 * 3.14159265359)  );\n    tiltPhase *=tiltPhase;\n    lidRaise = mix(0., mapParam((sinS(   ((iTime + (anim * 3.)) * anims *2. ) , 30. ) + 1.), 0.03, 0.3)  , guv.w) ;\n    lidTiltX = mix(0., mapParam((sin(((iTime + anim * 3.) * anim)) + 1.) / 2., -0.2, 0.2)  , guv.w) * tiltPhase; \n    lidTiltX += lidRaise * 2.*(hash(randomSeed +3.)-0.5);\n    lidTiltZ = mix(0., mapParam((cos(((iTime + anim * 3.) * anim)) + 1.) / 2., -0.15, 0.15)  , guv.w) * tiltPhase;\n    lidTiltZ += lidRaise * 2.*(hash(randomSeed)-0.5);\n    uv.y -= guv.w * (sinS(((iTime + anim * 3.) * anims), 15.) + 1.)/10.;\n    \n    \n    //uv.y -= tiltPhase;\n    cutSphereY = mapParam(hash(randomSeed + 0.3), 0.5, 0.8);\n    cutSphereRadius = mapParam(hash(randomSeed + 0.4), 0.45, 0.6);\n    thickness = mapParam(hash(randomSeed + 0.5), 0.05, 0.06);\n    lidGap = mapParam(hash(randomSeed + 0.6), 0.0, 0.05);\n    \n    mouthSliderA = hash(randomSeed + 0.7);\n    mouthSliderB = hash(randomSeed + 0.8);\n    mouthSliderC = hash(randomSeed + 0.9);\n    eyeSliderA = hash(randomSeed + 1.1);\n    \n    float subsurfaceDistance = mapParam(hash(randomSeed + 1.2), 0.05, 0.08);\n    float subsurfaceAttenuation = mapParam(hash(randomSeed + 1.3), 0.2, 2.0);\n    \n    vec2 sMouse = simulateCursorAdvanced(anim+iTime*anim/7., hash(randomSeed));\n    \n    // Camera parameters\n    float focal = 0.0;\n    float baseCameraDist = mapParam(0.1, 4.0, 10.0);\n    float screenMag = mapParam(1.0, 0.75, 3.0);\n    vec2 spooky = mix(vec2(0.5), sMouse, guv.w/2.);\n    float pitch = radians(mapParam(0.5 - (0.5 - spooky.y) / 3., -89.0, 70.0));\n    float yaw = mapParam(0.5 - (0.5 - spooky.x) / 3., -4.7123, 1.5708);\n    //float yaw = mapParam(0.5 - (guv.x-0.5)/10., -4.7123, 1.5708);\n    \n    // Stalk parameters\n    stalkRadius = mapParam(hash(randomSeed + 2.0), 0.04, 0.1);\n    stalkStarN = int(mapFloor(hash(randomSeed + 2.1), 5.0, 20.0));\n    stalkStarM = mapParam(hash(randomSeed + 2.2), 1.8, 4.0);\n    stalkHeight = mapParam(hash(randomSeed + 2.3), 0.3, 0.5);\n    stalkTwist = mapParam(hash(randomSeed + 2.4), 0.0, 1.5);\n    stalkBend = mapParam(hash(randomSeed + 2.5), 0.0, 0.4);\n    stalkTaper = mapParam(hash(randomSeed + 2.6), -0.5, 0.3);\n    stalkBulbHeight = mapParam(hash(randomSeed + 2.7), 0.1, 0.3);\n    \n    // Pumpkin shape parameters\n    k2 = mapParam(hash(randomSeed + 2.8), 0.02, 0.3);\n    m2 = mapParam(hash(randomSeed + 2.9), 0.0, 6.28);\n    n2 = mapFloor(hash(randomSeed + 3.0), 4.0, 12.0);\n    k1 = mapParam(hash(randomSeed + 3.1), 0.02, 0.3);\n    m1 = mapParam(hash(randomSeed + 3.2), 0.0, 6.28);\n    n1 = mapFloor(hash(randomSeed + 3.3), 5.0, 30.0);\n    k0 = mapParam(hash(randomSeed + 3.4), 0.02, 0.3);\n    m0 = mapParam(hash(randomSeed + 3.5), 0.0, 3.14);\n    n0 = mapFloor(hash(randomSeed + 3.6), 6.0, 60.0);\n    h = mapParam( mix( 0.35, hash(randomSeed + 3.7), guv.w ), -0.3, 0.05) + guv.w * (sinS(((iTime - 0.25 + (anim * 3.)) *anims* 2.), 30.) + 1.)/15.;\n    p = mapParam( mix( 0.5, hash(randomSeed + 3.8), guv.w ), 0.5, 0.8);\n    g = mapParam( mix( 0.5, hash(randomSeed + 3.9), guv.w ), 0.5, 0.7);\n    \n    // Derived parameters\n    stalkBulbRadius = cutSphereRadius * 0.6;\n    stalkHeightOffset = 0.0;\n    faceScale = g * (p + .3) * ((h + 1.) / 3.) * mapParam(hash(randomSeed + 1.0), 3.25, 4.5);\n    faceDepth = 1.3;\n    faceZ = 1.3;\n    \n    baseCameraDist /= pow(max(0.5, focal), 2.);\n    screenMag /= pow(max(0.5, focal), 2.);\n    \n    vec2 uvScene = uv / screenMag;\n    \n    // Camera setup\n    vec3 target = vec3(0.0, 0.35, 0.0);\n    vec3 dir = vec3(cos(pitch) * cos(yaw), sin(pitch), cos(pitch) * sin(yaw));\n    vec3 ro = target - dir * baseCameraDist;\n\n    vec3 forward = normalize(target - ro);\n    vec3 upRef = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(forward, upRef));\n    vec3 up = cross(right, forward);\n// Camera to world matrix (inverse of view matrix rotation part)\nmat3 cameraMatrix = mat3(right, up, -forward);\n    vec3 rd = normalize(forward + uvScene.x * right + uvScene.y * up);\n    \n    vec3 color = mix(vec3(0.9,0.9,1.2), vec3(0.0), guv.y);\n    color = pow(1.2*mix(color, color* texture(iChannel1, bguv, 0.).rgb, guv.y), vec3(2.));\n    \n    float t = raymarch(ro, rd);\n\n    if (t < 50.0) {\n        vec3 pos = ro + t * rd;\n        vec3 normal = getNormal(pos);\n        vec3 viewDir = normalize(ro - pos);\n       color = lighting(pos, normal, viewDir, subsurfaceDistance, subsurfaceAttenuation, cameraMatrix);\n    }\n    \n    return color;\n}\n\nvoid compute_things(in vec2 p, out vec2 h, out vec2 ddx, out vec2 ddy) {\n    const float TAU = 6.28318530718;\n    const mat2 M = mat2(8.0, 5.0, -5.0, 8.0);\n\n    vec2 r = iResolution.xy;\n    vec2 s = sqrt(r / r.yx);\n    vec2 a = 2.0 / r * s;\n    vec2 u = a * p - s;\n    \n    float S = dot(u, u) + 1.0;\n    float invS = 1.0 / S;\n    float invS2 = invS * invS;\n\n    vec3 g = vec3(1.0, u.yx) * invS + vec3(-0.5, 0.0, 0.5);\n\n    float T = dot(g, g);\n    float invT = 1.0 / T;\n    float invT2 = invT * invT;\n\n    vec3 dg_dux = vec3(-2.0 * u.x * invS2, -2.0 * u.x * u.y * invS2, invS - 2.0 * u.x * u.x * invS2);\n    vec3 dg_duy = vec3(-2.0 * u.y * invS2, invS - 2.0 * u.y * u.y * invS2, -2.0 * u.x * u.y * invS2);\n\n    vec3 dg_dx = dg_dux * a.x;\n    vec3 dg_dy = dg_duy * a.y;\n\n    vec2 q = g.xy * invT;\n\n    float dTdx = 2.0 * dot(g, dg_dx);\n    float dTdy = 2.0 * dot(g, dg_dy);\n\n    vec2 dq_dx = dg_dx.xy * invT - g.xy * dTdx * invT2;\n    vec2 dq_dy = dg_dy.xy * invT - g.xy * dTdy * invT2;\n\n    float denom = dot(q, q);\n    float scale = 1.0 / (TAU * denom);\n\n    ddx = vec2(dq_dx.x * q.y - dq_dx.y * q.x, dot(dq_dx, q)) * scale;\n    ddy = vec2(dq_dy.x * q.y - dq_dy.y * q.x, dot(dq_dy, q)) * scale;\n\n    h = vec2(atan(q.x, q.y), log(length(q))) / TAU;\n    h += iTime * 0.04;\n\n    h *= M;\n    ddx *= M;\n    ddy *= M;\n}\n\nmat2 rotate(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage0(out vec4 c, vec2 p) {\n\n    vec2 h, ddx, ddy;\n    compute_things(p, h, ddx, ddy);\n \n    float a = atan(ddx.x, ddy.x);\n    cellID = floor(h);\n    cellID = mod(cellID, vec2(8, 5));\n    vec2 cellUV = fract(h);\n    \n    vec2 uv = cellUV.yx * 2.0 - 1.0;\n    //uv = mix(  uv*rotate(3.2)  ,    uv*rotate(-a), guv.y*guv.y);\n    uv *= rotate(-a);\n    //uv *= rotate(2.6);\n    vec3 col = mainImage1(uv, cellID);\n    c = vec4(col, 1.0);\n\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    //fragCoord*=1.5;\n    //fragCoord += iMouse.xy-iResolution.xy/2.;\n    vec2 uv =  fragCoord.xy/iResolution.xy;\n    guv.xy = uv;\n    bguv = uv;\n    guv = guv.xxxx;\n    guv.y /= 0.4;\n    guv.y -= .8;\n    guv.z /= 0.2;\n    guv.z -= 02.;\n   // uv.y+=(-.1 + (uv.x*.2));\n    guv.w = distance(uv, vec2(.0, .5));\n    if (uv.y<.5) {\n    guv.w = 1.-(distance(uv, vec2(1., .5)));\n    }\n    guv.y  = guv.w *2.;guv.y -=.3;\n    guv.w  = guv.w *6.;guv.w -=2.4;\n    guv = clamp(guv, vec4(0), vec4(1));\n    vec2 j = vec2(.5);\n    fragColor = vec4(0);\n    vec4 c;\n    mainImage0(c, fragCoord);\n    float s = float(AA);\n    float k;\n    for (k = s; k-- > .5;) {\n        mainImage0(c, fragCoord + j - .5);\n        fragColor += c;\n        j = fract(j + vec2(.755, .57).yx);\n    }\n    fragColor /= s;\n    fragColor.a = 1.;\n    \n    vec3 color = fragColor.rgb;\n    \n    color = atan(color);\n    fragColor = vec4(color, 1.0);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// ---------- Editable parameters ----------\nvec4 colour_1 = vec4(2,2,3, 1.0);  // replace with desired RGBA (0..1)\nvec4 colour_2 = vec4(0,0,0, 1.0);\nvec4 colour_3 = vec4(.0,0,.3, 1.0);\n\nfloat contrast = 1.0;      // tweak 0..2 (approx)\nfloat spin_amount = 1.0;   // 0..1\nfloat spin_time_mul = 1.5; // multiply iTime if you want spin to run faster/slower\n\n// ---------- Internal constants ----------\n#define PIXEL_SIZE_FAC 700.0\n#define SPIN_EASE 0.5\n\nfloat resLen(vec2 r){ return length(r); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 bguv = fragCoord.xy/iResolution.xy;\n    vec4 bgtex=texture(iChannel0, bguv, 0.);\n\n    fragCoord.x-=iResolution.x/4.;\n    vec2 screen_coords = fragCoord;\n    vec2 love_ScreenSize = iResolution.xy;\n\n    float pixel_size = resLen(love_ScreenSize) / PIXEL_SIZE_FAC;\n    vec2 uv = (floor(screen_coords * (1.0 / pixel_size)) * pixel_size - 0.5 * love_ScreenSize) \n              / resLen(love_ScreenSize) - vec2(0.12, 0.0);\n    float uv_len = length(uv);\n\n    float speed = (spin_time_mul * iTime * SPIN_EASE * 0.2) + 302.2;\n    float new_pixel_angle = atan(uv.y, uv.x) + speed \n                            - SPIN_EASE * 20.0 * (spin_amount * uv_len + (1.0 - spin_amount));\n    vec2 mid = (love_ScreenSize / resLen(love_ScreenSize)) / 2.0;\n    uv = vec2(uv_len * cos(new_pixel_angle) + mid.x,\n              uv_len * sin(new_pixel_angle) + mid.y) - mid;\n\n    uv *= 30.0;\n\n    speed = iTime * 2.0;\n    vec2 uv2 = vec2(uv.x + uv.y);\n\n    for(int i = 0; i < 5; i++) {\n        uv2 += sin(max(uv.x, uv.y)) + uv;\n        uv  += 0.5 * vec2(cos(5.1123314 + 0.353 * uv2.y + speed * 0.131121), \n                          sin(uv2.x - 0.113 * speed));\n        uv  -= cos(uv.x + uv.y) - sin(uv.x * 0.711 - uv.y);\n    }\n\n    float contrast_mod = (0.25 * contrast + 0.5 * spin_amount + 1.2);\n    float paint_res = min(2.0, max(0.0, length(uv) * 0.035 * contrast_mod));\n    float c1p = max(0.0, 1.0 - contrast_mod * abs(1.0 - paint_res));\n    float c2p = max(0.0, 1.0 - contrast_mod * abs(paint_res));\n    float c3p = 1.0 - min(1.0, c1p + c2p);\n\n    vec4 ret_col = (0.3 / contrast) * colour_1 \n                 + (1.0 - 0.3 / contrast) * (colour_1 * c1p \n                 + colour_2 * c2p \n                 + vec4(c3p * colour_3.rgb, c3p * colour_1.a));\n \n\n    fragColor = (bgtex*20. +  ret_col)/21.;\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "33syzM",
    "date": "1759419975",
    "viewed": 241,
    "name": "three.js challenge",
    "description": "From [url]https://x.com/threejs/status/1973620023974568360[/url]",
    "likes": 21,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "disc",
     "challenge",
     "twitter",
     "rods",
     "threejs"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#if HW_PERFORMANCE == 0\n// turn off multisampling on mobile\n#define AA 1\n#else\n// change this to 1 if it runs slowly, or increase it for more smoothness\n#define AA 2 \n#endif\n\nfloat sdCylinder(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat map(vec3 p) {\n    // Configuration\n    float spacingA = 0.45;        // Distance between rings\n    float spacingB = 0.5;         // Distance between rods\n    float rodRadius = 0.07;       // Radius of each rod\n    float rodHeight = 1.5;        // Height of each rod\n    int numRings = 12;            // Maximum ring index\n    \n    // Wave configuration\n    float waveTime = iTime * 0.9;\n    float maxRadius = (float(numRings) + 0.5) * spacingA;\n    float waveRadius = maxRadius * 0.5;\n    float waveAmplitude = 1.5;\n    float waveWidth = 2.5;\n    \n    // Two wave center positions\n    vec2 waveCenter1 = vec2(cos(waveTime), sin(waveTime)) * waveRadius;\n    vec2 waveCenter2 = -waveCenter1;\n    \n    // Get radial distance and angle\n    float radialDist = length(p.xz);\n    float angle = atan(p.z, p.x);\n    \n    // Special handling for ring 0 (center ring)\n    float minDist = 1e6;\n    \n    // Check ring 0 separately since it has special properties\n    if (radialDist < spacingA) {\n        float ringRadius = spacingA/1.7;\n        float numRods = 4.0;\n        float angleStep = 2.0 * 3.14159 / numRods;\n        \n        float rodIndex = floor(angle / angleStep + 0.5);\n        float rodAngle = rodIndex * angleStep;\n        \n        vec3 rodCenter = vec3(cos(rodAngle) * ringRadius, 0.0, sin(rodAngle) * ringRadius);\n        \n        // no wave here in the center.\n   \n        vec3 adjustedRodCenter = rodCenter;\n        minDist = sdCylinder(p - adjustedRodCenter, rodRadius, rodHeight);\n    }\n    \n    // Domain repetition for rings 1 to numRings\n    if (radialDist >= spacingA * 0.5) {\n        // Find the nearest ring index based on radial distance\n        float ring = round((radialDist - spacingA * 0.5) / spacingA);\n        ring = clamp(ring, 1.0, float(numRings));\n        \n        float ringRadius = (ring + 0.5) * spacingA;\n        float circumference = 2.0 * 3.14159 * ringRadius;\n        float numRods = floor((circumference / spacingB + 0.5) + (circumference * 2.0) - 9.4);\n        \n        // Angular domain repetition for rods in this ring\n        float angleStep = 2.0 * 3.14159 / numRods;\n        float rodIndex = floor(angle / angleStep + 0.5);\n        float rodAngle = rodIndex * angleStep;\n        \n        vec3 rodCenter = vec3(cos(rodAngle) * ringRadius, 0.0, sin(rodAngle) * ringRadius);\n        \n        // Calculate wave influence\n        vec2 rodPos2D = rodCenter.xz;\n        float dist1 = length(rodPos2D - waveCenter1);\n        float dist2 = length(rodPos2D - waveCenter2);\n        float minWaveDist = min(2.2, min(dist1, dist2));\n        \n        float wave = cos(minWaveDist / waveWidth * 3.14159) * 0.5 + 0.5;\n        wave = smoothstep(0.0, 1.0, wave);\n        float heightOffset = wave * waveAmplitude;\n        \n        vec3 adjustedRodCenter = rodCenter + vec3(0.0, heightOffset, 0.0);\n        float dist = sdCylinder(p - adjustedRodCenter, rodRadius, rodHeight);\n        minDist = min(minDist, dist);\n    }\n    \n    return minDist;\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\n\nvec3 lighting(vec3 p, vec3 normal, vec3 rayDir, vec3 lightPos) {\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 viewDir = -rayDir;\n    vec3 reflectDir = reflect(-lightDir, normal);\n    \n    float diff = max(dot(normal, lightDir), 0.0);\n    //float spec = pow(max(dot(viewDir, reflectDir), 0.0), 16.0);\n    \n    vec3 ambient = vec3(0.4);\n    vec3 diffuse = vec3(0.5) * diff;\n   // vec3 specular = vec3(0) * spec;\n    \n    return ambient + diffuse;// + specular;\n}\n\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 60; i++) {\n        vec3 p = ro + t * rd;\n        float d = map(p);\n        if (d < 0.001 || t > 50.0) break;\n        t += d/2.;\n    }\n    return t;\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float time = iTime * 0.3;\n    float camDist = 14.0;\n    float camHeight = 13.0;\n    vec3 ro = vec3(cos(time) * camDist, camHeight, sin(time) * camDist);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n    float t = raymarch(ro, rd);\n    vec3 bg = vec3(0.1, 0.1, 0.1);\n    vec3 color = bg;\n    \n    if (t < 40.0) {\n        vec3 p = ro + t * rd;\n        vec3 normal = calcNormal(p);\n        vec3 lightPos = vec3(0.0, 8.0, 0.0);\n        \n        color = lighting(p, normal, rd, lightPos)*(1.0+p.y/2.);\n        \n        // Add some fog for depth\n       //color = mix(color, bg, 1.0 - exp(-0.015 * t));\n    }\n    color = max(bg, color);\n    color = tanh(color*1.2);\n    fragColor = vec4(color, 1.0);\n}\n\n// multisampling\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = float(AA), k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  \n\n/* \n// old map code with for loop\nfloat map(vec3 p) {\n    float minDist = 1e6;\n    \n    // Configuration\n    float spacingA = 0.45;        // Distance between rings\n    float spacingB = 0.5;        // Distance between rods\n    float rodRadius = 0.07;     // Radius of each rod\n    float rodHeight = 1.5;      // Height of each rod\n    int numRings = 12;          // Fixed number of rings (0-12 = 13 rings total)\n    \n    // Wave configuration\n    float waveTime = iTime * 0.9;\n    float maxRadius = (float(numRings) + 0.5) * spacingA;\n    float waveRadius = maxRadius * 0.5; // Halfway between center and edge\n    float waveAmplitude = 1.5; // How much the rods rise\n    float waveWidth = 2.5; // Width of the wave effect\n    \n    // Two wave center positions (opposite each other)\n    vec2 waveCenter1 = vec2(cos(waveTime), sin(waveTime)) * waveRadius;\n    vec2 waveCenter2 = -waveCenter1; // Opposite side\n    \n    // Concentric rings starting from ring 0\n    for (int ring = 0; ring <= numRings; ring++) {\n        float numRods;\n        float ringRadius;\n        \n        if (ring == 0) {\n            // First ring has exactly 4 rods\n            numRods = 4.0;\n            ringRadius = spacingA/1.7;\n        } else {\n            ringRadius = (float(ring)+0.5) * spacingA;\n            float circumference = 2.0 * 3.14159 * ringRadius;\n            numRods = floor((circumference / spacingB + 0.5) + (circumference*2.) -9.4);\n        }\n        \n        // Calculate angle between rods\n        float angleStep = 2.0 * 3.14159 / numRods;\n        \n        // Get current angle\n        float angle = atan(p.z, p.x);\n        \n        // Find nearest rod in this ring using domain repetition\n        float rodIndex = floor(angle / angleStep + 0.5);\n        float rodAngle = rodIndex * angleStep;\n        \n        // Position of the rod center\n        vec3 rodCenter = vec3(cos(rodAngle) * ringRadius, 0.0, sin(rodAngle) * ringRadius);\n        \n        // Calculate wave influence on this rod\n        vec2 rodPos2D = rodCenter.xz;\n        float dist1 = length(rodPos2D - waveCenter1);\n        float dist2 = length(rodPos2D - waveCenter2);\n        float minWaveDist = min( 2.2, min(dist1, dist2));\n        \n        // Create smooth wave using cosine\n        float wave = cos(minWaveDist / waveWidth * 3.14159) * 0.5 + 0.5;\n        wave = smoothstep(0.0, 1.0, wave);\n        float heightOffset = wave * waveAmplitude;\n        \n        // Adjust rod center with height offset\n        vec3 adjustedRodCenter = rodCenter + vec3(0.0, heightOffset, 0.0);\n        \n        // Distance to this rod\n        float dist = sdCylinder(p - adjustedRodCenter, rodRadius, rodHeight);\n        minDist = min(minDist, dist);\n    }\n    \n    return minDist;\n}\n\n*/",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wXfyWH",
    "date": "1759539384",
    "viewed": 121,
    "name": "Extruded Apollonian fractal",
    "description": "Trying to recreate: [url]https://x.com/pickover/status/1973780504349639165[/url]\nFirst attempt using domain repetition for speed. Can probably do better",
    "likes": 14,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "inversion",
     "apollonian",
     "gasket",
     "reproduction",
     "extruded"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Colourful Apollonian III - short\" by FabriceNeyret2. https://shadertoy.com/view/cl3GDl\n//     and \"Colourful Apollonian III\"         by mla.            https://shadertoy.com/view/wdsfWX\nfloat ang;\nvec4 getApollonianColor(vec2 uv, vec2 interactionPoint) {\n    vec2 z = uv;\n    \n    float N = 3.;\n    float a = 3.14159/N;\n    float D = 1./cos(a);\n    float T = tan(a);\n    float K = D - T;\n    \n    float maxDepth = 20.;\n    float depth = 0.;\n    vec2 t = vec2(0);\n    float s = T*T;\n    \n    float outerBound = (D + T) / 3.77;\n    if (length(uv) > outerBound) {\n        return vec4(0, 0, 0, 0);\n    }\n    \n    if (length(interactionPoint) < outerBound && length(interactionPoint) > 0.01) {\n        s = dot(interactionPoint, interactionPoint);\n        vec2 invCenter = interactionPoint / s;\n        float invScale = 1./s - 1.;\n        z = (z - invCenter) / dot(z - invCenter, z - invCenter) * invScale + invCenter;\n    }\n    \n    s = T*T;\n    \n    for (; depth < maxDepth && length(z) > K; depth++) {\n        z *= -K / dot(z,z);\n        \n        for (float j = 0.; j++ < N;) {\n            t = D * sin(6.28*j/N + vec2(0,1.57));\n            if (length(z-t) < T) {\n                z = (z-t) / dot(z-t,z-t) * s + t;\n                j = N;\n            }\n        }\n    }\n    \n    float alpha = 0.0;\n    if (length(z) < K) alpha = 1.0;\n    \n    for (float j = 0.; j < N; j++) {\n        vec2 center = D * sin(6.28*j/N + vec2(0,1.57));\n        if (length(z - center) < T) alpha = 1.0;\n    }\n    \n    if (alpha < 0.05 || depth > 19.9 || (ang>0.3&&ang<1.6)) {\n        return vec4(0.0);\n    }\n    \n    vec3 color = 0.5 + 0.5 * cos(depth * 0.5 + vec3(0, 2.1, 4.2));\n    return vec4(color, 1.0);\n}\n\nfloat sdTorusDisks(vec3 p, out float diskIndex) {\n    float torusRadius = 1.5;\n    float diskRadius = 0.55;\n    float diskThickness = 0.005;\n    float spacing = 0.005;\n    \n    float angle = atan(p.z, p.x);\n    \n    float nearestDiskAngle = round(angle / spacing) * spacing;\n    diskIndex = nearestDiskAngle / spacing; \n    \n    float c = cos(-nearestDiskAngle);\n    float s = sin(-nearestDiskAngle);\n    vec3 pRot;\n    pRot.x = c * p.x - s * p.z;\n    pRot.y = p.y;\n    pRot.z = s * p.x + c * p.z;\n\n    float distAlongRadius = pRot.x - torusRadius;\n    float distInDisk = length(vec2(distAlongRadius, pRot.y)) - diskRadius;\n    \n    return max(distInDisk, abs(pRot.z) - diskThickness);\n}\n\nvoid mainImage0(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy;\n    vec2 uv = (u - 0.5*R) / R.y;\n    \n    vec3 ro = vec3(3.33, 1.5, 4.5);\n    vec3 ta = vec3(0, 0, 0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = cross(uu, ww);\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 2.0*ww);\n    \n    float t = 0.0;\n    vec3 col = vec3(0.05);\n    \n    for (int i = 0; i < 220; i++) {\n        vec3 p = ro + rd * t;\n        \n        float diskIndex;\n        float d = sdTorusDisks(p, diskIndex);\n        float angle = atan(p.z, p.x);\n        ang = angle;\n        if (d < 0.001) {\n            float r = length(p.xz);\n            vec2 diskUV = vec2(r - 1.5, p.y);\n            \n            vec2 interactionPoint = vec2(\n                sin(angle+iTime/2.) * 0.6,\n                cos(angle+iTime/1.7) * 0.6\n            );\n            \n            vec4 gasket = getApollonianColor(diskUV*2.2, interactionPoint);\n            \n            if (gasket.a > 0.1) {\n                col = gasket.rgb;\n                \n                col *= 0.9 + 0.1 * sin(diskIndex * 0.001);\n                \n                vec3 n = normalize(vec3(p.x, 0, p.z));\n                float diff = 0.7 + 0.3 * dot(n, normalize(vec3(1, 1, 0)));\n                col *= diff;\n            } else {\n                t += 0.01;\n                continue;\n            }\n            break;\n        }\n        \n        t += max(d, 0.0001);\n        if (t > 20.0) break;\n    }\n    \n    O = vec4(col, 1.0);\n}\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s =2., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wXXyD7",
    "date": "1759709717",
    "viewed": 128,
    "name": "Warped Apollonian fractal",
    "description": "Trying to recreate: [url]https://x.com/pickover/status/1973780504349639165[/url]\nEnded up with this. Kinda off target but I'll take it",
    "likes": 9,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "psychedelic",
     "inversion",
     "apollonian",
     "gasket",
     "reproduction",
     "extruded"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Extruded Apollonian fractal\"      by Cotterzz.       https://shadertoy.com/view/wXfyWH\n// Fork of \"Colourful Apollonian III - short\" by FabriceNeyret2. https://shadertoy.com/view/cl3GDl\n//     and \"Colourful Apollonian III\"         by mla.            https://shadertoy.com/view/wdsfWX\n#if HW_PERFORMANCE == 0\n// turn off multisampling on mobile\n#define AA 1\n#else\n// change this to 1 if it runs slowly, or increase it for more smoothness\n#define AA 2 \n#endif\nfloat ang;\nfloat hgt;\n\nfloat getApollonianHeight(vec2 uv, vec2 interactionPoint) {\n    vec2 z = uv;\n    \n    float N = 3.;\n    float a = 3.14159/N;\n    float D = 1./cos(a);\n    float T = tan(a);\n    float K = D - T;\n    \n    float maxDepth = 20.;\n    float depth = 0.;\n    vec2 t = vec2(0);\n    float s = T*T;\n    \n    float outerBound = (D + T) / 3.77;\n    if (length(uv) > outerBound) {\n        return 0.0;\n    }\n    \n    if (length(interactionPoint) < outerBound && length(interactionPoint) > 0.01) {\n        s = dot(interactionPoint, interactionPoint);\n        vec2 invCenter = interactionPoint / s;\n        float invScale = 1./s - 1.;\n        z = (z - invCenter) / dot(z - invCenter, z - invCenter) * invScale + invCenter;\n    }\n    \n    s = T*T;\n    \n    for (; depth < maxDepth && length(z) > K; depth++) {\n        z *= -K / dot(z,z);\n        \n        for (float j = 0.; j++ < N;) {\n            t = D * sin(6.28*j/N + vec2(0,1.57));\n            if (length(z-t) < T) {\n                z = (z-t) / dot(z-t,z-t) * s + t;\n                j = N;\n            }\n        }\n    }\n    \n    float alpha = 0.0;\n    if (length(z) < K) alpha = 1.0;\n    \n    // Calculate distance to nearest circle boundary\n    float minDist = length(z) - K;  // Distance to center circle boundary\n    \n    for (float j = 0.; j < N; j++) {\n        vec2 center = D * sin(6.28*j/N + vec2(0,1.57));\n        float dist = abs(length(z - center) - T);  // Distance to this circle's boundary\n        minDist = min(minDist, dist);\n        if (length(z - center) < T) alpha = 1.0;\n    }\n    \n if (alpha < 0.05 || depth > 19.9 || (ang>0.3&&ang<1.6)) {\n        return 0.0;\n    }\n    \n    // Convert distance to height - closer to boundary = raised edge\n    // Use a smooth falloff for the circular ridges\n    float height = exp(-minDist * 8.0) * (1.0 + depth * 0.1);\n    \n    return height;\n}\n\nvec4 getApollonianColor(vec2 uv, vec2 interactionPoint) {\n    vec2 z = uv;\n    \n    float N = 3.;\n    float a = 3.14159/N;\n    float D = 1./cos(a);\n    float T = tan(a);\n    float K = D - T;\n    \n    float maxDepth = 20.;\n    float depth = 0.;\n    vec2 t = vec2(0);\n    float s = T*T;\n    \n    float outerBound = (D + T) / 3.77;\n    if (length(uv) > outerBound) {\n        return vec4(0, 0, 0, 0);\n    }\n    \n    if (length(interactionPoint) < outerBound && length(interactionPoint) > 0.01) {\n        s = dot(interactionPoint, interactionPoint);\n        vec2 invCenter = interactionPoint / s;\n        float invScale = 1./s - 1.;\n        z = (z - invCenter) / dot(z - invCenter, z - invCenter) * invScale + invCenter;\n    }\n    \n    s = T*T;\n    \n    for (; depth < maxDepth && length(z) > K; depth++) {\n        z *= -K / dot(z,z);\n        \n        for (float j = 0.; j++ < N;) {\n            t = D * sin(6.28*j/N + vec2(0,1.57));\n            if (length(z-t) < T) {\n                z = (z-t) / dot(z-t,z-t) * s + t;\n                j = N;\n            }\n        }\n    }\n    \n    float alpha = 0.0;\n    if (length(z) < K) alpha = 1.0;\n    \n       // Calculate distance to nearest circle boundary\n    float minDist = length(z) - K;  // Distance to center circle boundary\n    \n    for (float j = 0.; j < N; j++) {\n        vec2 center = D * sin(6.28*j/N + vec2(0,1.57));\n        float dist = abs(length(z - center) - T);  // Distance to this circle's boundary\n        minDist = min(minDist, dist);\n        if (length(z - center) < T) alpha = 1.0;\n    }\n    \n    if (alpha < 0.05 || depth > 19.9 || (ang>0.3&&ang<1.6)) {\n        hgt = 0.;\n        return vec4(0.0);\n    }\n    hgt= exp(-minDist * 8.0) * (1.0 + depth * 0.1);\n    \n    vec3 color = 0.5 + 0.5 * cos(depth * 0.5 + vec3(0, 2.1, 4.2));\n    return vec4(color, 1.0);\n    \n}\n\nfloat sdTorusDisks(vec3 p, out float diskIndex) {\n    float torusRadius = 1.5;\n    float diskRadius = 0.55;\n    float diskThickness = 0.001;\n    float spacing = 0.001;\n    \n    float angle = atan(p.z, p.x);\n    \n    float nearestDiskAngle = round(angle / spacing) * spacing;\n    diskIndex = nearestDiskAngle / spacing; \n    \n    float c = cos(-nearestDiskAngle);\n    float s = sin(-nearestDiskAngle);\n    vec3 pRot;\n    pRot.x = c * p.x - s * p.z;\n    pRot.y = p.y;\n    pRot.z = s * p.x + c * p.z;\n\n    float distAlongRadius = pRot.x - torusRadius;\n    float distInDisk = length(vec2(distAlongRadius, pRot.y)) - diskRadius;\n    \n    return max(distInDisk, abs(pRot.z) - diskThickness);\n}\n\nvoid mainImage0(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy;\n    vec2 uv = (u - 0.5*R) / R.y;\n    \n    vec3 ro = vec3(3.33, 1.5, 4.5);\n    vec3 ta = vec3(0, 0, 0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = cross(uu, ww);\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 2.0*ww);\n    \n    float t = 0.0;\n    vec3 col = vec3(0.05);\n    \n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        \n        float diskIndex;\n        float d = sdTorusDisks(p, diskIndex);\n        float angle = atan(p.z, p.x);\n        ang = angle;\n        if (d < 0.001) {\n            float r = length(p.xz);\n            vec2 diskUV = vec2(r - 1.5, p.y);\n            \n            vec2 interactionPoint = vec2(\n                sin(angle+iTime*1.5) * mix(0.2, vv.y, (sin(iTime/2.3)+1.)/2.),\n                cos(angle+iTime/1.7) * mix( vv.y,0.2, (sin(iTime/2.3)+1.)/2.)\n            );\n            \n            vec4 gasket = getApollonianColor(diskUV*2.2, interactionPoint);\n            \n            if (gasket.a > 0.1) {\n                col = gasket.rgb;\n                \n                col *= 0.9 + 0.1 * sin(diskIndex * 0.001);\n                \n                // Calculate normal from fractal height map using bump mapping\n                float uvScale = 2.2;\n                float bumpStrength = 0.1;  // Increased for more visible effect\n                float epsilon = 0.0001;\n                \n                // Sample fractal height at center and neighbors\n                float heightC = hgt;\n                float heightR = getApollonianHeight((diskUV + vec2(epsilon, 0)) * uvScale, interactionPoint);\n                //float heightU = getApollonianHeight((diskUV + vec2(0, epsilon)) * uvScale, interactionPoint);\n                \n                // Calculate gradients (slopes) from height differences\n                vec2 gradient = vec2(heightR - heightC, heightR - heightC) / epsilon;\n                \n                // Base normal (radial from torus center)\n                vec3 baseNormal = normalize(vec3(p.x, 0, p.z));\n                \n                // Create tangent space basis aligned with disk surface\n                vec3 tangent = normalize(cross(baseNormal, vec3(0, 1, 0)));\n                vec3 bitangent = normalize(cross(baseNormal, tangent));\n                \n                // Perturb normal with fractal height gradients\n                vec3 n = normalize(baseNormal + bumpStrength * (gradient.x * tangent + gradient.y * bitangent));\n                \n                vec3 lightDir1 = normalize(vec3(1, 1, 1));\n                vec3 lightDir2 = normalize(vec3(2, -2, -1));\n                vec3 rimLight = normalize(vec3(1, 0, 3));\n                \n                float diff1 = max(0.0, dot(n, lightDir1));\n                float diff2 = max(0.0, dot(n, lightDir2)) * 0.4;\n                float rim = pow(1.0 - abs(dot(n, normalize(-rd))), 2.0) * 0.3;\n                \n                \n                float ao = 0.7 + heightC * 0.3;\n                \n                \n                float lighting = 0.4 + 0.3 * diff1 + 0.1 * diff2 + rim;\n                col *= lighting * ao;\n            } else {\n                t += 0.01;\n                continue;\n            }\n            break;\n        }\n        \n        t += max(d/1.5, 0.01);\n        if (t > 20.0) break;\n    }\n    \n    O = vec4(tanh(col), 1.0);\n}\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = float(AA), k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXlyzB",
    "date": "1759804621",
    "viewed": 83,
    "name": "Cymatics V1",
    "description": "Click on slider to switch to interactive mode.",
    "likes": 8,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "waves",
     "frequency",
     "cymatics",
     "vibration"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "void mainImage(out vec4 color, in vec2 fragCoord)\n{\n    // Read slider values from Buffer A\n    vec3 sliderValues = vec3(\n        texelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r,\n        texelFetch(iChannel0, ivec2(2, 0), 0).r\n    );\n    \n    // Center the coordinates\n    vec2 uv = fragCoord - iResolution.xy * 0.5;\n    uv *= 35./iResolution.y;\n    // Interactive parameters from sliders\n    float waveSpacing = 1.5 + sliderValues.x * 20.0;\n    float centralFreq = 0.1 + sliderValues.y * 20.0;\n    float outerFreq = 0.7 + sliderValues.z * 2.0; \n    // Track waves separately for coloring\n    float centerWave = sin(length(uv) * centralFreq);\n    float topWave = sin(length(uv + vec2(0.0, waveSpacing)) * outerFreq);\n    float bottomWave = sin(length(uv + vec2(0.0, -waveSpacing)) * outerFreq);\n    float leftWave = sin(length(uv + vec2(-waveSpacing, 0.0)) * outerFreq);\n    float rightWave = sin(length(uv + vec2(waveSpacing, 0.0)) * outerFreq);\n    // Group waves by axis\n    float verticalWaves = topWave + bottomWave;\n    float horizontalWaves = leftWave + rightWave; \n    // Total interference pattern\n    float totalWaves = centerWave + topWave + bottomWave + leftWave + rightWave;\n    totalWaves = totalWaves * 0.2 + 0.5; \n    vec3 waveColor = vec3(\n        0.5 + 0.5 * horizontalWaves / 2.0,\n        0.5 + 0.5 * verticalWaves / 2.0,\n        0.5 + 0.5 * centerWave\n    );\n    vec3 finalColor = mix(vec3(0.0), waveColor, smoothstep(0.3, 0.7, totalWaves));\n    // Soft circular vignette\n    float dist = length(uv);\n    float circleMask = 1.0 - smoothstep(15.0, 16.5, dist);\n    finalColor *= circleMask;\n    // Draw sliders on top\n    vec2 sliderPos = vec2(iResolution.x - 90.0, 10.0);\n    float sliderWidth = 15.0;\n    float sliderHeight = 120.0;\n    float sliderSpacing = 30.0;\n    \n    for (int i = 0; i < 3; i++) {\n        vec2 thisSliderPos = sliderPos + vec2(float(i) * sliderSpacing, 0.0);\n        // Slider background\n        if (fragCoord.x > thisSliderPos.x && fragCoord.x < thisSliderPos.x + sliderWidth &&\n            fragCoord.y > thisSliderPos.y && fragCoord.y < thisSliderPos.y + sliderHeight) {\n            finalColor = vec3(0.15); \n            // Slider fill\n            if (fragCoord.y < thisSliderPos.y + sliderValues[i] * sliderHeight) {\n                finalColor = vec3(0.6, 0.6, 0.7); \n            }\n        }\n        // Slider outline\n        if (fragCoord.x > thisSliderPos.x - 1.0 && fragCoord.x < thisSliderPos.x + sliderWidth + 1.0 &&\n            fragCoord.y > thisSliderPos.y - 1.0 && fragCoord.y < thisSliderPos.y + sliderHeight + 1.0 &&\n            (fragCoord.x < thisSliderPos.x || fragCoord.x > thisSliderPos.x + sliderWidth ||\n             fragCoord.y < thisSliderPos.y || fragCoord.y > thisSliderPos.y + sliderHeight)) {\n            finalColor = vec3(0.4);\n        }\n    }\n    color = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 color, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Slider configuration\n    vec2 sliderPos = vec2(iResolution.x - 90.0, 10.0);\n    float sliderWidth = 25.0;  // Bigger click area\n    float sliderHeight = 120.0;\n    float sliderSpacing = 30.0;\n    \n    // Read previous state\n    vec3 sliderValues = vec3(\n        texelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r,\n        texelFetch(iChannel0, ivec2(2, 0), 0).r\n    );\n    float hasInteracted = texelFetch(iChannel0, ivec2(3, 0), 0).r;\n    \n    if (iFrame < 1) {\n        sliderValues = vec3(0.5, 0.5, 0.5);\n        hasInteracted = 0.0;\n    }\n    \n    if (hasInteracted < 0.5) {\n        sliderValues.x = 0.5 + 0.5 * sin(iTime * 0.7); \n        sliderValues.y = 0.5 + 0.5 * sin(iTime * 1.3); \n        sliderValues.z = 0.5 + 0.5 * sin(iTime * 2.1);  \n    }\n    \n    if (iMouse.z > 0.0) {\n        vec2 mouse = iMouse.xy;\n        \n        for (int i = 0; i < 3; i++) {\n            vec2 thisSliderPos = sliderPos + vec2(float(i) * sliderSpacing, 0.0);\n            \n            if (mouse.x > thisSliderPos.x && mouse.x < thisSliderPos.x + sliderWidth &&\n                mouse.y > thisSliderPos.y && mouse.y < thisSliderPos.y + sliderHeight) {\n                \n                float newValue = clamp((mouse.y - thisSliderPos.y) / sliderHeight, 0.0, 1.0);\n                sliderValues[i] = newValue;\n                hasInteracted = 1.0; \n            }\n        }\n    }\n    \n    // Store values in first 4 pixels\n    if (fragCoord.y < 1.0) {\n        if (fragCoord.x < 1.0) color = vec4(sliderValues.x, 0, 0, 1);\n        else if (fragCoord.x < 2.0) color = vec4(sliderValues.y, 0, 0, 1);\n        else if (fragCoord.x < 3.0) color = vec4(sliderValues.z, 0, 0, 1);\n        else if (fragCoord.x < 4.0) color = vec4(hasInteracted, 0, 0, 1);\n        else color = vec4(0);\n    } else {\n        color = vec4(0);\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXsyRS",
    "date": "1759804644",
    "viewed": 92,
    "name": "Extruded Cymatic",
    "description": "Something a bit different.",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "cymatic",
     "extruded"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Cymatics V1\" by Cotterzz. https://shadertoy.com/view/WXlyzB\n// Fork of \"Extruded Apollonian fractal\" by Cotterzz. https://shadertoy.com/view/wXfyWH\n// Fork of \"Colourful Apollonian III - short\" by FabriceNeyret2. https://shadertoy.com/view/cl3GDl\n//     and \"Colourful Apollonian III\"         by mla.            https://shadertoy.com/view/wdsfWX\n\nfloat ang;\nvec4 getCymaticColor(vec2 uv, vec3 inpt){\n    uv *= 0.1; // Scale down for better view\n    if (length(uv) > 16.) {return vec4(0);};\n    // Interactive parameters\n    float waveSpacing = inpt.x;  // Distance of outer sources\n    float centralFreq = inpt.y;  // Central wave frequency\n    float outerFreq = inpt.z;                      // Animated outer frequency    \n    \n    // Track waves separately for coloring\n    float centerWave = sin(length(uv) * centralFreq);\n    \n    float topWave = sin(length(uv + vec2(0.0, waveSpacing)) * outerFreq);\n    float bottomWave = sin(length(uv + vec2(0.0, -waveSpacing)) * outerFreq);\n    float leftWave = sin(length(uv + vec2(-waveSpacing, 0.0)) * outerFreq);\n    float rightWave = sin(length(uv + vec2(waveSpacing, 0.0)) * outerFreq);\n    \n    // Group waves by axis\n    float verticalWaves = topWave + bottomWave;\n    float horizontalWaves = leftWave + rightWave;\n    \n    // Total interference pattern\n    float totalWaves = centerWave + topWave + bottomWave + leftWave + rightWave;\n    totalWaves = pow(totalWaves, .1)*2.;\n    //totalWaves = totalWaves * 0.2 + 0.5;\n   \n    \n    // Option 2: Color by dominant direction\nvec3 waveColor = vec3(\n    0.5 + 0.5 * horizontalWaves / 2.0,  // Red: horizontal\n    0.5 + 0.5 * verticalWaves / 2.0,    // Green: vertical\n    0.5 + 0.5 * centerWave              // Blue: center\n);\n\n    \n    // Mix between black and colored based on total wave intensity\n    // This keeps the dark interference patterns black\n   vec3 finalColor = waveColor;//mix(vec3(0.0), waveColor, smoothstep(0.5, 0.6, totalWaves));\n    //vec3 finalColor = mix(vec3(0.0), waveColor, smoothstep(0.3, 0.7, totalWaves));\n     //vec3 finalColor = mix(vec3(0.0), waveColor, totalWaves);\n     \n    if (totalWaves < 0.01 || (ang>0.0&&ang<1.6)) {\n        return vec4(0.0);\n    }\n    \n    return vec4(finalColor, totalWaves);\n\n}\n\n\n\nfloat sdTorusDisks(vec3 p, out float diskIndex) {\n    float torusRadius = 1.5;\n    float diskRadius = 0.55;\n    float diskThickness = 0.0005;\n    float spacing = 0.0005;\n    \n    float angle = atan(p.z, p.x);\n    \n    float nearestDiskAngle = round(angle / spacing) * spacing;\n    diskIndex = nearestDiskAngle / spacing; \n    \n    float c = cos(-nearestDiskAngle);\n    float s = sin(-nearestDiskAngle);\n    vec3 pRot;\n    pRot.x = c * p.x - s * p.z;\n    pRot.y = p.y;\n    pRot.z = s * p.x + c * p.z;\n\n    float distAlongRadius = pRot.x - torusRadius;\n    float distInDisk = length(vec2(distAlongRadius, pRot.y)) - diskRadius;\n    \n    return max(distInDisk, abs(pRot.z) - diskThickness);\n}\n\nvoid mainImage0(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy;\n    vec2 uv = (u - 0.5*R) / R.y;\n    \n    vec3 ro = vec3(-3.6, 1.0, -3.6);\n    vec3 ta = vec3(0, 0, 0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = cross(uu, ww);\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 2.0*ww);\n    \n    float t = 0.0;\n    vec3 col = vec3(0.05);\n    \n    for (int i = 0; i < 220; i++) {\n        vec3 p = ro + rd * t;\n        \n        float diskIndex;\n        float d = sdTorusDisks(p, diskIndex);\n        float angle = 3.1416+atan(p.z, p.x);\n        ang = angle;\n        if (d < 0.01) {\n            float r = length(p.xz);\n            vec2 diskUV = vec2(r - 1.5, p.y);\n            \n                // Interactive parameters\n\n            \n            vec3 interactionPoint = vec3(\n    1.5 + (sin((angle+iTime)/2.1)+1.) * 10.0,  // Distance of outer sources\n     0.01 + (sin((angle+iTime)/3.1)+1.) * 5.0,  // Central wave frequency\n   1.3 + (sin((angle+iTime)/4.1)+1.) * 0.6      // Animated outer frequency  \n                \n            );\n            \n            vec4 gasket = getCymaticColor(diskUV*220., interactionPoint);\n            \n            if (gasket.a > 0.8) {\n                col = (col + gasket.rgb * gasket.a)/2.;\n                \n   \n            } else if (gasket.a > 0.01) {\n                col = (col + gasket.rgb * gasket.a)/2.;\n                \n\n                t += 0.01;\n                continue;\n            } else {\n                t += 0.01;\n                continue;\n            }\n            break;\n        }\n        \n        t += max(d, 0.001);\n        if (t > 20.0) break;\n    }\n    col=tanh(col);\n    O = vec4(col, 1.0);\n}\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s =2., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "t3fyzj",
    "date": "1759848749",
    "viewed": 100,
    "name": "Cymatics V2 - w/Audio",
    "description": "so... audio vis seems like the best use for this...\nClick on slider to switch to interactive mode.\nSliders: wave speed, reflection strength, visual gain and time smoothing",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "waves",
     "audio",
     "visualisation",
     "frequency",
     "cymatics",
     "vibration",
     "chaldni",
     "faradaywaves"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "// IF AUDIO DOESNT PLAY CLICK ON BUFFER A UP HERE ^^\n// AND THEN HIT PLAY/PAUSE ON ICHANNEL1 BELOW vv\n\n\n// Fork of \"Cymatics V1\" by Cotterzz. https://shadertoy.com/view/WXlyzB\n\nfloat getAudioSample(sampler2D buffer, float sampleOffset, vec2 resolution) {\n    int totalOffset = int(sampleOffset) % 512;  // Wrap around 512 samples\n    int row = 1 + (totalOffset / int(resolution.x));\n    int col = totalOffset % int(resolution.x);\n    \n    if (row <= 8 && col < int(resolution.x)) {\n        return texelFetch(buffer, ivec2(col, row), 0).r * 2.0 - 1.0;  \n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n    // Read slider values from Buffer A\n    vec4 sliderValues = vec4(\n        texelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r,\n        texelFetch(iChannel0, ivec2(2, 0), 0).r,\n        texelFetch(iChannel0, ivec2(3, 0), 0).r\n    );\n    \n    // Center the coordinates\n    vec2 uv = fragCoord - iResolution.xy * 0.5;\n    uv *= 35./iResolution.y;\n    \n    // Interactive parameters from sliders\n    float waveSpeed = 5.0 + sliderValues.x * 20.0;        // Wave propagation speed\n    float reflectionStrength = sliderValues.y;            // Reflection intensity\n    float visualGain = 1.0 + sliderValues.z * 4.0;       // Visualization sensitivity\n    \n    // Define virtual sound sources\n    vec2 source1 = vec2(0.0, 0.0);      // Center\n    vec2 source2 = vec2(-12.0, 0.0);    // Left\n    vec2 source3 = vec2(12.0, 0.0);     // Right\n    vec2 source4 = vec2(0.0, -12.0);    // Bottom\n    vec2 source5 = vec2(0.0, 12.0);     // Top\n    \n    // Calculate sample delay based on distance (in sample units)\n    // Assuming ~60fps and 44100Hz audio, each frame has ~735 samples\n    // But we only get 512, so scale accordingly\n    float sampleRate = 512.0; // samples per frame\n    \n    float delay1 = length(uv - source1) * waveSpeed;\n    float delay2 = length(uv - source2) * waveSpeed;\n    float delay3 = length(uv - source3) * waveSpeed;\n    float delay4 = length(uv - source4) * waveSpeed;\n    float delay5 = length(uv - source5) * waveSpeed;\n    \n    // Get audio samples at each delay\n    float wave1 = getAudioSample(iChannel0, delay1, iResolution.xy);\n    float wave2 = getAudioSample(iChannel0, delay2, iResolution.xy) * reflectionStrength * 0.8;\n    float wave3 = getAudioSample(iChannel0, delay3, iResolution.xy) * reflectionStrength * 0.8;\n    float wave4 = getAudioSample(iChannel0, delay4, iResolution.xy) * reflectionStrength * 0.7;\n    float wave5 = getAudioSample(iChannel0, delay5, iResolution.xy) * reflectionStrength * 0.7;\n    \n    // Create interference pattern\n    float totalWaves = (wave1 + wave2 + wave3 + wave4 + wave5) * visualGain;\n    \n    // Add some continuous wave effect based on accumulated phase\n    float phase = totalWaves * 10.0 + iTime * 2.0;\n    float continuousWave = sin(length(uv) * 0.5 + phase);\n    \n    // Mix direct audio with continuous visualization\n    totalWaves = totalWaves * 0.7 + continuousWave * 0.3 * abs(totalWaves);\n    \n    // Create color based on wave components\n    vec3 waveColor = vec3(\n        0.5 + 0.3 * (wave2 + wave3),  // Horizontal (red channel)\n        0.5 + 0.3 * (wave4 + wave5),  // Vertical (green channel)\n        0.5 + 0.5 * wave1              // Center (blue channel)\n    );\n    \n    // Apply wave intensity\n    float intensity = 0.5 + 0.5 * tanh(totalWaves);\n    vec3 finalColor = waveColor * intensity;\n    \n    // Add contour lines for cymatic pattern emphasis\n    float contourLines = abs(fract(totalWaves * 3.0 + 0.5) - 0.5);\n    finalColor *= 0.6 + 0.4 * smoothstep(0.1, 0.2, contourLines);\n    \n    // Circular boundary\n    float dist = length(uv);\n    float circleMask = 1.0 - smoothstep(15.0, 16.5, dist);\n    finalColor *= circleMask;\n    \n    // Draw sliders\n    vec2 sliderPos = vec2(iResolution.x -120.0, 10.0);\n    float sliderWidth = 15.0;\n    float sliderHeight = 120.0;\n    float sliderSpacing = 30.0;\n    \n    for (int i = 0; i < 4; i++) {\n        vec2 thisSliderPos = sliderPos + vec2(float(i) * sliderSpacing, 0.0);\n        \n        if (fragCoord.x > thisSliderPos.x && fragCoord.x < thisSliderPos.x + sliderWidth &&\n            fragCoord.y > thisSliderPos.y && fragCoord.y < thisSliderPos.y + sliderHeight) {\n            finalColor = vec3(0.15);\n            \n            if (fragCoord.y < thisSliderPos.y + sliderValues[i] * sliderHeight) {\n                finalColor = vec3(0.6, 0.6, 0.7);\n            }\n        }\n        \n        if (fragCoord.x > thisSliderPos.x - 1.0 && fragCoord.x < thisSliderPos.x + sliderWidth + 1.0 &&\n            fragCoord.y > thisSliderPos.y - 1.0 && fragCoord.y < thisSliderPos.y + sliderHeight + 1.0 &&\n            (fragCoord.x < thisSliderPos.x || fragCoord.x > thisSliderPos.x + sliderWidth ||\n             fragCoord.y < thisSliderPos.y || fragCoord.y > thisSliderPos.y + sliderHeight)) {\n            finalColor = vec3(0.4);\n        }\n    }\n    //finalColor *=2.;\n    finalColor = tanh(pow(finalColor*1.8, vec3(1.8)));\n    \n    \n    //color = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);//vec4(finalColor, 1.0);\n    color = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4df3Rn",
       "filepath": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3",
       "type": "music",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// IF AUDIO DOESNT PLAY CLICK ON BUFFER A UP HERE ^^\n// AND THEN HIT PLAY/PAUSE ON ICHANNEL1 BELOW vv\n\n\n\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Slider configuration\n    vec2 sliderPos = vec2(iResolution.x - 120.0, 10.0);\n    float sliderWidth = 25.0;\n    float sliderHeight = 120.0;\n    float sliderSpacing = 30.0;\n    \n    // Read previous state from row 0\n    vec4 sliderValues = vec4(\n        texelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r,\n        texelFetch(iChannel0, ivec2(2, 0), 0).r,\n        texelFetch(iChannel0, ivec2(3, 0), 0).r\n    );\n    float hasInteracted = texelFetch(iChannel0, ivec2(4, 0), 0).r;\n    \n    if (iFrame < 1) {\n        sliderValues = vec4(0.5);\n        hasInteracted = 0.0;\n    }\n    \n    if (hasInteracted < 0.5) {\n        sliderValues.x = 0.5 + 0.3 * sin(iTime / 3.7); \n        sliderValues.y = 0.5 + 0.3 * sin(iTime / 4.3); \n        sliderValues.z = 0.5 + 0.3 * sin(iTime / 2.1);  \n        sliderValues.w = 0.5 + 0.3 * sin(iTime / 2.1); \n    }\n    float v4 = pow(sliderValues.w, 3.);\n    float s4 = 15.;\n    \n    if (iMouse.z > 0.0) {\n        vec2 mouse = iMouse.xy;\n        \n        for (int i = 0; i < 4; i++) {\n            vec2 thisSliderPos = sliderPos + vec2(float(i) * sliderSpacing, 0.0);\n            \n            if (mouse.x > thisSliderPos.x && mouse.x < thisSliderPos.x + sliderWidth &&\n                mouse.y > thisSliderPos.y && mouse.y < thisSliderPos.y + sliderHeight) {\n                \n                float newValue = clamp((mouse.y - thisSliderPos.y) / sliderHeight, 0.0, 1.0);\n                sliderValues[i] = newValue;\n                hasInteracted = 1.0; \n            }\n        }\n    }\n    \n    ivec2 coord = ivec2(fragCoord);\n    \n    if (coord.y == 0) {\n        // Row 0: Store slider values\n        if (coord.x == 0) color = vec4(sliderValues.x, 0, 0, 1);\n        else if (coord.x == 1) color = vec4(sliderValues.y, 0, 0, 1);\n        else if (coord.x == 2) color = vec4(sliderValues.z, 0, 0, 1);\n        else if (coord.x == 3) color = vec4(sliderValues.w, 0, 0, 1);\n        else if (coord.x == 4) color = vec4(hasInteracted, 0, 0, 1);\n        else color = vec4(0);\n    }\n    else if (coord.y >= 1 ) { // incresa to 20 just in case we need it.\n        // Rows 1-8: Store current frame's 512 audio samples\n        // Map pixel position to audio sample index\n        int row = coord.y - 1;  // 0-7\n        int sampleIndex = row * int(iResolution.x) + coord.x;\n        \n        if (sampleIndex < 512) {\n            // Store current frame's audio sample\n            float audioSample = texture(iChannel1, vec2(float(sampleIndex) / 512.0, 1.0)).r;\n            audioSample = pow(audioSample*1.2, 1.2);\n            color = (vec4(audioSample, audioSample, audioSample, 1.0) + texelFetch(iChannel0, ivec2(coord.x, coord.y + 1), 0)*(v4 * s4))/((v4 * s4)+1.);\n        } else {\n            // Beyond 512 samples, store previous frame's data for rolling history\n            // Shift data from row above (previous frame position)\n            if (coord.y > 1) {\n                color = texelFetch(iChannel0, ivec2(coord.x, coord.y - 1), 0);\n            } else {\n                color = vec4(0);\n            }\n        }\n    }\n    else {\n        color = vec4(0);\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXXcRl",
    "date": "1759992665",
    "viewed": 58,
    "name": "Audio from Image",
    "description": "Turns image to audio as if it were a frequency-time graph in reverse.",
    "likes": 7,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fft",
     "audio",
     "synthesis",
     "dsp",
     "spectrograph"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// I wanted to make a shadertoy version of this very old webaudio experiment: https://www.johnc.pro/spectrogram/\n// (You can draw and play the sound of your drawing using additive synthesis, turning the spectrograph back into sound.)\n// But this is not possible on shadertoy because the buffers aren't connected, so sound isnt interactive.\n\n// However, next best thing is a way to play any predefined drawing.\n// Replace drawFunction in common and both the image and sound tabs will display and play it!\n// Try the three modes to see examples\n// You can create sound using SDFs or anything that returns meaningful values in the 0-1 range.\n// You can even use the passed time data to change the output over time.\n// Frequency range is logarithminc so musical notes are the same distance apart.\n// Sound fidelity has it's limits, this is just a toy really.\n// I'm sure it can be improved a lot, my DSP knowledge is rudimentary. Open to ideas.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = drawFunction(uv, iTime);\n    float scanX = mod(iTime, DURATION) / DURATION;\n    float scanLine = step(0.995, 1.-abs(uv.x - scanX));\n    col = mix(col, vec3(1.0, 0.0, 0.0), scanLine);  \n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec2 mainSound( int samp, float time )\n{\n    vec3 t = vec3(float(samp-1) / SAMPLE_RATE , float(samp) / SAMPLE_RATE , float(samp+1) / SAMPLE_RATE );\n    vec3 x = mod(t, DURATION) / DURATION;\n    \n    float sampl = 0.0;\n    \n    // Sample vertically across frequencies\n    for (int row = 0; row < NUM_SAMPLES; row++) {\n        float y = float(row) / float(NUM_SAMPLES);\n        \n        // Sample at exact x position (no need to interpolate between columns)\n        vec3 pixel = vec3(drawFunction(vec2(x.x, y), t.x).r ,  drawFunction(vec2(x.y, y), t.y).r , drawFunction(vec2(x.z, y), t.z).r ) ; \n        pixel = clamp(pixel, 0., 1.);\n        \n        vec3 brightness = 1.0 - pixel;\n\n        float freq = frequencyFromY(y);\n        \n        vec3 triple = brightness * sin(TWO_PI * freq * fract(t));\n        \n        if(triple.x == 0. && abs(triple.y)>0.4) { triple.y /=4.; }\n        \n        if(triple.z == 0. && abs(triple.y)>0.4) { triple.y /=4.; }\n        \n        sampl += triple.y;\n        \n    }\n    \n    // Soft clip using tanh - compresses loudness gracefully\n    sampl= tanh(sampl * 0.5);\n    \n    return vec2(sampl);\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// 0 - custom\n// 1 - musical notes\n// 2 - wavy lines\n// 3 - animated noise long compile time\n\n#define MODE 1\n\nconst float DURATION = 6.0;\nconst float SAMPLE_RATE = 44100.0;\nconst float MIN_FREQ = 16.0;\nconst float MAX_FREQ = 16000.0;\nconst int NUM_SAMPLES = 240;\nconst float TWO_PI = 6.283185307;\nfloat frequencyFromY(float y) {return floor(MIN_FREQ * pow(2.0, y * log(MAX_FREQ / MIN_FREQ) / log(2.0)));}\nfloat freqToY(float freq) {return log(freq / MIN_FREQ) / log(MAX_FREQ / MIN_FREQ);}\n\n#if MODE == 0\n\nvec3 drawFunction(vec2 uv, float t) { //use this function to draw whatever you like\n\n    vec3 col = vec3(1);\n    return col;\n}\n\n#endif\n\n#if MODE == 1\nfloat noteToFreq(int noteIndex) {\n    // F# F# D B E  G# G# A B A A D F#  F#  E E F# E\n    if (noteIndex == 0) return 369.99;  // F#4\n    if (noteIndex == 1) return 369.99;  // F#4\n    if (noteIndex == 2) return 293.66;  // D4\n    if (noteIndex == 3) return 246.94;  // B3 (low)\n    if (noteIndex == 4) return 329.63;  // E4\n    if (noteIndex == 5) return 415.30;  // G#4\n    if (noteIndex == 6) return 415.30;  // G#4\n    if (noteIndex == 7) return 440.00;  // A4\n    if (noteIndex == 8) return 493.88;  // B4 (high)\n    if (noteIndex == 9) return 440.00;  // A4\n    if (noteIndex == 10) return 440.00; // A4\n    if (noteIndex == 11) return 293.66; // D4\n    if (noteIndex == 12) return 369.99; // F#4\n    if (noteIndex == 13) return 369.99; // F#4\n    if (noteIndex == 14) return 329.63; // E4\n    if (noteIndex == 15) return 329.63; // E4\n    if (noteIndex == 16) return 369.99; // F#4\n    return 329.63; // E4\n}\n\nvec3 testFunction(vec2 uv) {  //take on me.\n    vec3 col = vec3(1.0);\n    int numNotes = 18;\n    float noteDuration = 1.0 / float(numNotes);\n    int noteIndex = int(uv.x / noteDuration) % numNotes;\n    float freq = noteToFreq(noteIndex);\n    float y = freqToY(freq);\n    float notePos = fract(uv.x / noteDuration);\n    float noteEnd = 0.3;\n    float fadeIn = smoothstep(0.0, 0.7, notePos);\n    float fadeOut = smoothstep(noteEnd, noteEnd + 0.7, notePos);\n    float envelope = fadeIn * (1.0 - fadeOut);\n    if (abs(uv.y - y) < 0.004) {\n        col = mix(vec3(1.0), vec3(0.0), envelope);\n    }\n    return col;\n}\n\nvec3 drawFunction(vec2 uv, float t) { \n    vec3 col = testFunction(uv);\n    return col;\n}\n\n#endif\n\n#if MODE == 2\n\nvec3 testFunction(vec2 uv) {\n    vec3 col = vec3(1.0); \n    float curveOffset = 0.15;\n    float y = 0.45;\n    // Upper curves\n    float curve1 = y + curveOffset + 0.05 * sin(uv.x * 20.0);\n    float curve2 = y + curveOffset * 2.0 + 0.05 * cos(uv.x * 15.0);\n    \n    // Lower curves\n    float curve3 = y - curveOffset - 0.05 * sin(uv.x * 18.0);\n    float curve4 = y - curveOffset * 2.0 - 0.05 * cos(uv.x * 12.0);\n    \n    if (abs(uv.y - curve1) < 0.003) {col = vec3(abs(uv.y - curve1)/0.003);}\n    if (abs(uv.y - curve2) < 0.009) {col = vec3(abs(uv.y - curve2)/0.009);}\n    if (abs(uv.y - curve3) < 0.02) {col = vec3(abs(uv.y - curve3)/0.02);}\n    if (abs(uv.y - curve4) < 0.005) {col = vec3(abs(uv.y - curve4)/0.005);}\n    return col;\n}\n\nvec3 drawFunction(vec2 uv, float t) { \n    vec3 col = testFunction(uv);\n    return col;\n}\n\n#endif\n\n\n#if MODE == 3\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector.\n\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec2 gradientDirection(uint hash) {\n    switch (int(hash) & 3) { // look at the last two bits to pick a gradient direction\n    case 0:\n        return vec2(1.0, 1.0);\n    case 1:\n        return vec2(-1.0, 1.0);\n    case 2:\n        return vec2(1.0, -1.0);\n    case 3:\n        return vec2(-1.0, -1.0);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, vec2 t) {\n    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);\n}\n\nvec2 fade(vec2 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec2 position, uint seed) {\n    vec2 floorPosition = floor(position);\n    vec2 fractPosition = position - floorPosition;\n    uvec2 cellCoordinates = uvec2(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 0)), seed)), fractPosition - vec2(1.0, 0.0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec2(0, 1)), seed)), fractPosition - vec2(0.0, 1.0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 1)), seed)), fractPosition - vec2(1.0, 1.0));\n    return interpolate(value1, value2, value3, value4, fade(fractPosition));\n}\n\nfloat perlinNoise(vec2 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < 4; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\nvec3 drawFunction(vec2 uv, float t) { \n\n   vec3 col = vec3(   perlinNoise(uv+vec2(t/5.,t/10.), 1, 6, 0.5, 2.0, 45u)   )+sqrt(uv.y);\n    return col;\n}\n\n#endif",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXsczs",
    "date": "1760057925",
    "viewed": 157,
    "name": "Wavetable Synth",
    "description": "Sadly this can't be interactive because of site limitations, but it really is playing the wavetable it's displaying.\nIf you want to change the texture, make sure you change it in all three buffers.\nIt may get out of sync, if it does restart it.",
    "likes": 24,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "audio",
     "synthesis",
     "wavetable",
     "dsp"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float yoffset = 0.5+sin(iTime)/2.;\n    \n    // Get the buffer contents\n    vec3 col = texture(iChannel0, uv).rgb;\n    uv+=0.1;\n    // Highlighted slice position (at 0.5)\n    float highlightPos = yoffset;\n    \n    // Draw highlighted slice with matching isometric transformation\n    vec2 centerUV = (uv - vec2(0.5, 0.5)) * 2.5;\n    \n    // Isometric projection for highlighted slice\n    float isoX = highlightPos * 0.6;  // Move right\n    float isoY = highlightPos * 0.9;  // Move up\n    \n    // Calculate x position in waveform from screen position\n    float waveX = ((centerUV.x - isoX) / 1.2) + 0.5;\n    \n    if(waveX >= 0.0 && waveX <= 1.0) {\n        float waveValue = wavetable(vec2(waveX, highlightPos), iChannel1, iTime);\n        \n        // y position: wave amplitude + isometric offset\n        float posY = waveValue * 0.25 + isoY;\n        \n        // Distance from current pixel\n        float dist = abs(centerUV.y - posY);\n        float lineThickness = 0.012;\n        float glowRadius = 0.04;\n        \n        if(dist < glowRadius) {\n            float intensity = 0.0;\n            \n            // Core line\n            if(dist < lineThickness) {\n                intensity = 1.0;\n            } else {\n                // Glow\n                intensity = 1.0 - (dist - lineThickness) / (glowRadius - lineThickness);\n                intensity *= 0.6;\n            }\n            \n            col += vec3(0.7, 1.0, 0.7) * intensity;\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Wavetable functions\nfloat wavetabletest(vec2 uv) {\n    float x = uv.x;  // Phase (0-1)\n    float y = uv.y;  // Table position (0-1)\n    \n    // Ensure continuity at boundaries\n    float phase = x * 2.0 * 3.14159265359;\n    \n    if (y < 0.5) {\n        // Interpolate between sine and square\n        float t = y * 2.0;  // 0 to 1 for first half\n        \n        // Sine wave\n        float sine = sin(phase);\n        \n        // Square wave (bandlimited with a few harmonics)\n        float square = 0.0;\n        for(int i = 1; i <= 7; i += 2) {\n            square += sin(phase * float(i)) / float(i);\n        }\n        square *= 4.0 / 3.14159265359;\n        \n        return mix(sine, square, t);\n    } else {\n        // Interpolate between square and complex wave\n        float t = (y - 0.5) * 4.0;  // 0 to 1 for second half\n        \n        // Square wave\n        float square = 0.0;\n        for(int i = 1; i <= 7; i += 2) {\n            square += sin(phase * float(i)) / float(i);\n        }\n        square *= 4.0 / 3.14159265359;\n        \n        // Complex wave (multiple harmonics)\n        float complex = sin(phase) * 0.5 +           // Fundamental\n                       sin(phase * 2.0) * 0.3 +      // 2nd harmonic\n                       sin(phase * 3.0) * 0.15 +     // 3rd harmonic\n                       sin(phase * 5.0) * 0.05;      // 5th harmonic\n        \n        return mix(square, complex, t);\n    }\n}\n\nfloat wavetable_metallic(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start harmonic, become increasingly inharmonic\n    float wave = sin(phase);\n    \n    // Add inharmonic partials\n    wave += sin(phase * 2.1) * 0.5 * y;\n    wave += sin(phase * 3.3) * 0.3 * y;\n    wave += sin(phase * 4.7) * 0.2 * y;\n    wave += sin(phase * 6.2) * 0.15 * y;\n    wave += sin(phase * 7.9) * 0.1 * y;\n    \n    return wave / (1.0 + y);\n}\n\nfloat wavetable_fold(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start with sine\n    float wave = sin(phase);\n    \n    // Apply wave folding - increases with y\n    float foldAmount = 1.0 + y * 4.0;\n    wave *= foldAmount;\n    \n    // Fold the wave\n    wave = abs(fract(wave * 0.25 + 0.5) * 2.0 - 1.0) * 2.0 - 1.0;\n    \n    return wave;\n}\n\nfloat wavetableTex(vec2 uv, sampler2D bmp) {\n    vec4 tex = texture(bmp, uv, 0.);\n   return ((tex.r +tex.g +tex.b)*.6666)-1.;\n}\nfloat wavetable_bitcrush(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start with clean sine\n    float wave = sin(phase);\n    \n    // Reduce bit depth as y increases\n    float bits = 5.0 - y * 7.0; // From 16-bit to 1-bit\n    float steps = pow(2.0, bits);\n    \n    wave = floor(wave * steps) / steps;\n    \n    return wave;\n}\nfloat wavetable_vowel(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Different formant frequencies for vowel sounds\n    float wave = 0.0;\n    \n    if (y < 0.25) {\n        // A to E\n        float t = y * 4.0;\n        // A: 730, 1090, 2440\n        float a = sin(phase) + 0.5*sin(phase*1.5) + 0.3*sin(phase*3.3);\n        // E: 530, 1840, 2480\n        float e = sin(phase) + 0.4*sin(phase*3.5) + 0.3*sin(phase*4.7);\n        wave = mix(a, e, t);\n        \n    } else if (y < 0.5) {\n        // E to I\n        float t = (y - 0.25) * 4.0;\n        float e = sin(phase) + 0.4*sin(phase*3.5) + 0.3*sin(phase*4.7);\n        // I: 270, 2290, 3010\n        float i = sin(phase) + 0.3*sin(phase*8.5) + 0.2*sin(phase*11.2);\n        wave = mix(e, i, t);\n        \n    } else if (y < 0.75) {\n        // I to O\n        float t = (y - 0.5) * 4.0;\n        float i = sin(phase) + 0.3*sin(phase*8.5) + 0.2*sin(phase*11.2);\n        // O: 570, 840, 2410\n        float o = sin(phase) + 0.5*sin(phase*1.5) + 0.2*sin(phase*4.2);\n        wave = mix(i, o, t);\n        \n    } else {\n        // O to U\n        float t = (y - 0.75) * 4.0;\n        float o = sin(phase) + 0.5*sin(phase*1.5) + 0.2*sin(phase*4.2);\n        // U: 440, 1020, 2240\n        float u = sin(phase) + 0.4*sin(phase*2.3) + 0.2*sin(phase*5.1);\n        wave = mix(o, u, t);\n    }\n    \n    return wave * 0.6; // Normalize\n}\nfloat wavetable_morph(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    if (y < 0.333) {\n        // Sine to Triangle\n        float t = y * 3.0;\n        float sine = sin(phase);\n        float triangle = asin(sin(phase)) * 2.0 / 3.14159265359;\n        return mix(sine, triangle, t);\n        \n    } else if (y < 0.666) {\n        // Triangle to Sawtooth\n        float t = (y - 0.333) * 3.0;\n        float triangle = asin(sin(phase)) * 2.0 / 3.14159265359;\n        float saw = (fract(x) * 2.0 - 1.0);\n        return mix(triangle, saw, t);\n        \n    } else {\n        // Sawtooth to Square\n        float t = (y - 0.666) * 3.0;\n        float saw = (fract(x) * 2.0 - 1.0);\n        \n        // Square wave (bandlimited)\n        float square = 0.0;\n        for(int i = 1; i <= 7; i += 2) {\n            square += sin(phase * float(i)) / float(i);\n        }\n        square *= 4.0 / 3.14159265359;\n        \n        return mix(saw, square, t);\n    }\n}\nfloat wavetable_harmonic(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start with sine, add harmonics as y increases\n    float wave = sin(phase);\n    \n    // Add harmonics progressively\n    int maxHarmonics = int(1.0 + y * 15.0);\n    for(int i = 2; i <= 16; i++) {\n        if(i <= maxHarmonics) {\n            float amplitude = 1.0 / float(i);\n            wave += sin(phase * float(i)) * amplitude;\n        }\n    }\n    \n    // Normalize\n    return wave / (1.0 + y * 2.0);\n}\nfloat wavetable_harmonic2(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    float outp = sin(phase) * 0.5;  // Fundamental always present\n    \n    // Gradually add harmonics based on table position\n    int numHarmonics = int(y * 12.0) + 1;\n    \n    for(int i = 2; i <= numHarmonics && i <= 12; i++) {\n        float harmAmp = (1.0 / float(i)) * (1.0 - float(i - 2) / 11.0 * 0.5);\n        outp += sin(phase * float(i)) * harmAmp * y;\n    }\n    \n    return outp / (1.0 + y * 0.5);  // Normalize\n}\nfloat wavetable_pwm(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Pulse width varies from 10% to 90%\n    float pulseWidth = 0.1 + y * 0.8;\n    \n    // Generate pulse wave using fourier series\n    float wave = 0.0;\n    for(int i = 1; i <= 9; i++) {\n        float n = float(i);\n        wave += (sin(n * 3.14159265359 * pulseWidth) / n) * sin(n * phase);\n    }\n    wave *= 2.0 / 3.14159265359;\n    \n    return wave;\n}\nfloat wavetable_pwm2(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Pulse width varies from 10% to 90%\n    float pulseWidth = 0.1 + y * 0.8;\n    \n    // Bandlimited pulse wave\n    float pulse = 0.0;\n    for(int i = 1; i <= 10; i++) {\n        pulse += sin(phase * float(i)) * sin(float(i) * 3.14159265359 * pulseWidth) / float(i);\n    }\n    pulse *= 4.0 / 3.14159265359;\n    \n    return pulse;\n}\nfloat wavetableclassic(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    if (y < 0.5) {\n        // Saw to Triangle\n        float t = y * 2.0;\n        \n        // Bandlimited saw wave\n        float saw = 0.0;\n        for(int i = 1; i <= 10; i++) {\n            saw += sin(phase * float(i)) / float(i);\n        }\n        saw *= -2.0 / 3.14159265359;\n        \n        // Triangle wave\n        float triangle = asin(sin(phase)) * 2.0 / 3.14159265359;\n        \n        return mix(saw, triangle, t);\n    } else {\n        // Triangle to Sine\n        float t = (y - 0.5) * 2.0;\n        float triangle = asin(sin(phase)) * 2.0 / 3.14159265359;\n        float sine = sin(phase);\n        return mix(triangle, sine, t);\n    }\n}\nfloat wavetablevoc(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    if (y < 0.33) {\n        // \"Ooh\" formant (darker)\n        float t = y * 3.0;\n        float ooh = sin(phase) * 0.8 + \n                   sin(phase * 2.0) * 0.15 * (1.0 - t) +\n                   sin(phase * 3.0) * 0.05;\n        return ooh;\n    } else if (y < 0.66) {\n        // \"Aah\" formant (brighter)\n        float t = (y - 0.33) * 3.0;\n        float aah = sin(phase) * 0.5 +\n                   sin(phase * 2.0) * 0.3 +\n                   sin(phase * 4.0) * 0.15 +\n                   sin(phase * 5.0) * 0.05;\n        return aah * (1.0 + t * 0.2);\n    } else {\n        // \"Eeh\" formant (brightest)\n        float t = (y - 0.66) * 3.0;\n        float eeh = sin(phase) * 0.4 +\n                   sin(phase * 3.0) * 0.3 +\n                   sin(phase * 5.0) * 0.2 +\n                   sin(phase * 7.0) * 0.1;\n        return eeh;\n    }\n}\nfloat wavetablebell(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start with fundamental\n    float outp = sin(phase) * (1.0 - y * 0.5);\n    \n    // Add increasingly inharmonic partials\n    outp += sin(phase * 2.7) * y * 0.3;   // Minor third-ish\n    outp += sin(phase * 4.2) * y * 0.2;   // Between harmonics\n    outp += sin(phase * 5.4) * y * 0.15;  // Metallic partial\n    outp += sin(phase * 7.8) * y * 0.1;   // Bell-like partial\n    \n    if (y > 0.5) {\n        float t = (y - 0.5) * 2.0;\n        outp += sin(phase * 9.3) * t * 0.08;\n        outp += sin(phase * 11.7) * t * 0.05;\n    }\n    \n    return outp;\n}\nfloat wavetabledist(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    float sine = sin(phase);\n    float drive = 1.0 + y * 10.0;  // Increase overdrive with y\n    \n    // Soft to hard clipping\n    float clipped = sine * drive;\n    \n    if (y < 0.5) {\n        // Soft clipping (tanh-like)\n        clipped = tanh(clipped * 2.0) * 0.9;\n    } else {\n        // Harder clipping\n        clipped = clamp(clipped, -1.0, 1.0);\n        // Add some harmonics back for bandlimiting\n        float t = (y - 0.5) * 2.0;\n        clipped = mix(tanh(sine * drive * 2.0), \n                     sign(sine) * pow(abs(sine), 0.3 - t * 0.2), \n                     t) * 0.9;\n    }\n    \n    return clipped;\n}\nfloat wavetable(vec2 uv, sampler2D bmp, float time) {\n    float period = time/6.2832;\n    int num = int(floor(period));\n    num = num%15;\n    float sampl;\n    \n    switch (num){\n        case 0: sampl = wavetablebell(uv); break;\n        case 1: sampl = wavetableTex(uv, bmp); break;\n        case 2: sampl = wavetabletest(uv); break;\n        case 3: sampl = wavetable_metallic(uv); break;\n        case 4: sampl = wavetable_fold(uv) ; break;\n        case 5: sampl = wavetable_bitcrush(uv) ; break;\n        case 6: sampl = wavetable_vowel(uv) ; break;\n        case 7: sampl = wavetable_morph(uv) ; break;\n        case 8: sampl = wavetable_harmonic(uv) ; break;\n        case 9: sampl = wavetable_harmonic2(uv) ; break;\n        case 10: sampl = wavetable_pwm(uv) ; break;\n        case 11: sampl = wavetable_pwm2(uv); break;\n        case 12: sampl = wavetableclassic( uv) ; break;\n        case 13: sampl = wavetablevoc(uv) ; break;\n        case 14: sampl = wavetabledist(uv) ; break;\n    }\n    \n   return clamp( sampl  , -1.,1.);\n}\n\n\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Only render on first frame, if the wavetable stays the same.\n    if (iFrame > 0) {\n        //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        //return;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0.0);\n    uv+=0.1;\n    // Main wavetable display (isometric view)\n    vec2 centerUV = (uv - vec2(0.5, 0.5)) * 2.5;\n    vec2 proj = vec2(0.6,0.9);\n    // Draw reference grid below (at -1.5)\n    for(int i = 0; i < 50; i++) {\n        float tablePos = float(i) / 49.0;\n        \n        // Isometric projection\n        float isoX = tablePos * proj.x;  // Move right\n        float isoY = tablePos * proj.y;  // Move up\n        \n        // Calculate x position from screen position\n        float waveX = ((centerUV.x - isoX) / 1.2) + 0.5;\n        \n        // Check if we're within the valid range\n        if(waveX >= 0.0 && waveX <= 1.0) {\n            // Reference grid at constant -1.5\n            float refValue = -1.5;\n            float posY = refValue * 0.25 + isoY;\n            \n            // Distance from current pixel\n            float dist = abs(centerUV.y - posY);\n            float lineThickness = 0.006 / (1.0 + tablePos * 0.3); // Perspective\n            \n            if(dist < lineThickness) {\n                float intensity = 1.0 - dist / lineThickness;\n                // Fade lines towards the back\n                intensity *= 1.0 - tablePos * 0.4;\n                // Darker green for reference grid\n                col += vec3(0.0, 0.3, 0.0) * intensity * 0.5;\n            }\n        }\n    }\n    \n    // Draw vertical lines from base to waveform\n    for(int i = 0; i < 30; i++) {\n        float tablePos = float(i) / 29.0;\n        \n        // Isometric projection\n        float isoX = tablePos * proj.x;  // Move right\n        float isoY = tablePos * proj.y;  // Move up\n        \n        // Calculate x position from screen position\n        float waveX = ((centerUV.x - isoX) / 1.2) + 0.5;\n        \n        // Check if we're within the valid range\n        if(waveX >= 0.0 && waveX <= 1.05) {\n            // Sample every few pixels for vertical lines\n            float xMod = mod(waveX * 100.0, 5.0);\n            if(xMod < 0.5) {\n                float waveValue = wavetable(vec2(waveX, tablePos), iChannel1, iTime);\n                \n                // Base and top positions\n                float baseY = -1.5 * 0.25 + isoY;\n                float topY = waveValue * 0.25 + isoY;\n                \n                // Check if we're between base and top\n                float minY = min(baseY, topY);\n                float maxY = max(baseY, topY);\n                \n                if(centerUV.y >= minY && centerUV.y <= maxY) {\n                    float lineThickness = 0.003 / (1.0 + tablePos * 0.3);\n                    float intensity = 1.0 - tablePos * 0.5;\n                    if(waveX<0.05||waveX>0.99){intensity*=2.;}\n                    col += vec3(0.0, 0.35, 0.0) * intensity *0.2;\n                }\n            }\n        }\n    }\n    \n    // Draw wavetable on top\n    for(int i = 0; i < 30; i++) {\n        float tablePos = float(i) / 29.0;\n        \n        // Isometric projection\n        float isoX = tablePos * proj.x;  // Move right\n        float isoY = tablePos * proj.y;  // Move up\n        \n        // Calculate x position in waveform from screen position\n        float waveX = ((centerUV.x - isoX) / 1.2) + 0.5;\n        \n        // Check if we're within the valid waveform range\n        if(waveX >= 0.0 && waveX <= 1.0) {\n            float waveValue = wavetable(vec2(waveX, tablePos), iChannel1, iTime);\n            \n            // y position: wave amplitude + isometric offset\n            float posY = waveValue * 0.25 + isoY;\n            \n            // Distance from current pixel\n            float dist = abs(centerUV.y - posY);\n            float lineThickness = 0.008 / (1.0 + tablePos * 0.3); // Perspective\n            \n            if(dist < lineThickness) {\n                float intensity = 1.0 - dist / lineThickness;\n                // Fade lines towards the back\n                intensity *= 1.0 - tablePos * 0.4;\n                if(waveX<0.05&&waveX>0.99){intensity*=3.;}\n                col += vec3(0.0, 0.7, 0.0) * intensity;\n            }\n        }\n    }\n    uv-=0.1;\n    // 2D bitmap view in corner (properly square with aspect ratio correction)\n    float cornerSize = 0.2;\n    vec2 cornerPos = vec2(0.05, 0.75); // Bottom left corner\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    // Correct for aspect ratio to make it square\n    vec2 cornerUV = (uv - cornerPos);\n    cornerUV.x *= aspectRatio;\n    cornerUV /= cornerSize;\n    \n    if(cornerUV.x >= 0.0 && cornerUV.x <= 1.0 && \n       cornerUV.y >= 0.0 && cornerUV.y <= 1.0) {\n        float sampl = wavetable(cornerUV, iChannel1, iTime);\n        // Map -1 to 1 to dark green to light green\n        float intensity = sampl * 0.5 + 0.5;\n        col = vec3(0.0, 0.2 + intensity * 0.6, 0.0);\n    }\n    \n    fragColor = vec4(tanh(col), 1.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "vec2 mainSound( int samp, float time )\n{\n    // Audio playback rate\n    float frequency = 262.0; // C3\n    float sampleRate = 44100.0;\n    \n    // Phase accumulator\n    float phase = fract(time * frequency);\n    \n    // Use middle position of wavetable (y = 0.5)\n    float tablePos = 0.5+sin(time)/2.;\n    \n    // Get sample from wavetable\n    float sampl = wavetable(vec2(phase, tablePos), iChannel0, time);\n    \n    return vec2(sampl);\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXsyW2",
    "date": "1760218728",
    "viewed": 195,
    "name": "Wavetable Synth V2",
    "description": "Second version with smooth wavetable blending and a rotating volumetric wavetable courtesy of 01000001\nSpeeds up after a while..\nRewind if sound stops or it gets out of sync.",
    "likes": 21,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "audio",
     "synthesis",
     "wavetable",
     "dsp"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sf3Rr",
       "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"vol vox box\" by 01000001. https://shadertoy.com/view/wfySzh\n// Fork of \"Wavetable Synth\" by Cotterzz. https://shadertoy.com/view/WXsczs\n\nconst float pi = 3.14159;\nconst float eps = 1e-4;\nfloat pc = 3.5;\nint lines = 50;\n#define flines float(lines)\nfloat offset;\nvec3 voxel(vec3 p){\n//p = floor(p*flines)/flines;\n\nfloat h = wavetable(vec2(p.x, p.y), iChannel0, iTime);\n\nvec3 col = vec3(0);\nfloat mul = 2.;\nint dom = 0;\n//h = (h+1.5)/5.;\nh+=1.5;\nh/=3.;\nif(h>(p.z) && p.y<offset) {col = vec3(0,0.3,0);dom+=1;}\n\nif(h>(p.z) &&abs(p.y-offset)<0.01){\n    col = vec3(0,1,0);mul *= 10.;dom+=2;\n  } else if(h>(p.z) &&(p.y<0.01||(p.x>0.99&&p.y<offset)||(p.x<0.01&&p.y<offset))){\n    col = vec3(0,1,0);mul *= 5.;\n  }\nif(abs(h-p.z)<0.01){ mul *= 30./max(0.001,(-5.*(p.y-offset)));dom+=4;}\n\nif(dom==7){col = vec3(1,1,1);}\n\n\nreturn col*mul;}\n\n\nfloat planeRay(vec3 ro, vec3 rd, vec3 norm, float d){\n    float a = dot(ro, norm)-d, b = dot(norm, -rd);\n    if (b < 0. && a > 0.) return 1e9;\n    return a / b;\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b){\n    float x = min(length(uv-a),length(uv-b));\n    vec2 v = normalize(b-a);\n    if (dot(v, uv-a) > 0. && dot(v, uv-a) < length(a-b)) x = min(x, abs(dot(uv-a, v.yx*vec2(-1,1)))); \n    return x;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    float SPEED = 1.2 + iTime/50.;\n    offset = 0.5+sin(iTime*SPEED)/2.05;\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv =( iMouse.xy == vec2(0)|| length(iMouse.xy)<50.)?vec2(iTime/5., -.2):(2.*iMouse.xy-r)/r.y;\n    O = vec4(0);\n\n    vec2 camM = muv*(pi/2. - 1e-3);\n    vec3 camF = vec3(sin(camM.x)*cos(camM.y), cos(camM.x)*cos(camM.y), sin(camM.y));\n    vec3 camR = vec3(cos(camM.x), sin(-camM.x), 0);\n    vec3 camU = cross(camR, camF);\n    \n    vec3 o = vec3(.5) - 3.*camF;\n    \n    vec3[8] p;\n    float vx,vy,vz;\n    for (int i = 0; i < 8; i++){\n        vx = dot(camR, vec3(i>>2, (i>>1)%2, i%2)-o);\n        vy = dot(camU, vec3(i>>2, (i>>1)%2, i%2)-o);\n        vz = dot(camF, vec3(i>>2, (i>>1)%2, i%2)-o);\n        p[i] = vec3(vx,vy, vz/pc);\n    } // vertex shader lol\n    \n    float d = 1e4;\n    \n    vec3 a,b;\n    \n    //*\n    for (int z = 0; z <= lines; z+=lines){\n        for (int x = 1; x < lines; x++){\n            float fx = float(x)/flines;\n            float fz = float(z)/flines;\n            a = mix(mix(p[0], p[1], fz), mix(p[4], p[5], fz), fx);\n            b = mix(mix(p[2], p[3], fz), mix(p[6], p[7], fz), fx);\n\n            d = min(d, line(cuv, a.xy / a.z, b.xy / b.z));\n\n\n            a = mix(mix(p[4], p[5], fz), mix(p[6], p[7], fz), fx);\n            b = mix(mix(p[0], p[1], fz), mix(p[2], p[3], fz), fx);\n\n            d = min(d, line(cuv, a.xy / a.z, b.xy / b.z));\n        }\n    }\n    //*/\n    \n    float x = .1 * \n    //smoothstep(2./r.y, 0., d);\n    exp(-pow(d / (2./r.y), 2.));\n    // gaussian instead of smoothstep nearly eliminates moire\n\n    d = 1e4;\n    // Outlines\n    //*\n    d = min(d, line(cuv, p[0].xy / p[0].z, p[2].xy / p[2].z));\n    d = min(d, line(cuv, p[2].xy / p[2].z, p[6].xy / p[6].z));\n    d = min(d, line(cuv, p[6].xy / p[6].z, p[4].xy / p[4].z));\n    d = min(d, line(cuv, p[4].xy / p[4].z, p[0].xy / p[0].z));\n    \n    d = min(d, line(cuv, p[1].xy / p[1].z, p[3].xy / p[3].z));\n    d = min(d, line(cuv, p[3].xy / p[3].z, p[7].xy / p[7].z));\n    d = min(d, line(cuv, p[7].xy / p[7].z, p[5].xy / p[5].z));\n    d = min(d, line(cuv, p[5].xy / p[5].z, p[1].xy / p[1].z));\n    \n    d = min(d, line(cuv, p[0].xy / p[0].z, p[1].xy / p[1].z));\n    d = min(d, line(cuv, p[2].xy / p[2].z, p[3].xy / p[3].z));\n    d = min(d, line(cuv, p[6].xy / p[6].z, p[7].xy / p[7].z));\n    d = min(d, line(cuv, p[4].xy / p[4].z, p[5].xy / p[5].z));\n    //*/\n\n    x = mix(x, .8, smoothstep(3./r.y, 0., d));\n    \n        \n    vec3 norm, dir = camF + camR * cuv.x/pc + camU*cuv.y/pc;\n    float t,dis,tempT,maxT,minT;\n    vec4 v;\n\n    maxT = 0.; minT = 1e9;\n    for (int q = 0; q < 6; q++){\n        norm *= 0.;\n        norm[q%3] = q%6<3?-1.:1.;\n        dis = q<3?0.:1.;\n        tempT = planeRay(o, dir, norm, dis);\n        if (dot(o, norm)-dis > 0.){\n            maxT = max(maxT, tempT);\n        } else {\n            if (tempT > 0.) minT = min(minT, tempT);\n        }\n    }\n    t = maxT * flines;\n    \n    if (minT - maxT > 0.) {\n        \n        float d;\n        vec3 p,v=vec3(0);\n        bvec3 sides = bvec3(dir.x > 0., dir.y > 0., dir.z > 0.);\n        vec3 dists;\n\n        for (int i = 0; i < 512; i++){\n            p = o*flines + dir*t;\n\n            if (\n                   p.x > flines + eps\n                || p.y > flines + eps\n                || p.z > flines + eps\n                || p.x < -eps \n                || p.y < -eps\n                || p.z < -eps\n            ) break; // prevents loop unrolling too. \n\n            vec3 vox = voxel(p/flines);\n            \n            for (int q = 0; q < 3; q++){\n                dists[q] = (sides[q]?ceil(p[q])-p[q]:floor(p[q])-p[q])/dir[q];\n            }\n\n            d = min(dists.x, min(dists.y, dists.z));\n\n            t += d + max(t*1e-5, 1e-4);\n            \n            v += d * max(vec3(0), vox);\n\n        }\n\n        O.xyz += (1.-exp(-v*.02));\n\n    }\n    // 2D bitmap view in corner (properly square with aspect ratio correction)\n    float cornerSize = 0.2;\n    vec2 cornerPos = vec2(0.05, 0.75); // Bottom left corner\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    // Correct for aspect ratio to make it square\n    vec2 cornerUV = (uv - cornerPos);\n    cornerUV.x *= aspectRatio;\n    cornerUV /= cornerSize;\n    \n    if(cornerUV.x >= 0.0 && cornerUV.x <= 1.0 && \n       cornerUV.y >= 0.0 && cornerUV.y <= 1.0) {\n        float sampl = wavetable(cornerUV, iChannel0, iTime);\n        // Map -1 to 1 to dark green to light green\n        float intensity = sampl * 0.5 + 0.5;\n       O = vec4(0.0, 0.2 + intensity * 0.6, 0.0, 1.0);\n    }\n    O += vec4(pow(x, 1./2.2));    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\n\n// Wavetable functions\nfloat wavetabletest(vec2 uv) {\n    float x = uv.x;  // Phase (0-1)\n    float y = uv.y;  // Table position (0-1)\n    \n    // Ensure continuity at boundaries\n    float phase = x * 2.0 * 3.14159265359;\n    \n    if (y < 0.5) {\n        // Interpolate between sine and square\n        float t = y * 2.0;  // 0 to 1 for first half\n        \n        // Sine wave\n        float sine = sin(phase);\n        \n        // Square wave (bandlimited with a few harmonics)\n        float square = 0.0;\n        for(int i = 1; i <= 7; i += 2) {\n            square += sin(phase * float(i)) / float(i);\n        }\n        square *= 4.0 / 3.14159265359;\n        \n        return mix(sine, square, t);\n    } else {\n        // Interpolate between square and complex wave\n        float t = (y - 0.5) * 4.0;  // 0 to 1 for second half\n        \n        // Square wave\n        float square = 0.0;\n        for(int i = 1; i <= 7; i += 2) {\n            square += sin(phase * float(i)) / float(i);\n        }\n        square *= 4.0 / 3.14159265359;\n        \n        // Complex wave (multiple harmonics)\n        float complex = sin(phase) * 0.5 +           // Fundamental\n                       sin(phase * 2.0) * 0.3 +      // 2nd harmonic\n                       sin(phase * 3.0) * 0.15 +     // 3rd harmonic\n                       sin(phase * 5.0) * 0.05;      // 5th harmonic\n        \n        return mix(square, complex, t);\n    }\n}\n\nfloat wavetable_metallic(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start harmonic, become increasingly inharmonic\n    float wave = sin(phase);\n    \n    // Add inharmonic partials\n    wave += sin(phase * 2.1) * 0.5 * y;\n    wave += sin(phase * 3.3) * 0.3 * y;\n    wave += sin(phase * 4.7) * 0.2 * y;\n    wave += sin(phase * 6.2) * 0.15 * y;\n    wave += sin(phase * 7.9) * 0.1 * y;\n    \n    return wave / (1.0 + y);\n}\n\nfloat wavetable_fold(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start with sine\n    float wave = sin(phase);\n    \n    // Apply wave folding - increases with y\n    float foldAmount = 1.0 + y * 4.0;\n    wave *= foldAmount;\n    \n    // Fold the wave\n    wave = abs(fract(wave * 0.25 + 0.5) * 2.0 - 1.0) * 2.0 - 1.0;\n    \n    return wave;\n}\n\nfloat wavetableTex(vec2 uv, sampler2D bmp) {\n    vec4 tex = texture(bmp, uv, 0.);\n   return ((tex.r +tex.g +tex.b))-0.5;\n}\nfloat wavetable_bitcrush(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start with clean sine\n    float wave = sin(phase);\n    \n    // Reduce bit depth as y increases\n    float bits = 5.0 - y * 7.0; // From 16-bit to 1-bit\n    float steps = pow(2.0, bits);\n    \n    wave = floor(wave * steps) / steps;\n    \n    return wave;\n}\nfloat wavetable_vowel(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Different formant frequencies for vowel sounds\n    float wave = 0.0;\n    \n    if (y < 0.25) {\n        // A to E\n        float t = y * 4.0;\n        // A: 730, 1090, 2440\n        float a = sin(phase) + 0.5*sin(phase*1.5) + 0.3*sin(phase*3.3);\n        // E: 530, 1840, 2480\n        float e = sin(phase) + 0.4*sin(phase*3.5) + 0.3*sin(phase*4.7);\n        wave = mix(a, e, t);\n        \n    } else if (y < 0.5) {\n        // E to I\n        float t = (y - 0.25) * 4.0;\n        float e = sin(phase) + 0.4*sin(phase*3.5) + 0.3*sin(phase*4.7);\n        // I: 270, 2290, 3010\n        float i = sin(phase) + 0.3*sin(phase*8.5) + 0.2*sin(phase*11.2);\n        wave = mix(e, i, t);\n        \n    } else if (y < 0.75) {\n        // I to O\n        float t = (y - 0.5) * 4.0;\n        float i = sin(phase) + 0.3*sin(phase*8.5) + 0.2*sin(phase*11.2);\n        // O: 570, 840, 2410\n        float o = sin(phase) + 0.5*sin(phase*1.5) + 0.2*sin(phase*4.2);\n        wave = mix(i, o, t);\n        \n    } else {\n        // O to U\n        float t = (y - 0.75) * 4.0;\n        float o = sin(phase) + 0.5*sin(phase*1.5) + 0.2*sin(phase*4.2);\n        // U: 440, 1020, 2240\n        float u = sin(phase) + 0.4*sin(phase*2.3) + 0.2*sin(phase*5.1);\n        wave = mix(o, u, t);\n    }\n    \n    return wave * 0.6; // Normalize\n}\nfloat wavetable_morph(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    if (y < 0.333) {\n        // Sine to Triangle\n        float t = y * 3.0;\n        float sine = sin(phase);\n        float triangle = asin(sin(phase)) * 2.0 / 3.14159265359;\n        return mix(sine, triangle, t);\n        \n    } else if (y < 0.666) {\n        // Triangle to Sawtooth\n        float t = (y - 0.333) * 3.0;\n        float triangle = asin(sin(phase)) * 2.0 / 3.14159265359;\n        float saw = (fract(x) * 2.0 - 1.0);\n        return mix(triangle, saw, t);\n        \n    } else {\n        // Sawtooth to Square\n        float t = (y - 0.666) * 3.0;\n        float saw = (fract(x) * 2.0 - 1.0);\n        \n        // Square wave (bandlimited)\n        float square = 0.0;\n        for(int i = 1; i <= 7; i += 2) {\n            square += sin(phase * float(i)) / float(i);\n        }\n        square *= 4.0 / 3.14159265359;\n        \n        return mix(saw, square, t);\n    }\n}\nfloat wavetable_harmonic(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start with sine, add harmonics as y increases\n    float wave = sin(phase);\n    \n    // Add harmonics progressively\n    int maxHarmonics = int(1.0 + y * 15.0);\n    for(int i = 2; i <= 16; i++) {\n        if(i <= maxHarmonics) {\n            float amplitude = 1.0 / float(i);\n            wave += sin(phase * float(i)) * amplitude;\n        }\n    }\n    \n    // Normalize\n    return wave / (1.0 + y * 2.0);\n}\nfloat wavetable_harmonic2(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    float outp = sin(phase) * 0.5;  // Fundamental always present\n    \n    // Gradually add harmonics based on table position\n    int numHarmonics = int(y * 12.0) + 1;\n    \n    for(int i = 2; i <= numHarmonics && i <= 12; i++) {\n        float harmAmp = (1.0 / float(i)) * (1.0 - float(i - 2) / 11.0 * 0.5);\n        outp += sin(phase * float(i)) * harmAmp * y;\n    }\n    \n    return outp / (1.0 + y * 0.5);  // Normalize\n}\nfloat wavetable_pwm(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Pulse width varies from 10% to 90%\n    float pulseWidth = 0.1 + y * 0.8;\n    \n    // Generate pulse wave using fourier series\n    float wave = 0.0;\n    for(int i = 1; i <= 9; i++) {\n        float n = float(i);\n        wave += (sin(n * 3.14159265359 * pulseWidth) / n) * sin(n * phase);\n    }\n    wave *= 2.0 / 3.14159265359;\n    \n    return wave;\n}\nfloat wavetable_pwm2(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Pulse width varies from 10% to 90%\n    float pulseWidth = 0.1 + y * 0.8;\n    \n    // Bandlimited pulse wave\n    float pulse = 0.0;\n    for(int i = 1; i <= 10; i++) {\n        pulse += sin(phase * float(i)) * sin(float(i) * 3.14159265359 * pulseWidth) / float(i);\n    }\n    pulse *= 4.0 / 3.14159265359;\n    \n    return pulse;\n}\nfloat wavetableclassic(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    if (y < 0.5) {\n        // Saw to Triangle\n        float t = y * 2.0;\n        \n        // Bandlimited saw wave\n        float saw = 0.0;\n        for(int i = 1; i <= 10; i++) {\n            saw += sin(phase * float(i)) / float(i);\n        }\n        saw *= -2.0 / 3.14159265359;\n        \n        // Triangle wave\n        float triangle = asin(sin(phase)) * 2.0 / 3.14159265359;\n        \n        return mix(saw, triangle, t);\n    } else {\n        // Triangle to Sine\n        float t = (y - 0.5) * 2.0;\n        float triangle = asin(sin(phase)) * 2.0 / 3.14159265359;\n        float sine = sin(phase);\n        return mix(triangle, sine, t);\n    }\n}\nfloat wavetablevoc(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    if (y < 0.33) {\n        // \"Ooh\" formant (darker)\n        float t = y * 3.0;\n        float ooh = sin(phase) * 0.8 + \n                   sin(phase * 2.0) * 0.15 * (1.0 - t) +\n                   sin(phase * 3.0) * 0.05;\n        return ooh;\n    } else if (y < 0.66) {\n        // \"Aah\" formant (brighter)\n        float t = (y - 0.33) * 3.0;\n        float aah = sin(phase) * 0.5 +\n                   sin(phase * 2.0) * 0.3 +\n                   sin(phase * 4.0) * 0.15 +\n                   sin(phase * 5.0) * 0.05;\n        return aah * (1.0 + t * 0.2);\n    } else {\n        // \"Eeh\" formant (brightest)\n        float t = (y - 0.66) * 3.0;\n        float eeh = sin(phase) * 0.4 +\n                   sin(phase * 3.0) * 0.3 +\n                   sin(phase * 5.0) * 0.2 +\n                   sin(phase * 7.0) * 0.1;\n        return eeh;\n    }\n}\nfloat wavetablebell(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start with fundamental\n    float outp = sin(phase) * (1.0 - y * 0.5);\n    \n    // Add increasingly inharmonic partials\n    outp += sin(phase * 2.7) * y * 0.3;   // Minor third-ish\n    outp += sin(phase * 4.2) * y * 0.2;   // Between harmonics\n    outp += sin(phase * 5.4) * y * 0.15;  // Metallic partial\n    outp += sin(phase * 7.8) * y * 0.1;   // Bell-like partial\n    \n    if (y > 0.5) {\n        float t = (y - 0.5) * 2.0;\n        outp += sin(phase * 9.3) * t * 0.08;\n        outp += sin(phase * 11.7) * t * 0.05;\n    }\n    \n    return outp;\n}\nfloat wavetabledist(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    float sine = sin(phase);\n    float drive = 1.0 + y * 10.0;  // Increase overdrive with y\n    \n    // Soft to hard clipping\n    float clipped = sine * drive;\n    \n    if (y < 0.5) {\n        // Soft clipping (tanh-like)\n        clipped = tanh(clipped * 2.0) * 0.9;\n    } else {\n        // Harder clipping\n        clipped = clamp(clipped, -1.0, 1.0);\n        // Add some harmonics back for bandlimiting\n        float t = (y - 0.5) * 2.0;\n        clipped = mix(tanh(sine * drive * 2.0), \n                     sign(sine) * pow(abs(sine), 0.3 - t * 0.2), \n                     t) * 0.9;\n    }\n    \n    return clipped;\n}\nfloat wavetable(vec2 uv, sampler2D bmp, float time) {\n\n    float period = time/6.2832;\n    int num = int(floor(period));\n    float phase = fract(period);\n    num = num%15;\n    float sampl;\n    \n    switch (num){\n        case 0: sampl = wavetablebell(uv); break;\n        case 1: sampl = wavetableTex(uv, bmp); break;\n        case 2: sampl = wavetabletest(uv); break;\n        case 3: sampl = wavetable_metallic(uv); break;\n        case 4: sampl = wavetable_fold(uv) ; break;\n        case 5: sampl = wavetable_bitcrush(uv) ; break;\n        case 6: sampl = wavetable_vowel(uv) ; break;\n        case 7: sampl = wavetable_morph(uv) ; break;\n        case 8: sampl = wavetable_harmonic(uv) ; break;\n        case 9: sampl = wavetable_harmonic2(uv) ; break;\n        case 10: sampl = wavetable_pwm(uv) ; break;\n        case 11: sampl = wavetable_pwm2(uv); break;\n        case 12: sampl = wavetableclassic( uv) ; break;\n        case 13: sampl = wavetablevoc(uv) ; break;\n        case 14: sampl = wavetabledist(uv) ; break;\n    }\n    \n    float sampl2;\n    \n    switch (num+1){\n        \n        case 1: sampl2 = wavetableTex(uv, bmp); break;\n        case 2: sampl2 = wavetabletest(uv); break;\n        case 3: sampl2 = wavetable_metallic(uv); break;\n        case 4: sampl2 = wavetable_fold(uv) ; break;\n        case 5: sampl2 = wavetable_bitcrush(uv) ; break;\n        case 6: sampl2 = wavetable_vowel(uv) ; break;\n        case 7: sampl2 = wavetable_morph(uv) ; break;\n        case 8: sampl2 = wavetable_harmonic(uv) ; break;\n        case 9: sampl2= wavetable_harmonic2(uv) ; break;\n        case 10: sampl2 = wavetable_pwm(uv) ; break;\n        case 11: sampl2 = wavetable_pwm2(uv); break;\n        case 12: sampl2 = wavetableclassic( uv) ; break;\n        case 13: sampl2 = wavetablevoc(uv) ; break;\n        case 14: sampl2 = wavetabledist(uv) ; break;\n        case 15: sampl2 = wavetablebell(uv); break;\n    }\n    \n    sampl = mix(sampl, sampl2, phase);\n    \n   return clamp( sampl  , -1.,1.);\n}\n\n\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sf3Rr",
       "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "vec2 mainSound( int samp, float time )\n{\n    float frequency = 262.0;\n    float SPEED = 1.2 +time/50.;\n    float phase = fract(time * frequency);\n    float tablePos = 0.5+sin(time*SPEED)/2.;\n    float sampl = wavetable(vec2(phase, tablePos), iChannel0, time);   \n    return vec2(sampl);\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "w3XBWS",
    "date": "1761851612",
    "viewed": 145,
    "name": "Parametric Pumpkin ",
    "description": "This was supposed to be Pumpkin Carver V3\nBut I got sidetracked [url=https://www.sleditor.com/]making my own Shader Editor[/url]\nSo I'm publishing this as it is because it's still fun to play with.",
    "likes": 18,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "procedural",
     "halloween",
     "drawing",
     "pumpkin",
     "carving",
     "octoberdesmos"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Pumpkin Carver V1\" by Cotterzz. https://www.shadertoy.com/view/3cBfDw\n// Fork of \"Pumpkin Carver V2\" by Cotterzz. https://www.shadertoy.com/view/tXfyRH\n// Used in \"Pumpkin Moebius\"   by Cotterzz. https://www.shadertoy.com/view/t3XcRH\n//\n// Pumpkin equation from https://www.desmos.com/3d/afwrvhoa9n\n//\n// 6th slider down on the left is AA\n// Sorry things aren't labelled yet...\n\n// comment out #define USE_SLIDERS on buffer A and republish for a randomised pumpkin on mouse move.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Mode selection - comment out for random mode\n#define USE_SLIDERS\n\n// Slider values on the right are pumpkin then stalk metrics.\n// Slider values on the left are camera/view at the top, then AA, then face then lid metrics at the bottom.\n\n// iChannel0 is this buffers output, iChannel1 is the font texture\n\n// Pumpkin Shader, SDF Based on:\n// https://www.desmos.com/3d/afwrvhoa9n\n\n\n// Random seed for random mode\nfloat randomSeed = 0.0;\n\nfloat n0 = 20.0;   // Primary ridge frequency (higher = more ridges)\nfloat m0 = 0.5;    // Primary ridge offset\nfloat k0 = 0.1;    // Primary ridge amplitude\n\nfloat n1 = 20.0;    // Secondary ridge frequency\nfloat m1 = 0.5;    // Secondary ridge offset  \nfloat k1 = 0.15;   // Secondary ridge amplitude\n\nfloat n2 = 3.0;    // Tertiary ridge frequency\nfloat m2 = 0.5;    // Tertiary ridge offset\nfloat k2 = 0.1;    // Tertiary ridge amplitude\n\nfloat g = 0.6;     // Global size offset\nfloat p = 0.9;     // Vertical squash factor\nfloat h = -0.3;    // Top/bottom flattening\n\nfloat[40] sliderValues;\nbool[40] hasInteracted;\n\nfloat thickness = 0.02;    // Wall thickness for hollow effect\nfloat cutSphereRadius = 0.6; // Size of sphere to cut from top\nfloat cutSphereY = 0.5;    // Height of cutting sphere center\nfloat lidRaise = 0.0;      // How much to raise the lid\nfloat lidTiltX = 0.04;      // Tilt angle around X axis\nfloat lidTiltZ = 0.05;      // Tilt angle around Z axis\nfloat lidGap = 0.02;       // Gap between lid and opening\n\n// Stalk parameters (now adjustable via sliders)\nfloat stalkRadius = 0.04;   // Base radius of stalk\nint   stalkStarN = 10;      // Number of star points\nfloat stalkStarM = 2.5;     // Star sharpness (between 2 and n)\nfloat stalkHeight = 0.35;   // Total height of stalk\nfloat stalkTwist = 0.1;     // Twisting amount around Y axis\nfloat stalkBend = 0.1;      // Bending amount (vertical curvature)\nfloat stalkTaper = -1.2;    // Tapering factor (0 = no taper, 1 = full taper)\nfloat stalkBulbHeight = 0.22; // Height of bulbous base\nfloat stalkBulbRadius = 0.45; // Maximum radius of bulbous base\nfloat stalkHeightOffset = 0.0; //minor adjustment when it gets displaced.\n\n// Face cutout parameters\nfloat faceScale = 0.3;     // Size of face characters\nfloat faceDepth = 0.1;     // How deep the cut goes  \nfloat faceZ = 0.0;         // Z offset for face position\n\nfloat stemSubtract;\n\nfloat mouthSliderA = 0.5;        // number telling us which mouth to use\nfloat mouthSliderB = 0.5;       // number of second shape for interpolation\nfloat mouthSliderC = 0.5;       // interpolation value\nint mouthTypes = 10;       // number of possible mouths for slider bounds calculation\nfloat eyeSliderA = 0.5;       // interpolation value\nint eyeTypes = 8;       // number of possible eyes for slider bounds calculation\n\n// Slider parameters\nconst float sliderLineWidth = 0.003;   // Width of the slider line (smaller)\nconst float sliderCircleRadius = 0.012; // Radius of the slider circle (smaller)\nconst int totalSliders = 40;           // Total number of sliders\n\n// Simple hash function for deterministic random values\nfloat hash(float seed) {\n    return fract(sin(seed * 12.9898) * 43758.5453);\n}\n\n// Parameter mapping functions - convert 0-1 values to parameter ranges\nfloat mapLidRaise(float t) { return t * 0.5; }\nfloat mapLidTiltX(float t) { return (t - 0.5) * 0.4; }\nfloat mapLidTiltZ(float t) { return (t - 0.5) * 0.4; }\nfloat mapCutSphereY(float t) { return mix(0.2, 1.0, clamp(t, 0.0, 1.0)); }\nfloat mapCutSphereRadius(float t) { return mix(0.4, 0.7, clamp(t, 0.0, 1.0)); }\nfloat mapThickness(float t) { return mix(0.04, 0.08, clamp(t, 0.0, 1.0)); }\nfloat mapLidGap(float t) { return mix(0.0, 0.05, clamp(t, 0.0, 1.0)); }\nfloat mapMouthSliderA(float t) { return t; }\nfloat mapMouthSliderB(float t) { return t; }\nfloat mapMouthSliderC(float t) { return t; }\nfloat mapFaceScale(float t) { return mix(3.25, 4.5, clamp(t, 0.0, 1.0)); }\nfloat mapEyeSliderA(float t) { return t; }\nfloat mapSubsurfaceDistance(float t) { return mix(0.0001, 0.2, clamp(t, 0.0, 1.0)); }  // How far to probe into surface\nfloat mapSubsurfaceAttenuation(float t) { return mix(0.1, 10.0, clamp(t, 0.0, 1.0)); } // Light falloff strength\n\n// Camera/scene parameters (sliders 14-19, hardcoded in random mode)\nfloat mapFocal(float t) { return t * 2.0; }\nfloat mapBaseCameraDist(float t) { return mix(4.0, 10.0, clamp(t, 0.0, 1.0)); }\nfloat mapScreenMag(float t) { return (t < 0.5) ? mix(0.75, 2.0, t * 2.0) : mix(2.0, 3.0, (t - 0.5) * 2.0); }\nfloat mapPitch(float t) { return radians(mix(-89.0, 70.0, clamp(t, 0.0, 1.0))); }\nfloat mapYaw(float t) { return mix(-4.7123, 1.5708, clamp(t, 0.0, 1.0)); }\n\n// Stalk parameters (sliders 20-27)\nfloat mapStalkRadius(float t) { return mix(0.04, 0.1, clamp(t, 0.0, 1.0)); }\nfloat mapStalkStarN(float t) { return floor(mix(5.0, 20.0, clamp(t, 0.0, 1.0))); }\nfloat mapStalkStarM(float t) { return mix(1.8, 4.0, clamp(t, 0.0, 1.0)); }\nfloat mapStalkHeight(float t) { return mix(0.2, 0.5, clamp(t, 0.0, 1.0)); }\nfloat mapStalkTwist(float t) { return mix(0.0, 1.5, clamp(t, 0.0, 1.0)); }\nfloat mapStalkBend(float t) { return mix(0.0, 0.6, clamp(t, 0.0, 1.0)); }\nfloat mapStalkTaper(float t) { return mix(-0.5, 0.3, clamp(t, 0.0, 1.0)); }\nfloat mapStalkBulbHeight(float t) { return mix(0.1, 0.3, clamp(t, 0.0, 1.0)); }\n\n// Pumpkin shape parameters (sliders 28-39)\nfloat mapK2(float t) { return mix(0.02, 0.3, clamp(t, 0.0, 1.0)); }\nfloat mapM2(float t) { return mix(0.0, 6.28, clamp(t, 0.0, 1.0)); }\nfloat mapN2(float t) { return floor(mix(4.0, 12.0, clamp(t, 0.0, 1.0))); }\nfloat mapK1(float t) { return mix(0.02, 0.3, clamp(t, 0.0, 1.0)); }\nfloat mapM1(float t) { return mix(0.0, 6.28, clamp(t, 0.0, 1.0)); }\nfloat mapN1(float t) { return floor(mix(5.0, 30.0, clamp(t, 0.0, 1.0))); }\nfloat mapK0(float t) { return mix(0.02, 0.3, clamp(t, 0.0, 1.0)); }\nfloat mapM0(float t) { return mix(0.0, 3.14, clamp(t, 0.0, 1.0)); }\nfloat mapN0(float t) { return floor(mix(6.0, 60.0, clamp(t, 0.0, 1.0))); }\nfloat mapH(float t) { return mix(-0.3, -0.05, clamp(t, 0.0, 1.0)); }\nfloat mapP(float t) { return mix(0.5, 0.8, clamp(t, 0.0, 1.0)); }\nfloat mapG(float t) { return mix(0.5, 0.7, clamp(t, 0.0, 1.0)); }\n\n// Get parameter value - either from slider or random\nfloat getParamValue(int sliderIndex) {\n#ifdef USE_SLIDERS\n    return sliderValues[sliderIndex];\n#else\n    // For random mode, hardcode camera/scene values (sliders 14-19)\n    if (sliderIndex == 14) return 0.0;  // AA\n    if (sliderIndex == 15) return 0.5;  // Focal\n    if (sliderIndex == 16) return 0.5;  // Camera distance\n    if (sliderIndex == 17) return 0.5;  // Screen magnification\n    if (sliderIndex == 18) return 0.5 - (0.5-(iMouse.y/iResolution.y))/6.; ;  // Pitch\n    if (sliderIndex == 19) return 0.5 - (0.5-(iMouse.x/iResolution.x))/3.;  // Yaw\n    \n    // For other parameters, use deterministic random based on slider index\n    return hash(randomSeed + float(sliderIndex) * 0.1);\n    //return (0.5-range/2.) + (hash(randomSeed + float(sliderIndex) * 0.1))*range;\n#endif\n}\n\n// SDF Operations\nfloat opOnion(float sdf, float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\n// Sphere SDF\nfloat sphereSDF(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\n// 2D Star SDF\nfloat sdStar(vec2 p, float r, int n, float m) {\n    // Precomputed values for given shape\n    float an = 3.141593 / float(n);\n    float en = 3.141593 / m;  // m is between 2 and n\n    vec2 acs = vec2(cos(an), sin(an));\n    vec2 ecs = vec2(cos(en), sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.y, p.x), 2.0 * an) - an;\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\n// get 2D sdf data from font texture.\nfloat GetCharacter(ivec2 ch, vec2 cuv, float th) {\n    cuv = clamp(cuv, vec2(0), vec2(1));\n    float tx = (cuv.x/16.) + (float(ch.x)*(1./16.));\n    float ty = (cuv.y/16.) + (float(ch.y)*(1./16.));\n    return (-.5*th) + texture(iChannel1, vec2(tx, ty)).a;\n}\n\n// Single character 2D SDF for face cutting\nfloat char2DSDF(vec2 p, float scale, ivec2 ch) {\n    // Map world XY to [0,1] glyph UV, centered at origin\n    vec2 uv = p / scale + 0.5;\n    return GetCharacter(ch, uv, 1.0);\n}\n\n// Rotated character SDF\nfloat char2DSDFRotated(vec2 p, vec2 scale, ivec2 ch, float angle, float th) {\n    float c = cos(angle);\n    float s = sin(angle);\n    vec2 rotP = vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n    vec2 uv = rotP / scale + 0.5;\n    return GetCharacter(ch, uv, th);\n}\n\nfloat eyesSDF(vec2 p, float scale, int index) {\n\n    ivec2 echars = ivec2(0);\n    float erotation = 0.;\n    vec2  escale = vec2(2,1) * scale;\n    vec2  eoffset = vec2(0,-0.4) * scale;\n    float ethickness = 1.0;\n\n    switch (index) {\n        case 0:echars = ivec2(5,15);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );erotation = -3.141;break;\n        case 1:echars = ivec2(14,14);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );erotation = -3.141;break;\n        case 2:echars = ivec2(4,15);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );escale = vec2(1,1) * scale;erotation = -3.141;break;\n        case 3:echars = ivec2(3,15);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );escale = vec2(1,1) * scale;erotation = -3.141;break;\n        case 4:echars = ivec2(12,14);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );escale = vec2(1,1) * scale;erotation = -3.141;break;\n        case 5:echars = ivec2(10,13);eoffset += vec2(-0.5,-0.2)*scale;p.x = abs (p.x );erotation = -3.141;break;\n        case 6:echars = ivec2(11,13);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );erotation = -3.141;break;\n        case 7:echars = ivec2(12,13);eoffset += vec2(-0.4,-0.4)*scale;p.x = abs (p.x );escale = vec2(2) * scale;break;\n        case 8:echars = ivec2(5,15);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );erotation = -3.141;break;\n    }\n    return  char2DSDFRotated(p + eoffset, escale, echars, erotation, ethickness);\n}\n\nfloat mouthSDF(vec2 p, float scale, int index) {\n\n    ivec2 mchars = ivec2(0);\n    float mrotation = 0.;\n    vec2  mscale = vec2(2,1) * scale;\n    vec2  moffset = vec2(0,0.3) * scale;\n    float mthickness = 1.0;\n\n    switch (index) {\n        //-------mouth is single character\n        case 0:mchars = ivec2(6,10);p.x = abs(p.x)<0.5?(fract( p.x * 6.)-0.5)/3.:p.x;break;\n        case 1:mchars = ivec2(15,6);moffset += vec2(-0.4,0)*scale;p.x = abs (p.x );mrotation = -.2;break;\n        case 2:mchars = ivec2(7,8); break;\n        case 3:mchars = ivec2(7,10);break;\n        case 4: mchars = ivec2(13,10);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale;\n        break;   case 5: mchars = ivec2(13,8);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale;\n        break;   case 6: mchars = ivec2(9,13);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale;\n        break;   case 7: mchars = ivec2(8,13);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale;\n        break;   case 8: mchars = ivec2(11,10);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale; \n        break;   case 9: mchars = ivec2(6,10);p.x = abs(p.x)<0.35?(fract( p.x * 6.)-0.5)/3.:p.x;break; \n        break;  case 10:mchars = ivec2(6,10);p.x = abs(p.x)<0.65?(fract( p.x * 6.)-0.5)/3.:p.x;break;\n        break;  case 11: mchars = ivec2(15,5);moffset += vec2(0,0.3)*scale;\n        break;  case 12: mchars = ivec2(3,15);mscale = vec2(2.5,1) * scale;\n        break;  case 13: mchars = ivec2(3,15);mscale = vec2(1.5,1.5) * scale;\n    }\n    \n    return  char2DSDFRotated(p + moffset, mscale, mchars, mrotation, mthickness);\n}\n\n// Complete face SDF - combines all features\nfloat faceSDF(vec2 p, float scale) {\n\n    \n    float mouthA = mouthSDF(p, scale, int(floor(mouthSliderA * float(mouthTypes))));\n    float mouthB = mouthSDF(p, scale, 1+int(floor(mouthSliderA * float(mouthTypes))));\n    float mouthC = mouthSDF(p, scale, 13);\n    float mouthD = mouthSDF(p, scale, 12);\n    float mouthE = mouthSDF(p, scale, 11);\n    float mouth = mix(mouthA, mouthB, fract(mouthSliderA * float(mouthTypes)));\n    mouth -= (0.5-abs(fract(mouthSliderA * float(mouthTypes)) - 0.5))/15.;\n    float mouthF = mouthSliderB<0.5 ? mix(mouthC, mouthD, mouthSliderB*2.) : mix(mouthD, mouthE, (mouthSliderB-0.5)*1.6);\n    mouth = mix(mouth, mouthF, mouthSliderC);\n    \n    float eyesA = eyesSDF(p, scale, int(floor(eyeSliderA * float(eyeTypes))));\n    float eyesB = eyesSDF(p, scale, 1+int(floor(eyeSliderA * float(eyeTypes))));  \n    float eyes = mix(eyesA, eyesB, fract(eyeSliderA * float(eyeTypes)));\n    \n    return min(mouth, eyes);\n\n}\n\n\n// Extrude a 2D SDF along Z axis\nfloat extrudeSDF(vec3 pos, float char2D, float halfDepth) {\n    vec2 w = vec2(char2D, abs(pos.z) - halfDepth);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// 3D Extrusion operation\nfloat opExtrusion(vec2 p, float h, float r, int n, float m) {\n    float d = sdStar(p, r, n, m);\n    vec2 w = vec2(d, abs(h) - stalkHeight * 0.5);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// Twisting operation (rotates around Y axis as Y increases)\nvec3 opTwist(vec3 p, float k) {\n    float c = cos(k * p.y);\n    float s = sin(k * p.y);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\n// Bending operation (curves the stalk in the XZ plane)\nvec3 opBend(vec3 p, float k) {\n    float bendAmount = k * p.y * p.y / stalkHeight; // Quadratic bend for natural curve\n    return vec3(p.x + bendAmount, p.y, p.z);\n}\n\n\n\n// Rotation matrices\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(1.0, 0.0, 0.0,\n                0.0, c, -s,\n                0.0, s, c);\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c, -s, 0.0,\n                s, c, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Convert Cartesian to spherical coordinates\nvec3 cartesianToSpherical(vec3 pos) {\n    float rho = length(pos);\n    float theta = atan(pos.z, pos.x);\n    float phi = acos(pos.y / rho);\n    return vec3(rho, theta, phi);\n}\nfloat pown(float f, float p){\n    return pow(abs(f), p);\n}\n\n// Pumpkin equation SDF\nfloat pumpkinSDF(vec3 pos) {\n    vec3 spherical = cartesianToSpherical(pos);\n    float theta = spherical.y;\n    float phi = spherical.z;\n    \n    float sin_term0 = sin(n0 * theta + m0);\n    float sin_term1 = sin(n1 * theta + m1);\n    float sin_term2 = sin(n2 * theta + m2);\n    \n    float part1 = (1.0 - pown(sin_term0, 4.0)) * (k0 / n0) +\n                  (1.0 - sin_term1) * (k1 / n1) +\n                  (1.0 - sin_term2) * (k2 / n2);\n    \n    float cos_2phi = cos(2.0 * phi);\n    float part2 = pown((1.0 - cos_2phi) / 2.0, 2.0);\n    float part3 = exp(-pown(phi - 3.14159 / 2.0, 2.0)) + p;\n    float part4 = 1.0 - h * cos_2phi;\n    \n    float target_rho = (part1 * part2 + g) * part3 * part4;\n    \n    return length(pos) - target_rho;\n}\n\n\n// Stalk SDF - curved, twisted, tapered star extrusion\nfloat stalkSDF(vec3 pos) {\n    // Transform position to match the lid's transformation\n    vec3 stalkPos = pos;\n    \n    // Move to lid's raised position\n    stalkPos.y -= lidRaise;\n    \n    // Apply inverse rotations (same as lid, but in reverse order)\n    stalkPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * stalkPos;\n    \n    // Position stalk above the lid center (now in lid's local space)\n    stalkPos = stalkPos - vec3(0.0, stalkHeightOffset + (g * p *1.2) - (h/3.), 0.0);\n    \n    // Apply twisting (the existing \"bend\" that creates spiral ridges)\n    vec3 twistedPos = opTwist(stalkPos, stalkTwist / stalkHeight);\n    \n    // Apply bending (new vertical curvature)\n    vec3 bentPos = opBend(twistedPos, stalkBend / stalkHeight);\n    \n    // Calculate radius with both tapering and bulbous base\n    float heightFactor = clamp((bentPos.y) / stalkHeight, 0.0, 1.0);\n    \n    // Bulbous base effect - smooth falloff from bulb radius to normal radius\n    float bulbFactor = 1.0 - smoothstep(0.0, stalkBulbHeight, bentPos.y);\n    float bulbRadius = mix(stalkRadius, stalkBulbRadius, bulbFactor);\n    \n    // Apply tapering on top of bulb radius\n    float taperedRadius = bulbRadius * (1.0 - stalkTaper * heightFactor);\n    \n    // Create extruded star - star shape in XZ plane, extruded along Y\n    float starDist = sdStar(bentPos.xz, taperedRadius, stalkStarN, stalkStarM);\n    float heightDist = (abs(bentPos.y - stalkHeight * 0.5) - stalkHeight * 0.5);\n    \n    // Combine using extrusion formula\n    vec2 w = vec2(starDist, heightDist);\n    float stalkBase = min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n\n    // Only show stalk outside the original pumpkin surface\n    // use stemsubtract stored in lidSDF()\n    return opSubtraction(stemSubtract, stalkBase);\n}\n\n\n\n// Hollow pumpkin with top cut off\nfloat hollowPumpkinSDF(vec3 pos) {\n    // Get the base pumpkin shape\n    float pumpkin = pumpkinSDF(pos);\n    \n    // Make it hollow using onion operation\n    float hollow = opOnion(pumpkin, thickness);\n    \n    // Create cutting sphere at the top - slightly larger for the gap\n    vec3 cutSpherePos = pos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius + lidGap);\n    \n    // Subtract the sphere from the hollow pumpkin\n    return opSubtraction(cuttingSphere, hollow);\n}\n\n// Lid (the cut-off part) - raised and tilted\nfloat lidSDF(vec3 pos) {\n    // Transform position for the lid\n    vec3 lidPos = pos;\n    \n    // Move down to original position, apply rotations, then raise up\n    lidPos.y -= lidRaise;\n    lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n    \n    // Get the base pumpkin shape\n    float pumpkin = pumpkinSDF(lidPos);\n    \n    stemSubtract = pumpkin;\n    \n    // Make it hollow\n    float hollow = opOnion(pumpkin, thickness);\n    \n    // Create cutting sphere - we want only the part that was cut off\n    vec3 cutSpherePos = lidPos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius);\n    \n    // Return only the intersection (the part that was inside the cutting sphere)\n    // We want the hollow pumpkin AND inside the cutting sphere\n    return max(hollow, cuttingSphere);\n}\n\n// Main scene SDF\nfloat sceneSDF(vec3 pos) {\n    float hollowPumpkin = hollowPumpkinSDF(pos);\n    float lid = lidSDF(pos);\n    float stalk = stalkSDF(pos);\n    \n    // Create complete face cutout\n    float faceShape = faceSDF(pos.xy, faceScale);\n    \n    vec3 facePos = pos - vec3(0.0, 0.0, faceZ);\n    float faceCutout = extrudeSDF(facePos, faceShape, faceDepth);\n    \n    // Subtract face cutout from hollow pumpkin only\n    hollowPumpkin = opSubtraction(faceCutout, hollowPumpkin);\n    \n    return opUnion(opUnion(hollowPumpkin, lid), stalk);\n}\n\n\n// Debug plane (world-space Z plane) helpers\nfloat rayPlaneIntersectZ(vec3 ro, vec3 rd, float planeZ) {\n    if (abs(rd.z) < 1e-4) return -1.0; // Parallel\n    return (planeZ - ro.z) / rd.z;\n}\n\nfloat rayPlaneIntersectX(vec3 ro, vec3 rd, float planeX) {\n    if (abs(rd.x) < 1e-4) return -1.0;\n    return (planeX - ro.x) / rd.x;\n}\n\nfloat rayPlaneIntersectY(vec3 ro, vec3 rd, float planeY) {\n    if (abs(rd.y) < 1e-4) return -1.0;\n    return (planeY - ro.y) / rd.y;\n}\n\nvec3 debugSDFColor(vec3 pos) {\n    float d = sceneSDF(pos);\n    vec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);\n    col *= 1.0 - exp(-6.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(150.0 * d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.005, abs(d)));\n    return col;\n}\nfloat getSliderLength(vec2 resolution) {\n    return resolution.x / 4.0; // 1/6 screen width\n}\n// Slider functions\nvec2 getSliderPosition(vec2 resolution, int sliderIndex) {\n    float spacing = sliderCircleRadius * 4.0 * resolution.y; // More spacing\n    bool leftSide = sliderIndex < 20;\n    int localIndex = leftSide ? sliderIndex : (sliderIndex - 20);\n    \n    float x = leftSide ? resolution.x * 0.02 : resolution.x * 0.98 - getSliderLength(resolution);\n    float y = resolution.y * 0.02 + float(localIndex) * spacing;\n    \n    return vec2(x, y);\n}\n\n\n\nvec4 getSliderState(vec2 resolution, int sliderIndex) {\n    // Read state from different pixels for each slider (8x5 grid)\n    int x = sliderIndex % 8;\n    int y = sliderIndex / 8;\n    vec2 pixelPos = vec2(float(x) + 0.5, float(y) + 0.5) / resolution;\n    return texture(iChannel0, pixelPos);\n}\n\nbool isInSliderHitArea(vec2 pos, vec2 sliderPos, float sliderLength, vec2 resolution) {\n    vec2 lineStart = sliderPos;\n    vec2 lineEnd = sliderPos + vec2(sliderLength, 0.0);\n    \n    // Expand hit area by circle radius\n    float clearance = sliderCircleRadius * resolution.y * 2.;\n    \n    return pos.x >= lineStart.x - clearance && \n           pos.x <= lineEnd.x + clearance &&\n           pos.y >= lineStart.y - clearance && \n           pos.y <= lineEnd.y + clearance;\n}\n\nfloat updateSliderValue(vec2 mousePos, vec2 sliderPos, float sliderLength) {\n    // Calculate value based on mouse position along the line\n    float t = (mousePos.x - sliderPos.x) / sliderLength;\n    return clamp(t, 0.0, 1.0);\n}\n\nint getActiveSlider(vec2 mousePos, vec2 resolution) {\n    float sliderLength = getSliderLength(resolution);\n    \n    for (int i = 0; i < totalSliders; i++) {\n        vec2 sliderPos = getSliderPosition(resolution, i);\n        if (isInSliderHitArea(mousePos, sliderPos, sliderLength, resolution)) {\n            return i;\n        }\n    }\n    return -1; // No slider hit\n}\n\nvec3 renderSliders(vec2 fragCoord, vec2 resolution, float sliderValues[40]) {\n    float sliderLength = getSliderLength(resolution);\n    \n    // Pixel-precise screen position\n    vec2 screenPos = fragCoord;\n    vec3 col1 = vec3(0);\n    vec3 col2 = vec3(0.5);\n    vec3 col3 = vec3(0.25);\n    vec3 col4 = vec3(0.7);\n    \n    // Calculate slider area boundaries\n    float spacing = sliderCircleRadius * 4.0 * resolution.y;\n    float leftStartX = (resolution.x * 0.02)-2.0;\n    float leftEndX = (leftStartX + sliderLength)+4.0;\n    float rightStartX = (resolution.x * 0.98 - sliderLength)-2.0;\n    float rightEndX = (resolution.x * 0.98)+2.0;\n    float startY = (resolution.y * 0.02)-2.0;\n    float maxY = startY  + 19.0 * spacing + 4.0; // 20 sliders (0-19), plus knob height for last slider\n    \n    // Early exit if not in any slider area\n    bool inLeftArea = (screenPos.x >= leftStartX && screenPos.x <= leftEndX);\n    bool inRightArea = (screenPos.x >= rightStartX && screenPos.x <= rightEndX);\n    if (!inLeftArea && !inRightArea) {\n        return vec3(-1.0); // Transparent (no slider)\n    }\n    if (screenPos.y < startY || screenPos.y > maxY) {\n        return vec3(-1.0); // Above or below slider area\n    }\n    \n    // Determine which slider we're potentially in\n    bool isLeftSide = inLeftArea;\n    float relativeY = screenPos.y - startY;\n    int localIndex = int(floor(relativeY / spacing));\n    \n    // Bounds check\n    if (localIndex < 0 || localIndex >= 20) {\n        return vec3(-1.0);\n    }\n    \n    int sliderIndex = isLeftSide ? localIndex : (localIndex + 20);\n    \n    // Now check if we're actually on this specific slider\n    //bool inactive = sliderIndex > 11 && sliderIndex < 14;\n    vec2 sliderPos = getSliderPosition(resolution, sliderIndex);\n    \n    // Convert to pixel-aligned coordinates\n    float xStart = floor(sliderPos.x + 0.5);\n    float xEnd   = floor(sliderPos.x + sliderLength + 0.5);\n    float yLine  = floor(sliderPos.y + 0.5);\n    vec2 circlePos = vec2(xStart + sliderValues[sliderIndex] * (xEnd - xStart), yLine + 0.5);\n    \n    // 2-pixel-high, pixel-precise line: match exactly two rows (yLine and yLine+1)\n    float row = floor(screenPos.y + 0.5);\n    bool onLine = (screenPos.x >= xStart && screenPos.x <= xEnd) &&\n                  (row == yLine || row == (yLine + 1.0));\n\n    // 4x4 black square knob centered on line (rows yLine-1..yLine+2)\n    float knobX = floor(circlePos.x + 0.5);\n    bool onKnob = (screenPos.x >= knobX - 2.0 && screenPos.x <= knobX + 1.0) &&\n                  (row >= (yLine - 1.0) && row <= (yLine + 2.0));\n    if (onKnob) {\n        //if(inactive){return col4;}\n        return col1;\n    }\n    if (onLine) {\n        //if(inactive){return col4;}\n        // Dark grey to the left of the knob, medium grey to the right\n        return (screenPos.x < circlePos.x) ? col3 : col2;\n    }\n    \n    return vec3(-1.0); // Transparent (no slider)\n}\n\n// Raymarching function\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = sceneSDF(pos);\n        if (d < 0.0005) break;\n        t += d * .9; // Use smaller step for complex shapes\n        if (t > 50.0) break;\n    }\n    return t;\n}\n\n// Calculate normal using finite differences\nvec3 getNormal(vec3 pos) {\n    float eps = 0.001;\n    vec3 n = vec3(\n        sceneSDF(pos + vec3(eps, 0, 0)) - sceneSDF(pos - vec3(eps, 0, 0)),\n        sceneSDF(pos + vec3(0, eps, 0)) - sceneSDF(pos - vec3(0, eps, 0)),\n        sceneSDF(pos + vec3(0, 0, eps)) - sceneSDF(pos - vec3(0, 0, eps))\n    );\n    return normalize(n);\n}\n\n\n// Subsurface scattering\nfloat calculateSubsurface(vec3 pos, vec3 interiorLightPos, float probeDistance, float atten) {\n    vec3 toLightDir = normalize(interiorLightPos - pos);\n    float toLightDist = distance(interiorLightPos , pos);\n    vec3 probePos = pos + toLightDir * probeDistance;\n    float d = sceneSDF(probePos);\n    \n    // Only apply subsurface if we're actually inside the object\n    // and not just in free space\n    float surfaceDist = sceneSDF(pos);\n    if (surfaceDist > 0.001) return 0.0;  // We're not on the surface\n    \n    return clamp(max(0., (d*atten)/toLightDist), 0.0, 1.0);\n}\n\nvec3 lighting(vec3 pos, vec3 normal, vec3 viewDir, float subsurfaceDistance, float subsurfaceAttenuation, mat3 cameraMatrix) {\n    float flicker = 0.5 + hash(randomSeed) + 0.2 * sin(iTime * 37.0) + 0.15 * sin(iTime * 71.0) * (0.5 + hash(randomSeed));\n    \n    vec3 worldKeyLightDir = normalize( vec3(0,.7,1.) );  // Original direction\n    vec3 keyLightDir = normalize(cameraMatrix * worldKeyLightDir);  // Transform to camera space\n    vec3 keyLightColor = vec3(.8, 0.9, 1.0);\n\n    vec3 interiorLightPos = vec3(0.0, 0.15, 0.0);\n    vec3 interiorLightColor = vec3(1.2, .8, 0.2);\n    float interiorLightIntensity = flicker;\n    \n    vec3 ambient = vec3(0.4, 0.3, 0.2);\n\n    float keyDiff = max(dot(normal, keyLightDir), 0.0);\n    vec3 keyDiffuse = keyDiff * keyLightColor;\n    \n    vec3 keyReflectDir = reflect(-keyLightDir, normal);\n    float keySpec = pow(max(dot(viewDir, keyReflectDir), 0.0), 32.0);\n    vec3 keySpecular = keySpec * keyLightColor;\n    \n    vec3 toInteriorLight = interiorLightPos - pos;\n    float interiorLightDist = length(toInteriorLight);\n    vec3 interiorLightDir = toInteriorLight / interiorLightDist;\n    \n    float attenuation = interiorLightIntensity / (1.0 + 0.5 * interiorLightDist * interiorLightDist);\n\n    float interiorDiff = max(dot(normal, interiorLightDir), 0.0);\n    vec3 interiorDiffuse = interiorDiff * interiorLightColor * attenuation;\n    \n    vec3 diffuse = keyDiffuse + interiorDiffuse;\n    \n    float hollowDist = hollowPumpkinSDF(pos);\n    float lidDist = lidSDF(pos);\n    float stalkDist = stalkSDF(pos);\n    \n    vec3 materialColor;\n    float fleshSpecular = 1.0;\n    \n    if (stalkDist < hollowDist && stalkDist < lidDist) {\n        materialColor = vec3(0.36, 0.57, 0.13);\n    } else if (lidDist < hollowDist) {\n        vec3 lidPos = pos;\n        lidPos.y -= lidRaise;\n        lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n        \n        float originalLidPumpkin = pumpkinSDF(lidPos);\n        float fleshDepth = max(0.0, -originalLidPumpkin + thickness);\n        \n        if (fleshDepth > 0.001) {\n            float depthFactor = clamp(fleshDepth / 0.1, 0.0, 1.0);\n            vec3 fleshColor = mix(vec3(1.2, 0.9, 0.4), vec3(0.8, 0.4, 0.1), depthFactor);\n            materialColor = fleshColor;\n            fleshSpecular = max(0., mix(0.8, 0.1, depthFactor * 20.));\n        } else {\n            materialColor = vec3(0.8, 0.4, 0.12);\n        }\n    } else {\n        float originalPumpkin = pumpkinSDF(pos);\n        float fleshDepth = max(0.0, -originalPumpkin + (thickness));\n        //shadow = clamp(10.* clamp(-originalPumpkin, 0.01, 10.5) * (1.-guv.x), 0., 0.6);\n\n        if (fleshDepth > 0.001) {\n            float depthFactor = clamp(fleshDepth / 0.1, 0.0, 1.0);\n            vec3 fleshColor = mix(vec3(1.2, 0.9, 0.4), vec3(0.8, 0.4, 0.1), depthFactor);\n\n            materialColor = fleshColor;\n            fleshSpecular = max(0., mix(0.8, 0.1, depthFactor * 20.));\n        } else {\n            materialColor = vec3(0.9, 0.45, 0.15);\n        }\n    }\n    \n    float subsurfaceDistance_val = calculateSubsurface(pos, interiorLightPos, subsurfaceDistance, subsurfaceAttenuation);\n    float subsurfaceFactor = subsurfaceDistance_val > 0.0 ? clamp(subsurfaceDistance_val, 0.0, 1.0) : 0.0;\n    vec3 subsurfaceLight = subsurfaceFactor * interiorLightColor;\n    \n    return (materialColor * (ambient + diffuse + subsurfaceLight) + fleshSpecular * keySpecular) ;\n}\n\n\n// Main function\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n#ifdef USE_SLIDERS\n    // Read current states\n    for (int i = 0; i < totalSliders; i++) {\n        vec4 state = getSliderState(iResolution.xy, i);\n        sliderValues[i] = state.r;\n        hasInteracted[i] = state.g > 0.25;\n        \n        // Default values before first interaction\n        if (!hasInteracted[i]) {\n            sliderValues[i] = i==14?0.0:0.5;\n        }\n    }\n#else\n    // In random mode, set up random seed (could be based on time, mouse, etc.)\n    randomSeed = iMouse.x + (iMouse.y/iResolution.y);  // Change over time, or use iMouse.x for user control\n#endif\n    \n#ifdef USE_SLIDERS\n    // Check for mouse interaction\n    bool mouseDown = (iMouse.z > 0.0); // abs() the z value\n    vec2 currentMousePos = abs(iMouse.xy); // Use current position for dragging, abs() as requested\n    vec2 clickPos = abs(iMouse.zw); // Click position, abs() as requested\n    \n    if (mouseDown) {\n        // Use click position to determine which slider was initially clicked\n        int activeSlider = getActiveSlider(clickPos, iResolution.xy);\n        if (activeSlider >= 0) {\n            // But use current mouse position for the actual value update (allows dragging)\n            vec2 sliderPos = getSliderPosition(iResolution.xy, activeSlider);\n            float sliderLength = getSliderLength(iResolution.xy);\n            sliderValues[activeSlider] = updateSliderValue(currentMousePos, sliderPos, sliderLength);\n            hasInteracted[activeSlider] = true;\n        }\n    }\n#endif\n\n    // Parameter assignments using new mapping system\n    lidRaise = mapLidRaise(getParamValue(0));\n    lidTiltX = mapLidTiltX(getParamValue(1));\n    lidTiltZ = mapLidTiltZ(getParamValue(2));\n    cutSphereY = mapCutSphereY(getParamValue(3));\n    cutSphereRadius = mapCutSphereRadius(getParamValue(4));\n    thickness = mapThickness(getParamValue(5));\n    lidGap = mapLidGap(getParamValue(6));\n    mouthSliderA = mapMouthSliderA(getParamValue(7));\n    mouthSliderB = mapMouthSliderB(getParamValue(8));\n    mouthSliderC = mapMouthSliderC(getParamValue(9));\n    eyeSliderA = mapEyeSliderA(getParamValue(11));\n    \n    // Subsurface scattering parameters (sliders 12-13)\n    float subsurfaceDistance = mapSubsurfaceDistance(getParamValue(12));\n    float subsurfaceAttenuation = mapSubsurfaceAttenuation(getParamValue(13));\n    \n    // Camera/scene parameters (sliders 14-19)\n    float focal = mapFocal(getParamValue(15));\n    float baseCameraDist = mapBaseCameraDist(getParamValue(16));\n    \n    // Stalk parameters (sliders 20-27)\n    stalkRadius = mapStalkRadius(getParamValue(20));\n    stalkStarN = int(mapStalkStarN(getParamValue(21)));\n    stalkStarM = mapStalkStarM(getParamValue(22));\n    stalkHeight = mapStalkHeight(getParamValue(23));\n    stalkTwist = mapStalkTwist(getParamValue(24));\n    stalkBend = mapStalkBend(getParamValue(25));\n    stalkTaper = mapStalkTaper(getParamValue(26));\n    stalkBulbHeight = mapStalkBulbHeight(getParamValue(27));\n    \n    // Pumpkin shape parameters (sliders 28-39)\n    k2 = mapK2(getParamValue(28));\n    m2 = mapM2(getParamValue(29));\n    n2 = mapN2(getParamValue(30));\n    k1 = mapK1(getParamValue(31));\n    m1 = mapM1(getParamValue(32));\n    n1 = mapN1(getParamValue(33));\n    k0 = mapK0(getParamValue(34));\n    m0 = mapM0(getParamValue(35));\n    n0 = mapN0(getParamValue(36));\n    h = mapH(getParamValue(37));\n    p = mapP(getParamValue(38));\n    g = mapG(getParamValue(39));\n    \n    // Derived parameters\n    stalkBulbRadius = cutSphereRadius * 0.6;\n    stalkHeightOffset = 0.0; // not used currently\n    faceScale = g*(p+.3)*((h+1.)/3.)*mapFaceScale(getParamValue(10));\n    faceDepth = 1.1;// should be fixed here now.\n    faceZ = 1.1;// should be fixed here now.\n    \n    // Screen-space magnify (scene-only)\n    float screenMag = mapScreenMag(getParamValue(17));\n        \n    baseCameraDist /= pow(max(0.5,focal), 2.);\n    screenMag /= pow(max(0.5,focal), 2.);\n    \n    vec2 suv = uv; // Save original UV for UI rendering\n    vec2 uvScene = uv / screenMag; // Scene-only magnification\n    \n    // Camera\n    float yaw = mapYaw(getParamValue(19));\n    float pitch = mapPitch(getParamValue(18));\n\n    vec3 target = vec3(0.0, 0.35, 0.0);\n    vec3 dir = vec3(cos(pitch) * cos(yaw),\n                    sin(pitch),\n                    cos(pitch) * sin(yaw));\n    vec3 ro = target - dir * baseCameraDist;\n\n    vec3 forward = normalize(target - ro);\n    vec3 upRef = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(forward, upRef));\n    vec3 up = cross(right, forward);\n\n    // Camera to world matrix (inverse of view matrix rotation part)\n    mat3 cameraMatrix = mat3(right, up, -forward);\n    vec3 rd = normalize(forward + uvScene.x * right + uvScene.y * up);\n    \n    vec3 color = vec3(0.8,1.0,1.);//vec3(0.0);\n    \n    float t = raymarch(ro, rd);\n\n    if (t < 50.0){\n        vec3 pos = ro + t * rd;\n        vec3 normal = getNormal(pos);\n        vec3 viewDir = normalize(ro - pos);\n        color = lighting(pos, normal, viewDir, subsurfaceDistance, subsurfaceAttenuation, cameraMatrix);\n\n    } else {\n        // Background\n        color = vec3(0.6, 0.8,1.);\n    }\n    \n    // Gamma correction\n    //color = pow(color, vec2(1.0/2.2).xxx);\n    color = atan(color);\n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) \n{ \n     \n    vec2 j = vec2(.5); \n    fragColor= vec4(0); \n    vec4 c; \n    mainImage0(c, fragCoord);\n    float s = 1.0 + floor(getParamValue(14) * 4.0);\n    float k;\n    for (k = s; k-- > .5; ) { \n        mainImage0(c, fragCoord + j - .5); \n        fragColor += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };fragColor /= s;fragColor.a==1.;\n    vec3 color = fragColor.rgb;\n    \n#ifdef USE_SLIDERS\n    // Render all sliders on top\n    vec3 sliderColor = renderSliders(fragCoord, iResolution.xy, sliderValues);\n    \n    if (sliderColor.x >= 0.0) {\n        color = sliderColor;\n    }\n    \n    // Write slider states to 8x5 pixel grid (40 sliders)\n    if (fragCoord.y < 5.0 && fragCoord.x < 8.0) {\n        int sliderIndex = int(fragCoord.x) + int(fragCoord.y) * 8;\n        //float startVal = 0.5;\n        //if(sliderIndex == 14) { startVal = 0.0;}\n        if (sliderIndex < totalSliders) {\n            fragColor = vec4(sliderValues[sliderIndex], hasInteracted[sliderIndex] ? 0.5 : 0.0, 0.0, 1.0);\n        } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n        \n    } else {\n        fragColor = vec4(color, 1.0);\n    }\n#else\n    // Random mode - no sliders\n    fragColor = vec4(color, 1.0);\n#endif\n} ",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3XSBR3",
    "date": "1762745162",
    "viewed": 55,
    "name": "New SL logo/splash screen",
    "description": "Click and drag!\nThis is the new animated, interactive logo for [url=https://sleditor.com]sleditor[/url]",
    "likes": 8,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "logo",
     "moebius",
     "splash",
     "sleditor"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n\nint PALETTE = 9;\nfloat gdist = 0.;\n// SDF for a box\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n\n// it's a tunnel (cylinder) with noise\n// added to it, rotated, etc\nfloat isolines(vec3 p) {\n\n    float s, i, n, T = iTime;\n\n    // distort p space with turbulence\n    p += cos(p.z+T+p.yzx*.5)*.6;\n\n    // sample cylinder\n    s = 4.-length(p.xy);\n\n    // rotate p for noise (aesthetic iirc)\n    p.xy *= mat2(cos(.3*T+vec4(0,33,11,0)));\n\n    // noise loop\n    for (n = .01; n < 1.; n += n )\n        s -= abs(dot(sin( p.z + T + 4.*p/n ), vec3(1.2))) * n;\n\n    return s;\n}\n\nvec3 fire(vec4 o, vec2 u) {\n    float d=1.,a,i,s,t = .1*(sin(iTime*.4) + iTime  );\n    vec3  p = iResolution;    \n    u = (u+u-p.xy)/p.y;\n    u *= mat2(cos(sin(iTime*.05)*2.+vec4(0,33,11,0)));\n    u += cos(t*vec2(.4,.8)) * vec2(.3,.1);\n    for(o*=0.; i++<64.; o += 1./s )\n        // sample position\n        // p = ro + rd * d, p.z += t * 1e1\n        p = vec3(u*d,d+t*1e1),\n        // get dist to iso lines\n        d += s = .01 + abs(isolines(p))*.15;\n    // color and tone map\n    return (vec4(1,.5,0.2,0)*o/1e3).rgb;\n}\n\n// U shape - semicircle with extended straight bars\nfloat letterU(vec2 p, float radius, float thickness, float extension) {\n    float shape = 1e10;\n    \n    // Bottom curved part - semicircle\n    float outer = length(p - vec2(0.0, 0.0)) - radius;\n    float inner = length(p - vec2(0.0, 0.0)) - (radius - thickness);\n    float ring = max(outer, -inner);\n    // Cut off the top half\n    ring = max(ring, p.y);\n    shape = min(shape, ring);\n    \n    // Left vertical bar extension\n    vec2 leftBarPos = vec2(-radius + thickness * 0.5, extension * 0.5);\n    float leftBar = sdBox(p - leftBarPos, vec2(thickness * 0.5, extension * 0.5));\n    shape = min(shape, leftBar);\n    \n    // Right vertical bar extension\n    vec2 rightBarPos = vec2(radius - thickness * 0.5, extension * 0.5);\n    float rightBar = sdBox(p - rightBarPos, vec2(thickness * 0.5, extension * 0.5));\n    shape = min(shape, rightBar);\n    \n    return shape;\n}\n\n// S shape made from two U shapes\nfloat letterS(vec2 p, float radius, float thickness, float extension, vec2 shift) {\n    // Bottom U - shifted down and right\n    vec2 bottomPos = p + shift;\n    float bottomU = letterU(bottomPos, radius, thickness, extension*0.4);\n    \n    // Top U - flipped and shifted up and left\n    vec2 topPos = p - shift;\n    topPos.y = -topPos.y; // Flip vertically\n    float topU = letterU(topPos, radius, thickness, extension);\n    \n    // Combine both U shapes to form S\n    return min(bottomU, topU);\n}\n\n// L shape made from two rectangles\nfloat letterL(vec2 p) {\n    // Vertical bar\n    float vertical = sdBox(p - vec2(0.0, 0.23), vec2(0.064, 0.34));\n    \n    // Horizontal bar (at the bottom)\n    float horizontal = sdBox(p - vec2(0.1165, -0.1), vec2(0.18, 0.064));\n    \n    // Combine both bars to form L\n    return min(vertical, horizontal);\n}\n\n// 2D rotation matrix\nmat2 rotate2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\nfloat rand(float n){return fract(cos(n*89.42)*343.42);}\nvec2 shake() {\n    return vec2(\n        sin(iTime*1e2),\n        cos(iTime*2e2)\n    ) * max(0.,1.2-iTime)/20.;\n}\nfloat nz(vec2 nv){\n    float o = 0.;\n    for (float i = .2; i < 2.;\n    o += abs(dot(sin(nv * i * 64.), vec2(.05))) / i,\n    i *= 1.4142);\n    return mix(o,  distance(vec2(0), nv), 0.5 + (sin(iTime)/2.));\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?nz(vec2(a,b)):s>0.3?b/(a==0.?0.01:a):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\n\nvec3 gpc(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gammaCorrection (vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\n\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = contrast(gpc(num),1.7);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n        return col;\n    } else {\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        return col;\n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., dc.r);\n    dc.g = min(1., dc.g);\n    dc.b = min(1., dc.b);\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\nvec3 mainAgg(vec2 uv, float seed, float pixely){\n   // uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n\n\n    uv = pixely>0.?(floor(uv/pixely))*pixely:uv;\n\n    uv += shake();\n    float zoom = 4. + (3.*(sin(iTime/1.5)+1.));\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    float o = nz(guv);\n   // float seed = floor(iTime/1.0);\n    PALETTE = int(floor(float(8)*rand(seed+66.)));\n    const int v = 24;\n    vec3 col = vec3(0);\n    float cn = 1.;\n    float values[v];\n    values[0] = 1.0;\n    values[1] = 10.0;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = 2.;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = 3.14159;\n   values[21] = atan(x, y)*4.;\n   values[22] = o;\n   values[23] = distance(vec2(x,y), vec2(0))*sin(atan(x, y));\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 30; int mini = 5;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n        }\n        if(abs(sub)<1.){seed+=100.;PALETTE = int(floor(float(8)*rand(seed+66.)));}\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            col += addColor(total, seed+float(i), values[21]);\n            cn+=1.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    return col;\n}\n\n\nvoid mainImage0(out vec4 c, vec2 p) {\n   p*=1.5;\n    p-=iResolution.xy/4.;\n\n    \n    float pix = 0.;\n\n\n        vec2 uv = (p - 0.5 * iResolution.xy) / iResolution.y;\n\n        \n        float wave = sin((uv.x+(iTime/5.))*50.)/3.;\n\n        wave += sin((uv.x+(iTime/3.))*17.)/3.;\n\n        wave += sin((uv.x+(iTime*-1.7))*19.)/7.;\n\n        wave += sin((uv.x+(iTime*1.9))*19.)/7.;\n\n        wave += sin((uv.x+(iTime*-1.2))*17.5)/1.5;\n\n        wave += sin((uv.x+(iTime*-1.5))*47.0)/1.0;\n        wave += sin((uv.x+(iTime*-0.5))*147.0)/3.0;\nwave += sin((uv.x+(iTime*0.5))*247.0)/4.0;\n        wave /=10.;\n        wave *= abs(uv.x);\n        float wav = abs(uv.y-wave);\n    vec2 luv = uv;\n        luv /=(3./(min(16.,iTime)/5.));\n       bool inside=true; if(luv.x<-0.15||luv.x>0.1){inside=false;}\n    // Rotate 100 degrees clockwise = -100 degrees = -1.745 radians\n    float angle = -radians(115.0);\n    luv = rotate2D(angle) * luv;\n    float radius = 0.21;\n    float thickness = 0.11;\n    float extension = 0.12;\n    vec2 shift = vec2(0.155, 0.05);\n    float distS = letterS(luv+vec2(-0.1,0.2), radius, thickness, extension, shift);\n        // L: just position it, no rotation\n\n    vec2 lPos = rotate2D(-angle) * (luv + vec2(-0.12,-0.23));\n    float distL = letterL(lPos);\n    \n    // Combine both letters\n    float dist = min(distS, distL);\n    if(!inside){dist = min(wav+0.01, dist);}\n    dist -= 0.015;\n    float pixely = 6.;//-floor(dist*40.);//pow(2., floor(abs((p.y/iResolution.y)-0.5)*10.));\n    float speedy = .03;\n    if(dist > 0.0) {\n   // if(left){p = (floor(p/pixely))*pixely;}\n    //speedy*=-1.5;\n    // p = (floor(p/pixely))*pixely;\n    pix = 0.1;\n    } else{\n       \n    }\n\n    vec2 r = iResolution.xy;\n    vec2 h = (p / r * 2. - 1.) * sqrt(r / r.yx);\n    vec3 g = vec3(1, h.yx) / (dot(h, h) + 1.) + vec3(-.5, 0, .5);\n    h = g.xy / dot(g, g);\n    h = vec2(atan(h.x, h.y), log(length(h))) / 6.28;\n    h += vec2(iMouse.x/400.,iMouse.y/400.)+iTime/40.;\n    h *= mat2(8, 5, -5, 8);\n    \n    // Get the cell coordinates (which cell we're in)\n    vec2 cellID = floor(h);\n    \n    //--------thx to chronos for this seam fix.------\n    cellID = mod(cellID, vec2(8,5));\n\n    float pma = .11;\n    float pmb = .07;\n    float pmc = .23;\n\n    float hotxA = floor(rand(floor(iTime*pma))*8.);\n    float hotyA = floor(rand(floor(iTime*pma))*5.);\n    float hotxB = floor(rand(floor(iTime*pmb))*8.);\n    float hotyB = floor(rand(floor(iTime*pmb))*5.);\n    float hotxC = floor(rand(floor(iTime*pmc))*8.);\n    float hotyC = floor(rand(floor(iTime*pmc))*5.);\n    float phaseA = fract(iTime*pma);\n    float phaseB = fract(iTime*pmb);\n    float phaseC = fract(iTime*pmc);\n    bool hotCellA = cellID==vec2(hotxA,hotyA);\n    bool hotCellB = cellID==vec2(hotxB,hotyB);\n    bool hotCellC = cellID==vec2(hotxC,hotyC);\n    bool hotCell = hotCellA||hotCellB||hotCellC;\n\n    float phase = hotCellA?phaseA:hotCellB?phaseB:phaseC;\n    float pcurve = 1.0 - smoothstep(0.0, 0.25, phase) + smoothstep(0.75, 1.0, phase);\n    if(pix>0.){pix = hotCell?0.05:0.08;}\n    \n    // Get local UV within the cell (0 to 1)\n    vec2 cellUV = fract(h);\n    \n    // Create a unique seed from cell coordinates\n    // Simple hash - you can make this more sophisticated if needed\n    float seed = cellID.x + cellID.y * 10.0;\n    // Or better hash:\n    // float seed = dot(cellID, vec2(127.1, 311.7));\n    // seed = fract(sin(seed) * 43758.5453);\n    \n    // Now call your pattern function:\n    // vec3 pattern = yourPatternFunction(cellUV, seed);\n    \n    // Example visualization showing the UVs and cell IDs:\n    vec3 col = mainAgg(cellUV, seed, pix);\n\n    if(dist>0.){p = (floor(p/6.))*6.;}\n\n    vec3  cf = fire(c,p);\n    if(hotCell&&dist<0.){col=cf;}\n    // Or keep the original square pattern:\n    // c = vec4(max(abs(cellUV.x - .5), abs(cellUV.y - .5)) * 2.);\n    if(dist<0.){\n        c = vec4(col, 1.0)-pow(vec4(max(abs(cellUV.x - .5), abs(cellUV.y - .5)) * 2.15),vec4(16.))/3.;\n    } else{\n        c = vec4(col, 1.0);\n    }\n    \n\n    \n    // Fill the S\n     \n     \n    if(dist >= 0.0 && !hotCell) {\n       c.rgb = clamp(c.rgb, vec3(0), vec3(1));\n        c.b=1.;\n        c.rgb+=tanh(dist*12.);\n\n\n        //c=tanh(c*1.9);\n        \n\n\n    } else if (dist >= 0.0 && hotCell){\n       //c.rgb=c.rgb*abs(dist*103.);\n        //c.b=.9;\n        if(c.r>0.5||c.g>0.5||c.b<0.3){\n            c.rgb = (c.rgb+vec3(4.))/3.;\n        } else {\n            c.rgb = (c.rgb+vec3(2.))/2.;\n        }\n        c.rgb=cf.bgr+0.5;//mix(c.rgb, vec3(1), pcurve);\n    } //else if(!hotCell){}\n    float thr = clamp(1.-abs(dist*100.), 0.0, 1.0);\n    c = mix(c, vec4(0,0.0,0.5,1), thr);\n    gdist=dist;\n    //if(wav<0.003){c.rgb=vec3(0,0,0.3);}\n\n        if(dist>0.){c = mix(c, cf.bgrr, max(0.,min(1.,tanh(dist*2.))));}\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 1., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n    //o.rgb = contrast(o.rgb,1.5);\n    o=gdist>0.?tanh(o*1.9):tanh(o*1.4);\n   \n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wftcW7",
    "date": "1763706712",
    "viewed": 83,
    "name": "SDF Editor Spider",
    "description": "I'm using three axes of symmetry here to turn one leg into eight.\nMade with a node based SDF tree editor I'm working on.\nCurrently it's standalone and has shadertoy glsl export, but I will integrate it with sleditor at some point.\n(This took 10 min)",
    "likes": 9,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "domain",
     "repetition",
     "spider",
     "sleditor",
     "sdfeditor"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Created with SDF Editor: https://www.sleditor.com/SDFeditor.html\n// Code output pasted straight into Shadertoy\n\n// SDF Primitives and Operations\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdCylinder(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdPlane(vec3 p, float h) {\n    return p.y - h;\n}\n\nfloat sdPyramid(vec3 p, float h) {\n    float m2 = h * h + 0.25;\n    p.xz = abs(p.xz);\n    if (p.z > p.x) {\n        p.xz = p.zx;\n    }\n    p.xz -= vec2(0.5);\n    vec3 q = vec3(p.z, h * p.y - 0.5 * p.x, h * p.x + 0.5 * p.y);\n    float s = max(-q.x, 0.0);\n    float t = clamp((q.y - 0.5 * p.z) / (m2 + 0.25), 0.0, 1.0);\n    float a = m2 * (q.x + s) * (q.x + s) + q.y * q.y;\n    float b = m2 * (q.x + 0.5 * t) * (q.x + 0.5 * t) + (q.y - m2 * t) * (q.y - m2 * t);\n    float d2 = (min(q.y, -q.x * m2 - 0.5 * q.y) > 0.0) ? 0.0 : min(a, b);\n    return sqrt((d2 + q.z * q.z) / m2) * sign(max(q.z, -p.y));\n}\n\nfloat sdVesicaSegment(vec3 p, vec3 a, vec3 b, float w) {\n    vec3 c = (a + b) * 0.5;\n    vec3 ba = b - a;\n    float l = length(ba);\n    vec3 v = ba / max(l, 0.0001);\n    vec3 rel = p - c;\n    float y = dot(rel, v);\n    vec2 q = vec2(length(rel - y * v), abs(y));\n    float r = 0.5 * l;\n    float ww = max(w, 0.0001);\n    float d = 0.5 * (r * r - ww * ww) / ww;\n    vec3 h = (r * q.x < d * (q.y - r)) ? vec3(0.0, r, 0.0) : vec3(-d, 0.0, d + ww);\n    return length(q - h.xy) - h.z;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nfloat opXor(float d1, float d2) {\n    return max(min(d1, d2), -max(d1, d2));\n}\n\nmat3 rotateX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n}\n\nmat3 rotateZ(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n}\n\n\nfloat sceneSDF(vec3 p) {\n    vec3 d_node_29_p = p;\n    d_node_29_p -= vec3(0.000, -0.2, 0.000);\n    d_node_29_p *= rotateY(iTime);\n    d_node_29_p *= rotateZ(0.);\n    float d_node_29_scale = max(0.850, 0.0001);\n    d_node_29_p /= d_node_29_scale;\n    vec3 d_node_26_p = d_node_29_p;\n    d_node_26_p -= vec3(0.000, 0.000, -0.500);\n    d_node_26_p *= rotateY(-0.0349);\n    float d_node_26_scale = max(1.000, 0.0001);\n    d_node_26_p /= d_node_26_scale;\n    vec3 d_node_24_p = d_node_26_p;\n    d_node_24_p -= vec3(0.000, 0.600, -0.200);\n    float d_node_24_scale = max(1.000, 0.0001);\n    d_node_24_p /= d_node_24_scale;\n    float d_node_24 = sdSphere(d_node_24_p, 0.500);\n    d_node_24 *= d_node_24_scale;\n    vec3 d_node_28_p = d_node_26_p;\n    d_node_28_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_28_scale = max(1.000, 0.0001);\n    d_node_28_p /= d_node_28_scale;\n    vec3 d_node_25_p = d_node_28_p;\n    d_node_25_p -= vec3(0.000, 0.400, 0.000);\n    float d_node_25_scale = max(0.400, 0.0001);\n    d_node_25_p /= d_node_25_scale;\n    float d_node_25 = sdBox(d_node_25_p, vec3(0.350, 0.200, 1.600));\n    d_node_25 *= d_node_25_scale;\n    float d_node_28 = d_node_25 - 0.110;\n    d_node_28 *= d_node_28_scale;\n    float d_node_26 = opSmoothUnion(d_node_24, d_node_28, 0.410);\n    d_node_26 *= d_node_26_scale;\n    vec3 d_node_23_p = d_node_29_p;\n    d_node_23_p -= vec3(0.000, 0.100, -0.200);\n    d_node_23_p *= rotateY(-0.1047);\n    float d_node_23_scale = max(1.000, 0.0001);\n    d_node_23_p /= d_node_23_scale;\n    vec3 d_node_23_warp = d_node_23_p;\n    d_node_23_warp.x = abs(d_node_23_warp.x);\n    vec3 d_node_22_p = d_node_23_warp;\n    d_node_22_p -= vec3(0.300, 0.000, 0.000);\n    d_node_22_p *= rotateY(-1.3439);\n    float d_node_22_scale = max(0.750, 0.0001);\n    d_node_22_p /= d_node_22_scale;\n    vec3 d_node_22_warp = d_node_22_p;\n    d_node_22_warp.x = abs(d_node_22_warp.x);\n    vec3 d_node_21_p = d_node_22_warp;\n    d_node_21_p -= vec3(0.200, 0.000, 0.000);\n    d_node_21_p *= rotateX(0.0873);\n    d_node_21_p *= rotateY(-0.1920);\n    float d_node_21_scale = max(1.000, 0.0001);\n    d_node_21_p /= d_node_21_scale;\n    vec3 d_node_21_warp = d_node_21_p;\n    d_node_21_warp.x = abs(d_node_21_warp.x);\n    vec3 d_node_13_p = d_node_21_warp;\n    d_node_13_p -= vec3(0.100, 0.100, 0.100);\n    d_node_13_p *= rotateX(0.0349);\n    d_node_13_p *= rotateY(-1.6930);\n    d_node_13_p *= rotateZ(-0.1047);\n    float d_node_13_scale = max(0.550, 0.0001);\n    d_node_13_p /= d_node_13_scale;\n    vec3 d_node_14_p = d_node_13_p;\n    d_node_14_p -= vec3(0.400, 0.000, 0.000);\n    d_node_14_p *= rotateZ(0.1920);\n    float d_node_14_scale = max(1.000, 0.0001);\n    d_node_14_p /= d_node_14_scale;\n    float d_node_14 = sdCylinder(d_node_14_p, 0.100, 0.300);\n    d_node_14 *= d_node_14_scale;\n    vec3 d_node_15_p = d_node_13_p;\n    d_node_15_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_15_scale = max(1.000, 0.0001);\n    d_node_15_p /= d_node_15_scale;\n    vec3 d_node_12_p = d_node_15_p;\n    d_node_12_p -= vec3(0.000, 0.000, 0.000);\n    d_node_12_p *= rotateZ(0.5411);\n    float d_node_12_scale = max(1.050, 0.0001);\n    d_node_12_p /= d_node_12_scale;\n    vec3 d_node_11_p = d_node_12_p;\n    d_node_11_p -= vec3(0.400, 0.000, 0.000);\n    float d_node_11_scale = max(1.000, 0.0001);\n    d_node_11_p /= d_node_11_scale;\n    float d_node_11 = sdSphere(d_node_11_p, 0.150);\n    d_node_11 *= d_node_11_scale;\n    vec3 d_node_10_p = d_node_12_p;\n    d_node_10_p -= vec3(-0.200, 0.000, 0.000);\n    float d_node_10_scale = max(1.350, 0.0001);\n    d_node_10_p /= d_node_10_scale;\n    float d_node_10 = sdVesicaSegment(d_node_10_p, vec3(-1.100, 0.000, 0.000), vec3(0.500, 0.000, 0.000), 0.120);\n    d_node_10 *= d_node_10_scale;\n    float d_node_12 = opSmoothUnion(d_node_11, d_node_10, 0.120);\n    d_node_12 *= d_node_12_scale;\n    vec3 d_node_17_p = d_node_15_p;\n    d_node_17_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_17_scale = max(1.000, 0.0001);\n    d_node_17_p /= d_node_17_scale;\n    vec3 d_node_16_p = d_node_17_p;\n    d_node_16_p -= vec3(-1.800, 0.400, 0.000);\n    d_node_16_p *= rotateZ(-0.9948);\n    float d_node_16_scale = max(1.000, 0.0001);\n    d_node_16_p /= d_node_16_scale;\n    float d_node_16 = sdVesicaSegment(d_node_16_p, vec3(-1.400, 0.000, 0.000), vec3(0.500, 0.000, 0.000), 0.160);\n    d_node_16 *= d_node_16_scale;\n    vec3 d_node_18_p = d_node_17_p;\n    d_node_18_p -= vec3(-2.800, -0.900, 0.000);\n    d_node_18_p *= rotateZ(-0.5061);\n    float d_node_18_scale = max(0.450, 0.0001);\n    d_node_18_p /= d_node_18_scale;\n    float d_node_18 = sdVesicaSegment(d_node_18_p, vec3(-1.500, 0.000, 0.000), vec3(0.500, 0.000, 0.000), 0.170);\n    d_node_18 *= d_node_18_scale;\n    float d_node_17 = opSmoothUnion(d_node_16, d_node_18, 0.550);\n    d_node_17 *= d_node_17_scale;\n    float d_node_15 = opSmoothUnion(d_node_12, d_node_17, 0.560);\n    d_node_15 *= d_node_15_scale;\n    float d_node_13 = min(d_node_14, d_node_15);\n    d_node_13 *= d_node_13_scale;\n    float d_node_21 = d_node_13;\n    d_node_21 *= d_node_21_scale;\n    float d_node_22 = d_node_21;\n    d_node_22 *= d_node_22_scale;\n    float d_node_23 = d_node_22;\n    d_node_23 *= d_node_23_scale;\n    float d_node_29 = min(d_node_26, d_node_23);\n    d_node_29 *= d_node_29_scale;\n\n    return d_node_29;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),\n        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\n        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float t = 0.0;\n    vec3 col = vec3(1.0);\n    \n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = sceneSDF(p);\n        \n        if (d < 0.001) {\n            vec3 n = calcNormal(p);\n            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n            float diff = max(dot(n, lightDir), 0.0);\n            float amb = 0.3;\n            col = vec3(0.85, 0.75, 0.7) * (diff + amb);\n            break;\n        }\n        \n        if (t > 20.0) break;\n        t += d;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3c3cRS",
    "date": "1763712089",
    "viewed": 95,
    "name": "Spider + sleditor #slai",
    "description": "This is the previous shader imported to sleditor, and transformed using the #slai command\nIt's not a magic bullet, wont perform miracles and still needs an experienced developer to guide it .\nBut these two tools in combination will save a lot of time.",
    "likes": 14,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "domain",
     "repetition",
     "spider",
     "sleditor",
     "sdfeditor"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Model created with SDF Editor: https://www.sleditor.com/SDFeditor.html\n// Enhanced in sleditor using Claude Sonnet 4.5\n\n// SLAI request: Could you improve this sdf spider? maybe add a head with eyes, some colour, anything else you think appropriate.\n\n// Response: head, eyes, better body definition, colors, and ambient occlusion\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdVesicaSegment(vec3 p, vec3 a, vec3 b, float w) {\n    vec3 c = (a + b) * 0.5;\n    vec3 ba = b - a;\n    float l = length(ba);\n    vec3 v = ba / max(l, 0.0001);\n    vec3 rel = p - c;\n    float y = dot(rel, v);\n    vec2 q = vec2(length(rel - y * v), abs(y));\n    float r = 0.5 * l;\n    float ww = max(w, 0.0001);\n    float d = 0.5 * (r * r - ww * ww) / ww;\n    vec3 h = (r * q.x < d * (q.y - r)) ? vec3(0.0, r, 0.0) : vec3(-d, 0.0, d + ww);\n    return length(q - h.xy) - h.z;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nmat3 rotateX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n}\n\nmat3 rotateZ(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n}\n\n// Material ID tracking\nfloat gMaterialID = 0.0;\n\nfloat sceneSDF(vec3 p) {\n    vec3 d_node_29_p = p;\n    d_node_29_p -= vec3(0.000, -0.2, 0.000);\n    d_node_29_p *= rotateY(-0.5+(iMouse.z!=0.?iMouse.x*5./iResolution.x:iTime * 0.5));\n    d_node_29_p *= rotateZ(0.);\n    float d_node_29_scale = max(0.850, 0.0001);\n    d_node_29_p /= d_node_29_scale;\n    \n    // BODY SECTION\n    vec3 d_node_26_p = d_node_29_p;\n    d_node_26_p -= vec3(0.000, 0.000, -0.500);\n    d_node_26_p *= rotateY(-0.0349);\n    float d_node_26_scale = max(1.000, 0.0001);\n    d_node_26_p /= d_node_26_scale;\n    vec3 d_node_24_p = d_node_26_p;\n    d_node_24_p -= vec3(0.000, 0.600, -0.200);\n    float d_node_24_scale = max(1.000, 0.0001);\n    d_node_24_p /= d_node_24_scale;\n    float d_node_24 = sdSphere(d_node_24_p, 0.500);\n    d_node_24 *= d_node_24_scale;\n    vec3 d_node_28_p = d_node_26_p;\n    d_node_28_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_28_scale = max(1.000, 0.0001);\n    d_node_28_p /= d_node_28_scale;\n    vec3 d_node_25_p = d_node_28_p;\n    d_node_25_p -= vec3(0.000, 0.400, 0.000);\n    float d_node_25_scale = max(0.400, 0.0001);\n    d_node_25_p /= d_node_25_scale;\n    float d_node_25 = sdBox(d_node_25_p, vec3(0.350, 0.200, 1.600));\n    d_node_25 *= d_node_25_scale;\n    float d_node_28 = d_node_25 - 0.110;\n    d_node_28 *= d_node_28_scale;\n    float d_node_26 = opSmoothUnion(d_node_24, d_node_28, 0.410);\n    d_node_26 *= d_node_26_scale;\n    \n    // LEGS SECTION\n    vec3 d_node_23_p = d_node_29_p;\n    d_node_23_p -= vec3(0.000, 0.100, -0.200);\n    d_node_23_p *= rotateY(-0.1047);\n    float d_node_23_scale = max(1.000, 0.0001);\n    d_node_23_p /= d_node_23_scale;\n    vec3 d_node_23_warp = d_node_23_p;\n    d_node_23_warp.x = abs(d_node_23_warp.x);\n    vec3 d_node_22_p = d_node_23_warp;\n    d_node_22_p -= vec3(0.300, 0.000, 0.000);\n    d_node_22_p *= rotateY(-1.3439);\n    float d_node_22_scale = max(0.750, 0.0001);\n    d_node_22_p /= d_node_22_scale;\n    vec3 d_node_22_warp = d_node_22_p;\n    d_node_22_warp.x = abs(d_node_22_warp.x);\n    vec3 d_node_21_p = d_node_22_warp;\n    d_node_21_p -= vec3(0.200, 0.000, 0.000);\n    d_node_21_p *= rotateX(0.0873);\n    d_node_21_p *= rotateY(-0.1920);\n    float d_node_21_scale = max(1.000, 0.0001);\n    d_node_21_p /= d_node_21_scale;\n    vec3 d_node_21_warp = d_node_21_p;\n    d_node_21_warp.x = abs(d_node_21_warp.x);\n    vec3 d_node_13_p = d_node_21_warp;\n    d_node_13_p -= vec3(0.100, 0.100, 0.100);\n    d_node_13_p *= rotateX(0.0349);\n    d_node_13_p *= rotateY(-1.6930);\n    d_node_13_p *= rotateZ(-0.1047);\n    float d_node_13_scale = max(0.550, 0.0001);\n    d_node_13_p /= d_node_13_scale;\n    vec3 d_node_14_p = d_node_13_p;\n    d_node_14_p -= vec3(0.400, 0.000, 0.000);\n    d_node_14_p *= rotateZ(0.1920);\n    float d_node_14_scale = max(1.000, 0.0001);\n    d_node_14_p /= d_node_14_scale;\n    float d_node_14 = sdCylinder(d_node_14_p, 0.100, 0.300);\n    d_node_14 *= d_node_14_scale;\n    vec3 d_node_15_p = d_node_13_p;\n    d_node_15_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_15_scale = max(1.000, 0.0001);\n    d_node_15_p /= d_node_15_scale;\n    vec3 d_node_12_p = d_node_15_p;\n    d_node_12_p -= vec3(0.000, 0.000, 0.000);\n    d_node_12_p *= rotateZ(0.5411);\n    float d_node_12_scale = max(1.050, 0.0001);\n    d_node_12_p /= d_node_12_scale;\n    vec3 d_node_11_p = d_node_12_p;\n    d_node_11_p -= vec3(0.400, 0.000, 0.000);\n    float d_node_11_scale = max(1.000, 0.0001);\n    d_node_11_p /= d_node_11_scale;\n    float d_node_11 = sdSphere(d_node_11_p, 0.150);\n    d_node_11 *= d_node_11_scale;\n    vec3 d_node_10_p = d_node_12_p;\n    d_node_10_p -= vec3(-0.200, 0.000, 0.000);\n    float d_node_10_scale = max(1.350, 0.0001);\n    d_node_10_p /= d_node_10_scale;\n    float d_node_10 = sdVesicaSegment(d_node_10_p, vec3(-1.100, 0.000, 0.000), vec3(0.500, 0.000, 0.000), 0.120);\n    d_node_10 *= d_node_10_scale;\n    float d_node_12 = opSmoothUnion(d_node_11, d_node_10, 0.120);\n    d_node_12 *= d_node_12_scale;\n    vec3 d_node_17_p = d_node_15_p;\n    d_node_17_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_17_scale = max(1.000, 0.0001);\n    d_node_17_p /= d_node_17_scale;\n    vec3 d_node_16_p = d_node_17_p;\n    d_node_16_p -= vec3(-1.800, 0.400, 0.000);\n    d_node_16_p *= rotateZ(-0.9948);\n    float d_node_16_scale = max(1.000, 0.0001);\n    d_node_16_p /= d_node_16_scale;\n    float d_node_16 = sdVesicaSegment(d_node_16_p, vec3(-1.400, 0.000, 0.000), vec3(0.500, 0.000, 0.000), 0.160);\n    d_node_16 *= d_node_16_scale;\n    vec3 d_node_18_p = d_node_17_p;\n    d_node_18_p -= vec3(-2.800, -0.900, 0.000);\n    d_node_18_p *= rotateZ(-0.5061);\n    float d_node_18_scale = max(0.450, 0.0001);\n    d_node_18_p /= d_node_18_scale;\n    float d_node_18 = sdVesicaSegment(d_node_18_p, vec3(-1.500, 0.000, 0.000), vec3(0.500, 0.000, 0.000), 0.170);\n    d_node_18 *= d_node_18_scale;\n    float d_node_17 = opSmoothUnion(d_node_16, d_node_18, 0.550);\n    d_node_17 *= d_node_17_scale;\n    float d_node_15 = opSmoothUnion(d_node_12, d_node_17, 0.560);\n    d_node_15 *= d_node_15_scale;\n    float d_node_13 = min(d_node_14, d_node_15);\n    d_node_13 *= d_node_13_scale;\n    float d_node_21 = d_node_13;\n    d_node_21 *= d_node_21_scale;\n    float d_node_22 = d_node_21;\n    d_node_22 *= d_node_22_scale;\n    float d_node_23 = d_node_22;\n    d_node_23 *= d_node_23_scale;\n    \n    float bodyAndLegs = min(d_node_26, d_node_23);\n    \n    // HEAD SECTION - positioned in front of body\n    vec3 headPos = d_node_29_p;\n    headPos -= vec3(0.0, 0.4, 0.8);\n    float head = sdEllipsoid(headPos, vec3(0.35, 0.3, 0.4));\n    \n    // EYES - two large spider eyes\n    vec3 eyeL = d_node_29_p;\n    eyeL -= vec3(-0.18, 0.45, 1.0);\n    float eyeLeftOuter = sdSphere(eyeL, 0.15);\n    \n    vec3 eyeR = d_node_29_p;\n    eyeR -= vec3(0.18, 0.45, 1.0);\n    float eyeRightOuter = sdSphere(eyeR, 0.15);\n    \n    // Eye pupils (for material ID)\n    vec3 pupilL = d_node_29_p;\n    pupilL -= vec3(-0.18, 0.45, 1.12);\n    float pupilLeft = sdSphere(pupilL, 0.08);\n    \n    vec3 pupilR = d_node_29_p;\n    pupilR -= vec3(0.18, 0.45, 1.12);\n    float pupilRight = sdSphere(pupilR, 0.08);\n    \n    // Smaller side eyes\n    vec3 sideEyeL = d_node_29_p;\n    sideEyeL -= vec3(-0.32, 0.35, 0.95);\n    float sideEyeLeft = sdSphere(sideEyeL, 0.08);\n    \n    vec3 sideEyeR = d_node_29_p;\n    sideEyeR -= vec3(0.32, 0.35, 0.95);\n    float sideEyeRight = sdSphere(sideEyeR, 0.08);\n    \n    // Combine eyes with head\n    float eyes = min(eyeLeftOuter, eyeRightOuter);\n    eyes = min(eyes, min(sideEyeLeft, sideEyeRight));\n    \n    // Add fangs\n    vec3 fangL = d_node_29_p;\n    fangL -= vec3(-0.12, 0.2, 1.05);\n    fangL *= rotateX(0.3);\n    float fangLeft = sdCylinder(fangL, 0.03, 0.15);\n    \n    vec3 fangR = d_node_29_p;\n    fangR -= vec3(0.12, 0.2, 1.05);\n    fangR *= rotateX(0.3);\n    float fangRight = sdCylinder(fangR, 0.03, 0.15);\n    \n    float fangs = min(fangLeft, fangRight);\n    \n    // Combine head features\n    float headComplete = opSmoothUnion(head, eyes, 0.05);\n    headComplete = min(headComplete, fangs);\n    \n    // Combine everything\n    float spider = opSmoothUnion(bodyAndLegs, headComplete, 0.3);\n    spider *= d_node_29_scale;\n    \n    // Track material - check if we hit eyes\n    float pupils = min(pupilLeft, pupilRight);\n    pupils *= d_node_29_scale;\n    \n    if (pupils < spider) {\n        gMaterialID = 2.0; // Pupils\n        return pupils;\n    } else if (eyes * d_node_29_scale < spider) {\n        gMaterialID = 1.0; // Eyes\n        return eyes * d_node_29_scale;\n    } else {\n        gMaterialID = 0.0; // Body\n        return spider;\n    }\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),\n        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\n        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)\n    ));\n}\n\n// Calculate ambient occlusion\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.12 * float(i) / 4.0;\n        float d = sceneSDF(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera with slight movement\n    float camAngle = sin(iTime * 0.2) * 0.3;\n    vec3 ro = vec3(sin(camAngle) * 3.0, 0.3, cos(camAngle) * 3.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    float t = 0.0;\n    vec3 col = vec3(0.15, 0.2, 0.3); // Dark blue background\n    \n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = sceneSDF(p);\n        \n        if (d < 0.001) {\n            vec3 n = calcNormal(p);\n            \n            // Lighting setup\n            vec3 lightDir1 = normalize(vec3(1.0, 1.0, 1.0));\n            vec3 lightDir2 = normalize(vec3(-0.5, 0.5, 0.5));\n            \n            float diff1 = max(dot(n, lightDir1), 0.0);\n            float diff2 = max(dot(n, lightDir2), 0.0) * 0.5;\n            \n            // Specular\n            vec3 viewDir = normalize(ro - p);\n            vec3 reflectDir = reflect(-lightDir1, n);\n            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n            \n            // Ambient occlusion\n            float ao = calcAO(p, n);\n            \n            // Material colors based on ID\n            vec3 baseColor;\n            if (gMaterialID > 1.5) {\n                // Pupils - black\n                baseColor = vec3(0.05, 0.05, 0.1);\n                spec *= 2.0;\n            } else if (gMaterialID > 0.5) {\n                // Eyes - glossy white/yellow\n                baseColor = vec3(0.95, 0.92, 0.7);\n                spec *= 3.0;\n            } else {\n                // Body - dark brown/black with orange markings\n                float pattern = sin(p.x * 10.0) * sin(p.y * 10.0) * sin(p.z * 10.0);\n                vec3 color1 = vec3(0.15, 0.1, 0.08); // Dark brown\n                vec3 color2 = vec3(0.6, 0.3, 0.1); // Orange\n                baseColor = mix(color1, color2, smoothstep(-0.3, 0.3, pattern) * 0.3);\n            }\n            \n            // Combine lighting\n            float amb = 0.2;\n            col = baseColor * (diff1 + diff2 + amb) * ao;\n            col += vec3(1.0, 0.9, 0.8) * spec * 0.5;\n            \n            // Rim lighting for depth\n            float rim = 1.0 - max(dot(viewDir, n), 0.0);\n            rim = pow(rim, 3.0);\n            col += vec3(0.3, 0.2, 0.4) * rim * 0.5;\n            \n            break;\n        }\n        \n        if (t > 20.0) break;\n        t += d;\n    }\n    \n    // Vignette\n    float vignette = 1.0 - length(uv) * 0.3;\n    col *= vignette;\n    \n    // Tone mapping and gamma correction\n    col = col / (col + vec3(1.0));\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfdyzX",
    "date": "1763932406",
    "viewed": 68,
    "name": "Flying Skull in smoke",
    "description": "Another shader assembled using tools I'm building, SDF modelling was not the bottleneck it used to be",
    "likes": 13,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "smoke",
     "skull",
     "sleditor",
     "sdfeditor"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// made with SDFeditor and SLeditor\n// https://www.sleditor.com/\n// https://www.sleditor.com/SDFeditor.html\n// smoke borrowed from a diatribes shader :)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdPlane(vec3 p, float h) {\n    return p.y - h;\n}\n\nfloat sdPyramid(vec3 p, float h) {\n    float m2 = h * h + 0.25;\n    p.xz = abs(p.xz);\n    if (p.z > p.x) {\n        p.xz = p.zx;\n    }\n    p.xz -= vec2(0.5);\n    vec3 q = vec3(p.z, h * p.y - 0.5 * p.x, h * p.x + 0.5 * p.y);\n    float s = max(-q.x, 0.0);\n    float t = clamp((q.y - 0.5 * p.z) / (m2 + 0.25), 0.0, 1.0);\n    float a = m2 * (q.x + s) * (q.x + s) + q.y * q.y;\n    float b = m2 * (q.x + 0.5 * t) * (q.x + 0.5 * t) + (q.y - m2 * t) * (q.y - m2 * t);\n    float d2 = (min(q.y, -q.x * m2 - 0.5 * q.y) > 0.0) ? 0.0 : min(a, b);\n    return sqrt((d2 + q.z * q.z) / m2) * sign(max(q.z, -p.y));\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nmat3 rotateX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n}\n\nmat3 rotateZ(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n}\n\nfloat hash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise(vec3 x) {\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(mix(hash(i + vec3(0, 0, 0)), \n                       hash(i + vec3(1, 0, 0)), f.x),\n                   mix(hash(i + vec3(0, 1, 0)), \n                       hash(i + vec3(1, 1, 0)), f.x), f.y),\n               mix(mix(hash(i + vec3(0, 0, 1)), \n                       hash(i + vec3(1, 0, 1)), f.x),\n                   mix(hash(i + vec3(0, 1, 1)), \n                       hash(i + vec3(1, 1, 1)), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    float amp = 0.5;\n    for(int i = 0; i < 5; i++) {\n        f += amp * noise(p);\n        p *= 2.0;\n        amp *= 0.5;\n    }\n    return f;\n}\n\nvec3 getSkullPosition(float time) {\n\n    float emergeFactor = smoothstep(0.0, 10.0, time);\n    float t1 = time * 0.4;\n    float t2 = time * 0.3;\n    float t3 = time * 0.7;\n    \n    float x = sin(t1) * 2.0;\n    float z = sin(t1 * 2.0) * 1.5;\n\n    float y = -4.0 + emergeFactor * 6.0 + sin(t2) * 1.0 + cos(t3) * 0.8;\n    \n    x += cos(t2) * 1.0;\n    z += sin(t2 * 0.5) * 1.0;\n    \n    return vec3(x, y, z);\n}\n\n\nmat3 lookAtRotation(vec3 forward, vec3 up) {\n    vec3 f = normalize(forward);\n    vec3 r = normalize(cross(up, f));\n    vec3 u = cross(f, r);\n    return mat3(r, u, f);\n}\n\nmat3 getSkullRotation(float time) {\n    \n    float dt = 0.01; \n    vec3 pos1 = getSkullPosition(time);\n    vec3 pos2 = getSkullPosition(time - dt);\n    vec3 velocity = (pos2 - pos1) / dt;\n    \n\n    if(length(velocity) < 0.01) {\n        velocity = vec3(0.0, 0.0, 1.0);\n    }\n    \n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    mat3 velocityRotation = lookAtRotation(velocity, up);\n    \n\n    float tilt = time * 0.5;\n    mat3 bankRotation = rotateZ(sin(time * 0.3) * 0.15);\n    \n    return velocityRotation * bankRotation;\n}\n\nfloat cloudDensity(vec3 p) {\n    float s = 0.0;\n    float n = 0.1;\n    \n\n    for(int i = 0; i < 4; i++) {\n        s -= abs(dot(sin(iTime * 0.5 + p / n), vec3(1.0))) * n * 0.3;\n        n *= 2.0;\n    }\n    \n    return s;\n}\n\nfloat sceneSDF(vec3 p) {\n    vec3 skullPos = getSkullPosition(iTime);\n    mat3 skullRot = getSkullRotation(iTime);\n    vec3 localP = skullRot * (p - skullPos);\n    \n    vec3 d_node_1_p = localP;\n\n    d_node_1_p *= rotateX(-0.0873);\n    d_node_1_p *= rotateY(-0.0349);\n    float d_node_1_scale = max(0.950, 0.0001);\n    d_node_1_p /= d_node_1_scale;\n    vec3 d_node_1_warp = d_node_1_p;\n    d_node_1_warp.x = abs(d_node_1_warp.x);\n    vec3 d_node_0_p = d_node_1_warp;\n    d_node_0_p -= vec3(0.700, 0.100, 0.300);\n    d_node_0_p *= rotateX(0.3491);\n    d_node_0_p *= rotateY(0.2967);\n    d_node_0_p *= rotateZ(0.3142);\n    float d_node_0_scale = max(1.000, 0.0001);\n    d_node_0_p /= d_node_0_scale;\n    float d_node_0 = sdSphere(d_node_0_p, 0.400);\n    d_node_0 *= d_node_0_scale;\n    float d_node_1 = d_node_0;\n    d_node_1 *= d_node_1_scale;\n    vec3 d_node_16_p = localP;\n    d_node_16_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_16_scale = max(1.000, 0.0001);\n    d_node_16_p /= d_node_16_scale;\n    vec3 d_node_14_p = d_node_16_p;\n    d_node_14_p -= vec3(0.000, -1.900, -0.600);\n    float d_node_14_scale = max(0.550, 0.0001);\n    d_node_14_p /= d_node_14_scale;\n    vec3 d_node_14_warp = d_node_14_p;\n    d_node_14_warp.x = abs(d_node_14_warp.x);\n    vec3 d_node_13_p = d_node_14_warp;\n    d_node_13_p -= vec3(0.500, 1.300, -0.800);\n    float d_node_13_scale = max(2.500, 0.0001);\n    d_node_13_p /= d_node_13_scale;\n    vec3 d_node_13_warp = d_node_13_p;\n    d_node_13_warp.x = abs(d_node_13_warp.x);\n    vec3 d_node_12_p = d_node_13_warp;\n    d_node_12_p -= vec3(0.100, 0.000, 1.300);\n    float d_node_12_scale = max(0.400, 0.0001);\n    d_node_12_p /= d_node_12_scale;\n    float d_node_12 = sdBox(d_node_12_p, vec3(0.150, 0.200, 0.150));\n    d_node_12 *= d_node_12_scale;\n    float d_node_13 = d_node_12;\n    d_node_13 *= d_node_13_scale;\n    float d_node_14 = d_node_13;\n    d_node_14 *= d_node_14_scale;\n    vec3 d_node_4_p = d_node_16_p;\n    d_node_4_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_4_scale = max(1.000, 0.0001);\n    d_node_4_p /= d_node_4_scale;\n    vec3 d_node_2_p = d_node_4_p;\n    d_node_2_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_2_scale = max(1.000, 0.0001);\n    d_node_2_p /= d_node_2_scale;\n    vec3 d_node_2_warp = d_node_2_p;\n    d_node_2_warp.x = abs(d_node_2_warp.x);\n    vec3 d_node_6_p = d_node_2_warp;\n    d_node_6_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_6_scale = max(0.850, 0.0001);\n    d_node_6_p /= d_node_6_scale;\n    vec3 d_node_6_warp = d_node_6_p;\n    float d_node_6_angle = 0.200 * d_node_6_warp.x;\n    mat2 d_node_6_mat = mat2(cos(d_node_6_angle), -sin(d_node_6_angle), sin(d_node_6_angle), cos(d_node_6_angle));\n    vec2 d_node_6_rot = d_node_6_mat * d_node_6_warp.xy;\n    d_node_6_warp.xy = d_node_6_rot;\n    vec3 d_node_3_p = d_node_6_warp;\n    d_node_3_p -= vec3(0.800, 0.000, 0.000);\n    d_node_3_p *= rotateZ(-0.2443);\n    float d_node_3_scale = max(1.000, 0.0001);\n    d_node_3_p /= d_node_3_scale;\n    float d_node_3 = sdBox(d_node_3_p, vec3(0.500, 0.400, 1.050));\n    d_node_3 *= d_node_3_scale;\n    float d_node_6 = d_node_3;\n    d_node_6 *= d_node_6_scale;\n    float d_node_2 = d_node_6;\n    d_node_2 *= d_node_2_scale;\n    vec3 d_node_11_p = d_node_4_p;\n    d_node_11_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_11_scale = max(1.000, 0.0001);\n    d_node_11_p /= d_node_11_scale;\n    vec3 d_node_10_p = d_node_11_p;\n    d_node_10_p -= vec3(0.000, -0.600, 0.900);\n    d_node_10_p *= rotateX(0.2618);\n    d_node_10_p *= rotateY(-0.7505);\n    float d_node_10_scale = max(0.400, 0.0001);\n    d_node_10_p /= d_node_10_scale;\n    float d_node_10 = sdPyramid(d_node_10_p, 2.300);\n    d_node_10 *= d_node_10_scale;\n    vec3 d_node_8_p = d_node_11_p;\n    d_node_8_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_8_scale = max(1.000, 0.0001);\n    d_node_8_p /= d_node_8_scale;\n    vec3 d_node_5_p = d_node_8_p;\n    d_node_5_p -= vec3(0.000, 0.000, -0.700);\n    float d_node_5_scale = max(1.000, 0.0001);\n    d_node_5_p /= d_node_5_scale;\n    float d_node_5 = sdSphere(d_node_5_p, 1.650);\n    d_node_5 *= d_node_5_scale;\n    vec3 d_node_9_p = d_node_8_p;\n    d_node_9_p -= vec3(0.000, 0.000, 0.000);\n    float d_node_9_scale = max(1.000, 0.0001);\n    d_node_9_p /= d_node_9_scale;\n    vec3 d_node_7_p = d_node_9_p;\n    d_node_7_p -= vec3(0.000, -1.100, 0.400);\n    float d_node_7_scale = max(0.800, 0.0001);\n    d_node_7_p /= d_node_7_scale;\n    float d_node_7 = sdBox(d_node_7_p, vec3(0.550, 0.750, 0.250));\n    d_node_7 *= d_node_7_scale;\n    float d_node_9 = d_node_7 - 0.370;\n    d_node_9 *= d_node_9_scale;\n    float d_node_8 = opSmoothUnion(d_node_5, d_node_9, 0.770);\n    d_node_8 *= d_node_8_scale;\n    float d_node_11 = opSmoothSubtraction(d_node_10, d_node_8, 0.290);\n    d_node_11 *= d_node_11_scale;\n    float d_node_4 = opSmoothSubtraction(d_node_2, d_node_11, 0.300);\n    d_node_4 *= d_node_4_scale;\n    float d_node_16 = opSmoothSubtraction(d_node_14, d_node_4, 0.460);\n    d_node_16 *= d_node_16_scale;\n\n    float skull = min(d_node_1, d_node_16);\n    \n\n    float cloudLayer = cloudDensity(p) + 4.0;\n    \n    // I dont think this works\n    return opSmoothUnion(skull, cloudLayer, 1.5);\n}\n\nfloat eyesSDF(vec3 p) {\n    vec3 skullPos = getSkullPosition(iTime);\n    mat3 skullRot = getSkullRotation(iTime);\n    vec3 localP = skullRot * (p - skullPos);\n    \n    vec3 d_node_1_p = localP;\n    d_node_1_p -= vec3(0.000, 0.000, 0.000);\n    d_node_1_p *= rotateX(-0.0873);\n    d_node_1_p *= rotateY(-0.0349);\n    float d_node_1_scale = max(0.950, 0.0001);\n    d_node_1_p /= d_node_1_scale;\n    vec3 d_node_1_warp = d_node_1_p;\n    d_node_1_warp.x = abs(d_node_1_warp.x);\n    vec3 d_node_0_p = d_node_1_warp;\n    d_node_0_p -= vec3(0.700, 0.100, 0.300);\n    d_node_0_p *= rotateX(0.3491);\n    d_node_0_p *= rotateY(0.2967);\n    d_node_0_p *= rotateZ(0.3142);\n    float d_node_0_scale = max(1.000, 0.0001);\n    d_node_0_p /= d_node_0_scale;\n    float d_node_0 = sdSphere(d_node_0_p, 0.400);\n    d_node_0 *= d_node_0_scale;\n    float d_node_1 = d_node_0;\n    d_node_1 *= d_node_1_scale;\n    return d_node_1;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),\n        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\n        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 skullPos = getSkullPosition(iTime * 2.);\n    \n    float camAngle = iTime * 2.;\n    vec3 camOffset = vec3(\n        cos(camAngle) * 6.0 + sin(iTime * 0.2) * 2.0,\n        sin(iTime * 0.4) * 1.5 + 1.0,\n        sin(camAngle) * 6.0 + cos(iTime * 0.25) * 2.0\n    );\n    \n    vec3 ro = skullPos + camOffset;\n    vec3 lookAt = skullPos;\n    \n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    // Skull raymarch\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float eyeGlow = 0.0;\n    bool hitSkull = false;\n    float flicker = 0.5 + 0.3 * sin(iTime * 55.0 + sin(iTime * 70.0));\n    float pulse = 0.5 + 0.5 * sin(iTime * 10.0);\n    \n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = sceneSDF(p);\n        \n        // Eye glow accumulation\n        float eyeDist = eyesSDF(p) * 2.;\n        eyeGlow += 0.025 / (0.1 + eyeDist * eyeDist * eyeDist) * flicker;\n        \n        if (d < 0.001) {\n            vec3 n = calcNormal(p);\n            \n            // Dramatic lighting from below (fire/hellish)\n            vec3 lightDir1 = normalize(vec3(0.0, -1.0, 0.2));\n            vec3 lightDir2 = normalize(vec3(1.0, 0.5, 1.0));\n            \n            float diff1 = max(dot(n, lightDir1), 0.0);\n            float diff2 = max(dot(n, lightDir2), 0.0);\n            float amb = 0.05; // Darker ambient for scarier look\n            \n            float eyeDist = eyesSDF(p);\n            if(eyeDist < 0.05) {\n                // Glowing eyes with flicker\n                col = vec3(1.0, 0.2, 0.05) * 20.5 * flicker;\n            } else {\n                // Skull lighting\n                vec3 baseColor = vec3(0.7, 0.65, 0.6);\n                vec3 fireLight = vec3(1.0, 0.3, 0.1) * diff1 * 0.8;\n                vec3 rimLight = vec3(0.3, 0.4, 0.5) * diff2 * 0.3;\n                \n                col = baseColor * (diff2 * 0.4 + amb) + fireLight + rimLight;\n                \n                // Add atmospheric fog based on distance\n                float fogAmount = 1.0 - exp(-t * 0.05);\n                col = mix(col, vec3(0.02, 0.01, 0.02), fogAmount * 0.5);\n            }\n            hitSkull = true;\n            break;\n        }\n        \n        if (t > 30.0) break;\n        t += d * 0.8; // Slower march for better cloud integration\n    }\n    \n    // Cloud raymarch accumulation (from original shader)\n    vec3 cloudCol = vec3(0.0);\n    float cloudDist = 0.0;\n    \n    // Volumetric cloud rendering\n    for(int i = 0; i < 64; i++) {\n        vec3 p = ro + rd * cloudDist;\n        float s = cloudDensity(p / 10.);\n        \n        // Accumulate cloud color with depth-based fog\n        float density = 1.0 / (0.07 + 0.2 * abs(s));\n        vec3 fogColor = vec3(0.02, 0.01, 0.01); // Dark purplish fog\n        cloudCol += fogColor * density * 0.1;\n        \n        cloudDist += 0.5;\n    }\n    \n    // Combine clouds and skull\n    if(!hitSkull) {\n        col = cloudCol;\n    } else {\n        // Blend skull with clouds based on depth\n        col = mix(cloudCol, col, exp(-t * 0.2));\n    }\n    \n    // Add eye glow\n    vec3 eyeColor = vec3(1.0, 0.15, 0.03) * eyeGlow;\n    col += eyeColor;\n    \n    // Enhanced atmospheric effects\n    float smokeFbm = fbm(vec3(uv * 3.0, iTime * 0.15)) * 0.15;\n    col = mix(col, vec3(0.08, 0.04, 0.05), smokeFbm);\n    \n    \n    float vignette = 1.0 - length(uv) * 0.5;\n    vignette = pow(vignette, 1.5);\n    col *= vignette;\n    \n    // Contrast boost for dramatic effect\n    col = pow(col, vec3(0.9));\n    col = col / (1.0 + col);\n    \n    // Subtle color grading - desaturate and add slight green tint for eerie feel\n    float lum = dot(col, vec3(0.299, 0.587, 0.114));\n    col = mix(col, vec3(lum), 0.2);\n    col *= vec3(0.95, 1.0, 0.98);\n    \n    // Motion blur feedback\n    fragColor = (texture(iChannel0, fragCoord / iResolution.xy, 0.) * 2.0 + vec4(col, 1.0)) / 2.8;\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfGczm",
    "date": "1764563531",
    "viewed": 272,
    "name": "Unfinished Woman SDFeditor",
    "description": "19 primitives and about 30 operations.\nTesting out SDF editor and seeing what it can do.\nThis took between 1-2 hours (plus lots of dev time for the editor itself",
    "likes": 20,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "sculpture",
     "anatomy",
     "woman",
     "sleditor",
     "sdfeditor"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Generated with SDF Builder\n// Paste into Shadertoy\n\n// SDF Primitives and Operations\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\nfloat sdCylinder(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n\n\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n    float b = (r1 - r2) / h;\n    float a = sqrt(max(1.0 - b * b, 0.0001));\n    vec2 q = vec2(length(p.xz), p.y);\n    float k = dot(q, vec2(-b, a));\n    if (k < 0.0) return length(q) - r1;\n    if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n    return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdVerticalCapsule(vec3 p, float h, float r) {\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n\n\n\nfloat sdVesicaSegment(vec3 p, vec3 a, vec3 b, float w) {\n    vec3 c = (a + b) * 0.5;\n    vec3 ba = b - a;\n    float l = length(ba);\n    vec3 v = ba / max(l, 0.0001);\n    vec3 rel = p - c;\n    float y = dot(rel, v);\n    vec2 q = vec2(length(rel - y * v), abs(y));\n    float r = 0.5 * l;\n    float ww = max(w, 0.0001);\n    float d = 0.5 * (r * r - ww * ww) / ww;\n    vec3 h = (r * q.x < d * (q.y - r)) ? vec3(0.0, r, 0.0) : vec3(-d, 0.0, d + ww);\n    return length(q - h.xy) - h.z;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nfloat opXor(float d1, float d2) {\n    return max(min(d1, d2), -max(d1, d2));\n}\n\nvec3 hsvToRgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 intToColor(int i) {\n    float goldenRatio = 0.618033988749895;\n    float hue = fract(float(i) * goldenRatio);\n    float satBucket = floor(mod(float(i), 3.0));\n    float valBucket = floor(mod(float(i), 4.0));\n    float sat = clamp(0.7 + satBucket * 0.1, 0.0, 1.0);\n    float val = clamp(0.7 + valBucket * 0.075, 0.0, 1.0);\n    return hsvToRgb(vec3(hue, sat, val));\n}\n\nmat3 rotateX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n}\n\nmat3 rotateZ(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n}\n\n// === Experimental Shapes ===\n\n// Cart2Polar for Mandelbulb\nvec3 cart2polar(in vec3 st) {\n    float r = length(st);\n    float phi = acos(st.z / r);\n    float theta = atan(st.y, st.x);\n    return vec3(r, phi, theta);\n}\n\n// Mandelbulb SDF\nfloat sdMandelbulb(in vec3 st, float power, float maxIterations) {\n    vec3 zeta = st;\n    float m = dot(st, st);\n    float dz = 1.0;\n    int iterations = int(maxIterations);\n    \n    for (int i = 0; i < 50; i++) {\n        if (i >= iterations) break;\n        \n        dz = power * pow(m, 3.5) * dz + 1.0;\n        vec3 sphericalZ = cart2polar(zeta);\n        float newx = pow(sphericalZ.x, power) * sin(sphericalZ.y * power) * cos(sphericalZ.z * power);\n        float newy = pow(sphericalZ.x, power) * sin(sphericalZ.y * power) * sin(sphericalZ.z * power);\n        float newz = pow(sphericalZ.x, power) * cos(sphericalZ.y * power);\n        zeta.x = newx + st.x;\n        zeta.y = newy + st.y;\n        zeta.z = newz + st.z;\n        \n        m = dot(zeta, zeta);\n        if (m > 2.0) break;\n    }\n    \n    // Distance estimation through the Hubbard-Douady potential\n    return 0.25 * log(m) * sqrt(m) / dz;\n}\n\n// Supershape helpers\nvec3 Spherical(vec3 pos) {\n    float r = sqrt(pos.x * pos.x + pos.y * pos.y + pos.z * pos.z);\n    float theta = pos.z / r;\n    float phi = atan(pos.y, pos.x);\n    vec3 w = vec3(r, theta, phi);\n    return w;\n}\n\nbool hair = true;\n\n// Complex Woman SDF (performance test primitive)\nfloat sdComplexWoman(vec3 p) {\n    vec3 smoothunion_1_p = p;\n    smoothunion_1_p -= vec3(0.000, 0.000, 0.000); // Centered at origin\n    smoothunion_1_p *= rotateX(-2.6878);\n    smoothunion_1_p *= rotateY(2.8449);\n    smoothunion_1_p *= rotateZ(2.8798);\n    float smoothunion_1_scale = max(1.000, 0.0001);\n    smoothunion_1_p /= smoothunion_1_scale;\n    vec3 smoothunion_2_p = smoothunion_1_p;\n    smoothunion_2_p -= vec3(0.000, 0.000, 0.000); // Centered (was -3.100, 0.500, -1.100)\n    smoothunion_2_p *= rotateX(1.0123);\n    smoothunion_2_p *= rotateY(-0.8901);\n    smoothunion_2_p *= rotateZ(-2.0420);\n    float smoothunion_2_scale = max(1.000, 0.0001);\n    smoothunion_2_p /= smoothunion_2_scale;\n    vec3 smoothunion_3_p = smoothunion_2_p;\n    smoothunion_3_p -= vec3(0.000, 0.000, 0.000);\n    float smoothunion_3_scale = max(1.000, 0.0001);\n    smoothunion_3_p /= smoothunion_3_scale;\n    vec3 smoothunion_4_p = smoothunion_3_p;\n    smoothunion_4_p -= vec3(0.000, 0.000, 0.000);\n    float smoothunion_4_scale = max(1.000, 0.0001);\n    smoothunion_4_p /= smoothunion_4_scale;\n    vec3 symx_1_p = smoothunion_4_p;\n    symx_1_p -= vec3(0.000, 0.000, 0.000);\n    symx_1_p *= rotateX(0.1571);\n    float symx_1_scale = max(1.000, 0.0001);\n    symx_1_p /= symx_1_scale;\n    vec3 symx_1_warp = symx_1_p;\n    symx_1_warp.x = abs(symx_1_warp.x);\n    vec3 smoothunion_5_p = symx_1_warp;\n    smoothunion_5_p -= vec3(0.000, 0.000, 0.000);\n    float smoothunion_5_scale = max(1.000, 0.0001);\n    smoothunion_5_p /= smoothunion_5_scale;\n    vec3 smoothunion_6_p = smoothunion_5_p;\n    smoothunion_6_p -= vec3(-0.200, 0.000, -0.100);\n    smoothunion_6_p *= rotateY(-0.1920);\n    smoothunion_6_p *= rotateZ(0.5061);\n    float smoothunion_6_scale = max(1.000, 0.0001);\n    smoothunion_6_p /= smoothunion_6_scale;\n    vec3 cheapbend_1_p = smoothunion_6_p;\n    cheapbend_1_p -= vec3(0.900, -0.400, 0.100);\n    cheapbend_1_p *= rotateX(-1.1345);\n    cheapbend_1_p *= rotateY(0.8901);\n    cheapbend_1_p *= rotateZ(0.1396);\n    float cheapbend_1_scale = max(1.000, 0.0001);\n    cheapbend_1_p /= cheapbend_1_scale;\n    vec3 cheapbend_1_warp = cheapbend_1_p;\n    float cheapbend_1_angle = 0.900 * cheapbend_1_warp.x;\n    mat2 cheapbend_1_mat = mat2(cos(cheapbend_1_angle), -sin(cheapbend_1_angle), sin(cheapbend_1_angle), cos(cheapbend_1_angle));\n    vec2 cheapbend_1_rot = cheapbend_1_mat * cheapbend_1_warp.xy;\n    cheapbend_1_warp.xy = cheapbend_1_rot;\n    vec3 sphere_1_p = cheapbend_1_warp;\n    sphere_1_p -= vec3(-0.400, -0.300, 0.000);\n    float sphere_1_scale = max(0.950, 0.0001);\n    sphere_1_p /= sphere_1_scale;\n    float sphere_1 = sdSphere(sphere_1_p, 0.500) * sphere_1_scale;\n    float cheapbend_1 = sphere_1 * cheapbend_1_scale;\n    vec3 smoothunion_7_p = smoothunion_6_p;\n    smoothunion_7_p -= vec3(0.000, 0.000, 0.000);\n    float smoothunion_7_scale = max(0.950, 0.0001);\n    smoothunion_7_p /= smoothunion_7_scale;\n    vec3 sphere_2_p = smoothunion_7_p;\n    sphere_2_p -= vec3(0.700, 0.000, -0.100);\n    float sphere_2_scale = max(0.850, 0.0001);\n    sphere_2_p /= sphere_2_scale;\n    float sphere_2 = sdSphere(sphere_2_p, 0.500) * sphere_2_scale;\n    vec3 vesicasegment_1_p = smoothunion_7_p;\n    vesicasegment_1_p -= vec3(0.700, 0.000, 0.000);\n    vesicasegment_1_p *= rotateX(-0.0349);\n    vesicasegment_1_p *= rotateY(-1.7104);\n    float vesicasegment_1_scale = max(1.050, 0.0001);\n    vesicasegment_1_p /= vesicasegment_1_scale;\n    float vesicasegment_1 = sdVesicaSegment(vesicasegment_1_p, vec3(-0.500, 0.000, 0.000), vec3(0.500, 0.000, 0.000), 0.360) * vesicasegment_1_scale;\n    float smoothunion_7 = opSmoothUnion(sphere_2, vesicasegment_1, 0.010) * smoothunion_7_scale;\n    float smoothunion_6 = opSmoothUnion(cheapbend_1, smoothunion_7, 0.070) * smoothunion_6_scale;\n    vec3 sphere_3_p = smoothunion_5_p;\n    sphere_3_p -= vec3(0.300, -0.800, -1.300);\n    sphere_3_p *= rotateZ(-0.0349);\n    float sphere_3_scale = max(1.150, 0.0001);\n    sphere_3_p /= sphere_3_scale;\n    float sphere_3 = sdSphere(sphere_3_p, 0.350) * sphere_3_scale;\n    float smoothunion_5 = opSmoothUnion(smoothunion_6, sphere_3, 0.390) * smoothunion_5_scale;\n    float symx_1 = smoothunion_5 * symx_1_scale;\n    vec3 smoothunion_8_p = smoothunion_4_p;\n    smoothunion_8_p -= vec3(-0.100, 0.000, 0.000);\n    float smoothunion_8_scale = max(1.000, 0.0001);\n    smoothunion_8_p /= smoothunion_8_scale;\n    vec3 smoothunion_9_p = smoothunion_8_p;\n    smoothunion_9_p -= vec3(0.000, 0.000, 0.000);\n    float smoothunion_9_scale = max(1.000, 0.0001);\n    smoothunion_9_p /= smoothunion_9_scale;\n    vec3 cheapbend_2_p = smoothunion_9_p;\n    cheapbend_2_p -= vec3(0.900, 0.700, -2.200);\n    cheapbend_2_p *= rotateX(0.2967);\n    cheapbend_2_p *= rotateY(-1.5533);\n    cheapbend_2_p *= rotateZ(-0.8029);\n    float cheapbend_2_scale = max(1.000, 0.0001);\n    cheapbend_2_p /= cheapbend_2_scale;\n    vec3 cheapbend_2_warp = cheapbend_2_p;\n    float cheapbend_2_angle = 0.200 * cheapbend_2_warp.x;\n    mat2 cheapbend_2_mat = mat2(cos(cheapbend_2_angle), -sin(cheapbend_2_angle), sin(cheapbend_2_angle), cos(cheapbend_2_angle));\n    vec2 cheapbend_2_rot = cheapbend_2_mat * cheapbend_2_warp.xy;\n    cheapbend_2_warp.xy = cheapbend_2_rot;\n    vec3 vesicasegment_2_p = cheapbend_2_warp;\n    vesicasegment_2_p -= vec3(-1.200, -1.400, -1.300);\n    vesicasegment_2_p *= rotateX(-0.5236);\n    vesicasegment_2_p *= rotateY(-0.9948);\n    vesicasegment_2_p *= rotateZ(-1.1868);\n    float vesicasegment_2_scale = max(0.450, 0.0001);\n    vesicasegment_2_p /= vesicasegment_2_scale;\n    float vesicasegment_2 = sdVesicaSegment(vesicasegment_2_p, vec3(-2.700, -0.400, 1.200), vec3(0.100, -0.100, -0.100), 0.170) * vesicasegment_2_scale;\n    float cheapbend_2 = vesicasegment_2 * cheapbend_2_scale;\n    vec3 vesicasegment_3_p = smoothunion_9_p;\n    vesicasegment_3_p -= vec3(-0.500, -1.300, -1.500);\n    vesicasegment_3_p *= rotateX(-0.2094);\n    vesicasegment_3_p *= rotateY(0.2443);\n    vesicasegment_3_p *= rotateZ(-1.6581);\n    float vesicasegment_3_scale = max(0.750, 0.0001);\n    vesicasegment_3_p /= vesicasegment_3_scale;\n    float vesicasegment_3 = sdVesicaSegment(vesicasegment_3_p, vec3(-1.400, -0.100, -0.700), vec3(0.800, -0.400, 0.800), 0.310) * vesicasegment_3_scale;\n    float smoothunion_9 = opSmoothUnion(cheapbend_2, vesicasegment_3, 0.290) * smoothunion_9_scale;\n    vec3 cheapbend_3_p = smoothunion_8_p;\n    cheapbend_3_p -= vec3(-1.300, -0.600, -2.800);\n    cheapbend_3_p *= rotateX(1.4486);\n    cheapbend_3_p *= rotateY(1.1345);\n    cheapbend_3_p *= rotateZ(-3.0369);\n    float cheapbend_3_scale = max(1.050, 0.0001);\n    cheapbend_3_p /= cheapbend_3_scale;\n    vec3 cheapbend_3_warp = cheapbend_3_p;\n    float cheapbend_3_angle = -0.300 * cheapbend_3_warp.x;\n    mat2 cheapbend_3_mat = mat2(cos(cheapbend_3_angle), -sin(cheapbend_3_angle), sin(cheapbend_3_angle), cos(cheapbend_3_angle));\n    vec2 cheapbend_3_rot = cheapbend_3_mat * cheapbend_3_warp.xy;\n    cheapbend_3_warp.xy = cheapbend_3_rot;\n    vec3 verticalcapsule_1_p = cheapbend_3_warp;\n    verticalcapsule_1_p -= vec3(-0.300, 0.200, -1.900);\n    verticalcapsule_1_p *= rotateX(0.1571);\n    verticalcapsule_1_p *= rotateY(-1.4835);\n    verticalcapsule_1_p *= rotateZ(-0.3491);\n    float verticalcapsule_1_scale = max(0.600, 0.0001);\n    verticalcapsule_1_p /= verticalcapsule_1_scale;\n    float verticalcapsule_1 = sdVerticalCapsule(verticalcapsule_1_p, 2.150, 0.390) * verticalcapsule_1_scale;\n    float cheapbend_3 = verticalcapsule_1 * cheapbend_3_scale;\n    float smoothunion_8 = opSmoothUnion(smoothunion_9, cheapbend_3, 0.150) * smoothunion_8_scale;\n    float smoothunion_4 = opSmoothUnion(symx_1, smoothunion_8, 0.260) * smoothunion_4_scale;\n    vec3 cheapbend_4_p = smoothunion_3_p;\n    cheapbend_4_p -= vec3(0.000, 0.000, 0.000);\n    float cheapbend_4_scale = max(1.000, 0.0001);\n    cheapbend_4_p /= cheapbend_4_scale;\n    vec3 cheapbend_4_warp = cheapbend_4_p;\n    float cheapbend_4_angle = 0.300 * cheapbend_4_warp.x;\n    mat2 cheapbend_4_mat = mat2(cos(cheapbend_4_angle), -sin(cheapbend_4_angle), sin(cheapbend_4_angle), cos(cheapbend_4_angle));\n    vec2 cheapbend_4_rot = cheapbend_4_mat * cheapbend_4_warp.xy;\n    cheapbend_4_warp.xy = cheapbend_4_rot;\n    vec3 verticalcapsule_2_p = cheapbend_4_warp;\n    verticalcapsule_2_p -= vec3(0.000, -0.900, -0.800);\n    verticalcapsule_2_p *= rotateX(-0.8552);\n    verticalcapsule_2_p *= rotateY(-0.1396);\n    float verticalcapsule_2_scale = max(0.950, 0.0001);\n    verticalcapsule_2_p /= verticalcapsule_2_scale;\n    float verticalcapsule_2 = sdVerticalCapsule(verticalcapsule_2_p, 0.800, 0.410) * verticalcapsule_2_scale;\n    float cheapbend_4 = verticalcapsule_2 * cheapbend_4_scale;\n    float smoothunion_3 = opSmoothUnion(smoothunion_4, cheapbend_4, 0.110) * smoothunion_3_scale;\n    vec3 smoothunion_10_p = smoothunion_2_p;\n    smoothunion_10_p -= vec3(0.000, 0.000, 0.000);\n    float smoothunion_10_scale = max(1.000, 0.0001);\n    smoothunion_10_p /= smoothunion_10_scale;\n    vec3 cheapbend_5_p = smoothunion_10_p;\n    cheapbend_5_p -= vec3(0.000, 0.500, -0.200);\n    cheapbend_5_p *= rotateX(-2.9845);\n    cheapbend_5_p *= rotateY(-0.0349);\n    cheapbend_5_p *= rotateZ(-0.0873);\n    float cheapbend_5_scale = max(0.900, 0.0001);\n    cheapbend_5_p /= cheapbend_5_scale;\n    vec3 cheapbend_5_warp = cheapbend_5_p;\n    float cheapbend_5_angle = -1.200 * cheapbend_5_warp.x;\n    mat2 cheapbend_5_mat = mat2(cos(cheapbend_5_angle), -sin(cheapbend_5_angle), sin(cheapbend_5_angle), cos(cheapbend_5_angle));\n    vec2 cheapbend_5_rot = cheapbend_5_mat * cheapbend_5_warp.xy;\n    cheapbend_5_warp.xy = cheapbend_5_rot;\n    vec3 verticalcapsule_3_p = cheapbend_5_warp;\n    verticalcapsule_3_p -= vec3(0.000, 0.000, 0.000);\n    verticalcapsule_3_p *= rotateX(0.2443);\n    verticalcapsule_3_p *= rotateY(-0.4363);\n    float verticalcapsule_3_scale = max(1.000, 0.0001);\n    verticalcapsule_3_p /= verticalcapsule_3_scale;\n    float verticalcapsule_3 = sdVerticalCapsule(verticalcapsule_3_p, 0.700, 0.140) * verticalcapsule_3_scale;\n    float cheapbend_5 = verticalcapsule_3 * cheapbend_5_scale;\n    vec3 vesicasegment_4_p = smoothunion_10_p;\n    vesicasegment_4_p -= vec3(-0.200, 0.400, -0.400);\n    vesicasegment_4_p *= rotateX(1.1345);\n    vesicasegment_4_p *= rotateY(0.7330);\n    vesicasegment_4_p *= rotateZ(0.0349);\n    float vesicasegment_4_scale = max(1.000, 0.0001);\n    vesicasegment_4_p /= vesicasegment_4_scale;\n    float vesicasegment_4 = sdVesicaSegment(vesicasegment_4_p, vec3(0.900, -0.400, -0.500), vec3(0.200, -0.500, -1.000), 0.190) * vesicasegment_4_scale;\n    float smoothunion_10 = opSmoothUnion(cheapbend_5, vesicasegment_4, 0.100) * smoothunion_10_scale;\n    float smoothunion_2 = opSmoothUnion(smoothunion_3, smoothunion_10, 0.070) * smoothunion_2_scale;\n    vec3 smoothunion_11_p = smoothunion_1_p;\n    smoothunion_11_p -= vec3(3.100, -0.500, 1.100); // Offset to maintain relative position\n    float smoothunion_11_scale = max(1.000, 0.0001);\n    smoothunion_11_p /= smoothunion_11_scale;\n    vec3 roundcone_1_p = smoothunion_11_p;\n    roundcone_1_p -= vec3(-3.000, 0.300, -1.400);\n    roundcone_1_p *= rotateX(-1.0821);\n    roundcone_1_p *= rotateY(0.1047);\n    roundcone_1_p *= rotateZ(-0.5934);\n    float roundcone_1_scale = max(1.000, 0.0001);\n    roundcone_1_p /= roundcone_1_scale;\n    float roundcone_1 = sdRoundCone(roundcone_1_p, 0.360, 0.170, 0.600) * roundcone_1_scale;\n    vec3 verticalcapsule_4_p = smoothunion_11_p;\n    verticalcapsule_4_p -= vec3(-3.100, 0.500, -1.000);\n    verticalcapsule_4_p *= rotateX(-1.0123);\n    verticalcapsule_4_p *= rotateY(-0.3840);\n    verticalcapsule_4_p *= rotateZ(-0.9948);\n    float verticalcapsule_4_scale = max(1.000, 0.0001);\n    verticalcapsule_4_p /= verticalcapsule_4_scale;\n    float verticalcapsule_4 = sdVerticalCapsule(verticalcapsule_4_p, 0.500, 0.170) * verticalcapsule_4_scale;\n    float smoothunion_11 = opSmoothUnion(roundcone_1, verticalcapsule_4, 0.260) * smoothunion_11_scale;\n    float smoothunion_1 = opSmoothUnion(smoothunion_2, smoothunion_11, 0.140) * smoothunion_1_scale;\n    return smoothunion_1;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    vec3 smoothunion_1_p = p;\n    smoothunion_1_p -= vec3(-0.300, 0.000, 0.000);\n    smoothunion_1_p *= rotateY(-0.3+sin(iTime)*0.7);\n    //smoothunion_1_p *= rotateZ(0.1920);\n    smoothunion_1_p *= rotateX(0.1920);\n    float smoothunion_1_scale = max(1.000, 0.0001);\n    smoothunion_1_p /= smoothunion_1_scale;\n    vec3 smoothunion_2_p = smoothunion_1_p;\n    smoothunion_2_p -= vec3(0.000, 0.000, 0.000);\n    float smoothunion_2_scale = max(1.000, 0.0001);\n    smoothunion_2_p /= smoothunion_2_scale;\n    vec3 smoothunion_3_p = smoothunion_2_p;\n    smoothunion_3_p -= vec3(-0.100, -0.400, 0.700);\n    smoothunion_3_p *= rotateX(0.0349);\n    smoothunion_3_p *= rotateY(0.8552);\n    smoothunion_3_p *= rotateZ(0.1571);\n    float smoothunion_3_scale = max(0.600, 0.0001);\n    smoothunion_3_p /= smoothunion_3_scale;\n    vec3 roundcone_1_p = smoothunion_3_p;\n    roundcone_1_p -= vec3(0.000, -0.100, 0.000);\n    roundcone_1_p *= rotateX(-2.9671);\n    roundcone_1_p *= rotateY(-0.1222);\n    roundcone_1_p *= rotateZ(0.1222);\n    float roundcone_1_scale = max(0.800, 0.0001);\n    roundcone_1_p /= roundcone_1_scale;\n    float roundcone_1_dist;\n    float roundcone_1_skip = length(roundcone_1_p) - (1.020);\n    if (roundcone_1_skip > 2.0) {\n        roundcone_1_dist = roundcone_1_skip;\n    } else {\n        roundcone_1_dist = sdRoundCone(roundcone_1_p, 0.470, 0.130, 0.550);\n    }\n    float roundcone_1 = roundcone_1_dist;\n    roundcone_1 *= roundcone_1_scale;\n    vec3 roundcone_2_p = smoothunion_3_p;\n    roundcone_2_p -= vec3(0.100, -0.500, 0.000);\n    roundcone_2_p *= rotateX(-0.0698);\n    roundcone_2_p *= rotateY(-0.6109);\n    roundcone_2_p *= rotateZ(3.0194);\n    float roundcone_2_scale = max(1.000, 0.0001);\n    roundcone_2_p /= roundcone_2_scale;\n    float roundcone_2_dist;\n    float roundcone_2_skip = length(roundcone_2_p) - (1.230);\n    if (roundcone_2_skip > 2.0) {\n        roundcone_2_dist = roundcone_2_skip;\n    } else {\n        roundcone_2_dist = sdRoundCone(roundcone_2_p, 0.280, 0.210, 0.950);\n    }\n    float roundcone_2 = roundcone_2_dist;\n    roundcone_2 *= roundcone_2_scale;\n    float smoothunion_3 = opSmoothUnion(roundcone_1, roundcone_2, 0.300);\n    smoothunion_3 *= smoothunion_3_scale;\n    vec3 smoothunion_4_p = smoothunion_2_p;\n    smoothunion_4_p -= vec3(0.000, 0.000, 0.000);\n    float smoothunion_4_scale = max(1.000, 0.0001);\n    smoothunion_4_p /= smoothunion_4_scale;\n    vec3 smoothunion_5_p = smoothunion_4_p;\n    smoothunion_5_p -= vec3(-0.100, 0.000, 0.000);\n    float smoothunion_5_scale = max(1.000, 0.0001);\n    smoothunion_5_p /= smoothunion_5_scale;\n    vec3 complexwoman_1_p = smoothunion_5_p;\n    complexwoman_1_p -= vec3(0.000, 0.000, 0.000);\n    float complexwoman_1_scale = max(1.000, 0.0001);\n    complexwoman_1_p /= complexwoman_1_scale;\n    float complexwoman_1_dist;\n    float complexwoman_1_skip = length(complexwoman_1_p) - (6.0);\n    if (complexwoman_1_skip > 2.0) {\n        complexwoman_1_dist = complexwoman_1_skip;\n    } else {\n        complexwoman_1_dist = sdComplexWoman(complexwoman_1_p);\n    }\n    float complexwoman_1 = complexwoman_1_dist;\n    complexwoman_1 *= complexwoman_1_scale;\n    vec3 round_1_p = smoothunion_5_p;\n    round_1_p -= vec3(0.000, 0.000, 0.000);\n    round_1_p *= rotateX(-0.0349);\n    round_1_p *= rotateY(0.0873);\n    float round_1_scale = max(0.900, 0.0001);\n    round_1_p /= round_1_scale;\n    vec3 vesicasegment_1_p = round_1_p;\n    vesicasegment_1_p -= vec3(-0.700, 0.000, -0.900);\n    float vesicasegment_1_scale = max(0.900, 0.0001);\n    vesicasegment_1_p /= vesicasegment_1_scale;\n    float vesicasegment_1_dist;\n    float vesicasegment_1_skip = length(vesicasegment_1_p) - (1.293);\n    if (vesicasegment_1_skip > 2.0) {\n        vesicasegment_1_dist = vesicasegment_1_skip;\n    } else {\n        vesicasegment_1_dist = sdVesicaSegment(vesicasegment_1_p, vec3(-0.800, 1.300, 0.400), vec3(0.900, -0.200, 0.100), 0.150);\n    }\n    float vesicasegment_1 = vesicasegment_1_dist;\n    vesicasegment_1 *= vesicasegment_1_scale;\n    float round_1 = vesicasegment_1 - 0.040;\n    round_1 *= round_1_scale;\n    float smoothunion_5 = opSmoothUnion(complexwoman_1, round_1, 0.040);\n    smoothunion_5 *= smoothunion_5_scale;\n    vec3 smoothunion_6_p = smoothunion_4_p;\n    smoothunion_6_p -= vec3(-0.900, 0.000, 0.500);\n    smoothunion_6_p *= rotateX(-2.1293);\n    smoothunion_6_p *= rotateY(2.8972);\n    smoothunion_6_p *= rotateZ(1.0996);\n    float smoothunion_6_scale = max(0.800, 0.0001);\n    smoothunion_6_p /= smoothunion_6_scale;\n    vec3 sphere_1_p = smoothunion_6_p;\n    sphere_1_p -= vec3(0.000, -0.200, 0.000);\n    float sphere_1_scale = max(1.000, 0.0001);\n    sphere_1_p /= sphere_1_scale;\n    float sphere_1_dist;\n    float sphere_1_skip = length(sphere_1_p) - (0.400);\n    if (sphere_1_skip > 2.0) {\n        sphere_1_dist = sphere_1_skip;\n    } else {\n        sphere_1_dist = sdSphere(sphere_1_p, 0.400);\n    }\n    float sphere_1 = sphere_1_dist;\n    sphere_1 *= sphere_1_scale;\n    vec3 symx_1_p = smoothunion_6_p;\n    symx_1_p -= vec3(0.000, -0.100, 0.000);\n    symx_1_p *= rotateX(-0.5411);\n    symx_1_p *= rotateY(-0.0873);\n    symx_1_p *= rotateZ(0.0524);\n    float symx_1_scale = max(0.800, 0.0001);\n    symx_1_p /= symx_1_scale;\n    vec3 symx_1_warp = symx_1_p;\n    symx_1_warp.x = abs(symx_1_warp.x);\n    vec3 round_2_p = symx_1_warp;\n    round_2_p -= vec3(0.000, -0.100, 0.000);\n    round_2_p *= rotateX(0.0524);\n    float round_2_scale = max(0.850, 0.0001);\n    round_2_p /= round_2_scale;\n    vec3 vesicasegment_2_p = round_2_p;\n    vesicasegment_2_p -= vec3(0.000, -0.300, 0.100);\n    vesicasegment_2_p *= rotateX(1.2741);\n    vesicasegment_2_p *= rotateY(-0.9250);\n    vesicasegment_2_p *= rotateZ(-0.0175);\n    float vesicasegment_2_scale = max(0.750, 0.0001);\n    vesicasegment_2_p /= vesicasegment_2_scale;\n    float vesicasegment_2_dist;\n    float vesicasegment_2_skip = length(vesicasegment_2_p) - (0.700);\n    if (vesicasegment_2_skip > 2.0) {\n        vesicasegment_2_dist = vesicasegment_2_skip;\n    } else {\n        vesicasegment_2_dist = sdVesicaSegment(vesicasegment_2_p, vec3(-0.600, -0.800, 0.300), vec3(0.200, -0.200, 0.100), 0.190);\n    }\n    float vesicasegment_2 = vesicasegment_2_dist;\n    vesicasegment_2 *= vesicasegment_2_scale;\n    float round_2 = vesicasegment_2 - 0.070;\n    round_2 *= round_2_scale;\n    float symx_1 = round_2;\n    symx_1 *= symx_1_scale;\n    float smoothunion_6 = opSmoothUnion(sphere_1, symx_1, 0.170);\n    smoothunion_6 *= smoothunion_6_scale;\n    float smoothunion_4 = opSmoothUnion(smoothunion_5, smoothunion_6, 0.110);\n    smoothunion_4 *= smoothunion_4_scale;\n    float smoothunion_2 = opSmoothUnion(smoothunion_3, smoothunion_4, 0.240);\n    smoothunion_2 *= smoothunion_2_scale;\n    vec3 twist_1_p = smoothunion_1_p;\n    twist_1_p -= vec3(-0.900, -0.300, 0.400);\n    twist_1_p *= rotateX(3.0543);\n    twist_1_p *= rotateY(1.2043);\n    twist_1_p *= rotateZ(-2.8972);\n    float twist_1_scale = max(0.300, 0.0001);\n    twist_1_p /= twist_1_scale;\n    vec3 twist_1_warp = twist_1_p;\n    float twist_1_angle = 0.700 * twist_1_warp.y;\n    mat2 twist_1_mat = mat2(cos(twist_1_angle), -sin(twist_1_angle), sin(twist_1_angle), cos(twist_1_angle));\n    twist_1_warp.xz = twist_1_mat * twist_1_warp.xz;\n    vec3 smoothunion_7_p = twist_1_warp;\n    smoothunion_7_p -= vec3(0.000, 0.000, 0.000);\n    float smoothunion_7_scale = max(1.000, 0.0001);\n    smoothunion_7_p /= smoothunion_7_scale;\n    vec3 sphere_2_p = smoothunion_7_p;\n    sphere_2_p -= vec3(0.100, 0.000, 0.000);\n    sphere_2_p *= rotateX(-0.7505);\n    sphere_2_p *= rotateY(-0.6458);\n    sphere_2_p *= rotateZ(-0.4363);\n    float sphere_2_scale = max(1.550, 0.0001);\n    sphere_2_p /= sphere_2_scale;\n    float sphere_2_dist;\n    float sphere_2_skip = length(sphere_2_p) - (0.700);\n    if (sphere_2_skip > 2.0) {\n        sphere_2_dist = sphere_2_skip;\n    } else {\n        sphere_2_dist = sdSphere(sphere_2_p, 0.700);\n    }\n    float sphere_2 = sphere_2_dist;\n    sphere_2 *= sphere_2_scale;\n    vec3 mandelbulb_1_p = smoothunion_7_p;\n    mandelbulb_1_p -= vec3(0.400, -0.100, 0.300);\n    mandelbulb_1_p *= rotateX(-1.0821);\n    mandelbulb_1_p *= rotateY(-0.5061);\n    mandelbulb_1_p *= rotateZ(0.8029);\n    float mandelbulb_1_scale = max(1.300, 0.0001);\n    mandelbulb_1_p /= mandelbulb_1_scale;\n    float mandelbulb_1_dist;\n    float mandelbulb_1_skip = length(mandelbulb_1_p) - (1.5);\n    if (mandelbulb_1_skip > 2.0) {\n        mandelbulb_1_dist = mandelbulb_1_skip;\n    } else {\n        mandelbulb_1_dist = sdMandelbulb(mandelbulb_1_p, 7.000, 5.000);\n    }\n    float mandelbulb_1 = mandelbulb_1_dist;\n    mandelbulb_1 *= mandelbulb_1_scale;\n    float smoothunion_7 = opSmoothUnion(sphere_2, mandelbulb_1, 0.560);\n    smoothunion_7 *= smoothunion_7_scale;\n    float twist_1 = smoothunion_7;\n    twist_1 *= twist_1_scale;\n    float smoothunion_1 = opSmoothUnion(smoothunion_2, twist_1, 0.300);\n    smoothunion_1 *= smoothunion_1_scale;\n    if(smoothunion_4<0.1||smoothunion_3<0.1){hair=false;}\n    return smoothunion_1;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),\n        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\n        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera settings from editor (adjust these as needed)\n    vec3 cameraPos = vec3(2.02, -.2, 4.);\n    vec3 cameraTarget = vec3(-0.51, -0.88, -0.15);\n    \n    // Calculate ray direction\n    vec3 forward = normalize(cameraTarget - cameraPos);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    vec3 ro = cameraPos;\n    \n    float t = 0.0;\n    vec3 col = vec3(1.0);\n    \n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = sceneSDF(p);\n        \n        if (d < 0.01) {\n            vec3 n = calcNormal(p);\n            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n            float diff = max(dot(n, lightDir), 0.0);\n            float amb = 0.3;\n            col = vec3(0.7) * (diff + amb);\n            if(hair){col=vec3(0.4)* (diff + amb);}\n            break;\n        }\n        \n        if (t > 20.0) break;\n        // Conservative step multiplier for complex/approximate SDFs\n        t += d * 0.5;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3ccBRH",
    "date": "1765444250",
    "viewed": 144,
    "name": "Circle Invert Universe Ball 2",
    "description": "I had to try this.\nClick on canvas to divide between regular and inverted\nHigher mouse.y = wider transition width + smooth geometric transition\nReduce AA if it runs slowly.",
    "likes": 16,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarch",
     "circle",
     "abstract",
     "inversion"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// forked from Universe Ball 2 by diatribes https://www.shadertoy.com/view/WcGcWV\n\n// inspired by @Jaenam's gem shaders\n// e.g., https://www.shadertoy.com/view/t3SyzV\n// multisampling - 2 or 3 looks better but watch FPS, set to 0 for higher FPS\n#define AA 0\n\n\n// can play with color here\n#define PALETTE vec3(6,3,2)\nvoid mainImage0(out vec4 o, vec2 u) {\n\n    float xm = iMouse.x==0.0?iResolution.x/2.:iMouse.x; \n    float ym = iMouse.y==0.0?iResolution.y/2.:iMouse.y;\n    vec2 uo = u; // get divider values\n\n    float n,i,s,t=iTime*.2, d,v;\n    vec3  q,p = iResolution, c;\n    u = (u+u-p.xy)/p.y;\n    \n    float centerY = iResolution.y / 2.0;\n    \n    if(ym > centerY) {\n        // Above center: geometric transition\n        float transitionWidth = (ym - centerY) * 1.5;\n        float blend = smoothstep(xm - transitionWidth, xm + transitionWidth, uo.x);\n        float inversionRadius = 0.58;\n        vec2 inversionCenter = vec2(0.0, 0.0);\n        vec2 uOffset = u - inversionCenter;\n        float dist = max(length(uOffset), 0.001);\n        float newDist = inversionRadius * pow(dist/inversionRadius, 1.0 - 2.0*blend);\n        u = inversionCenter + newDist * normalize(uOffset);\n        \n        // Render once with the geometric transition\n        vec2 l = u - (u.yx*.9+.3-vec2(-.35,.15));    \n        for(; i++ < 5e1 && d < 5e1;\n            d += s = min(q.y=.01+.6*abs(24. - length(q.xy)),\n                         v = max(s, dot(abs(fract(p)-.5), vec3(.04)))),\n            c +=(1.+cos(p.z+PALETTE))/v\n              +  d*vec3(5,2,1)/q.y/1e1\n              +  7.*vec3(3,4,1)/length(l)\n        )\n            for(q = p = vec3(u * d, d - 16.),\n                s = length(p)-8.,\n                p.xy *= mat2(cos(t+p.z*.6+vec4(0,33,11,0))),\n                p += cos(t+p.zxy)+cos(t+p.yzx*s)/s/4.,\n                p += .5*cos(t+dot(cos(t+p), p) *  p),\n                n = .02; n < 2.; n *= 1.6\n            )\n                q.y -= abs(dot(sin(4.*t+.3*q / n ), q-q+n));\n\n        c = mix(c, c.yzx, smoothstep(2., .1, length(u)*1.));\n        o.rgb = tanh(c*c/6e7/length(u-.3)+.1*length(u));\n    } else {\n        // Below center: render both versions and fade between them\n        float fadeWidth = (centerY - ym) / 1.5;\n        float blendFactor = smoothstep(xm - fadeWidth, xm + fadeWidth, uo.x);\n        \n        // Render non-inverted version\n        vec2 u_normal = u;\n        vec3 c_normal = vec3(0);\n        float d_normal = 0., i_normal = 0.;\n        vec3 q_normal;\n        \n        vec2 l = u_normal - (u_normal.yx*.9+.3-vec2(-.35,.15));    \n        for(; i_normal++ < 5e1 && d_normal < 5e1;\n            d_normal += s = min(q_normal.y=.01+.6*abs(24. - length(q_normal.xy)),\n                         v = max(s, dot(abs(fract(p)-.5), vec3(.04)))),\n            c_normal +=(1.+cos(p.z+PALETTE))/v\n              +  d_normal*vec3(5,2,1)/q_normal.y/1e1\n              +  7.*vec3(3,4,1)/length(l)\n        )\n            for(q_normal = p = vec3(u_normal * d_normal, d_normal - 16.),\n                s = length(p)-8.,\n                p.xy *= mat2(cos(t+p.z*.6+vec4(0,33,11,0))),\n                p += cos(t+p.zxy)+cos(t+p.yzx*s)/s/4.,\n                p += .5*cos(t+dot(cos(t+p), p) *  p),\n                n = .02; n < 2.; n *= 1.6\n            )\n                q_normal.y -= abs(dot(sin(4.*t+.3*q_normal / n ), q_normal-q_normal+n));\n        c_normal = mix(c_normal, c_normal.yzx, smoothstep(2., .1, length(u_normal)*1.));\n        \n        // Render inverted version\n        vec2 u_inverted = u;\n        float inversionRadius = 0.58;\n        vec2 inversionCenter = vec2(0.0, 0.0);\n        vec2 uOffset = u_inverted - inversionCenter;\n        float dist = length(uOffset);\n        if(dist > 0.001) {\n            u_inverted = inversionCenter + (inversionRadius * inversionRadius / (dist * dist)) * uOffset;\n        }\n        \n        vec3 c_inverted = vec3(0);\n        float d_inverted = 0., i_inverted = 0.;\n        vec3 q_inverted;\n        \n        l = u_inverted - (u_inverted.yx*.9+.3-vec2(-.35,.15));    \n        for(; i_inverted++ < 5e1 && d_inverted < 5e1;\n            d_inverted += s = min(q_inverted.y=.01+.6*abs(24. - length(q_inverted.xy)),\n                         v = max(s, dot(abs(fract(p)-.5), vec3(.04)))),\n            c_inverted +=(1.+cos(p.z+PALETTE))/v\n              +  d_inverted*vec3(5,2,1)/q_inverted.y/1e1\n              +  7.*vec3(3,4,1)/length(l)\n        )\n            for(q_inverted = p = vec3(u_inverted * d_inverted, d_inverted - 16.),\n                s = length(p)-8.,\n                p.xy *= mat2(cos(t+p.z*.6+vec4(0,33,11,0))),\n                p += cos(t+p.zxy)+cos(t+p.yzx*s)/s/4.,\n                p += .5*cos(t+dot(cos(t+p), p) *  p),\n                n = .02; n < 2.; n *= 1.6\n            )\n                q_inverted.y -= abs(dot(sin(4.*t+.3*q_inverted / n ), q_inverted-q_inverted+n));\n        c_inverted = mix(c_inverted, c_inverted.yzx, smoothstep(2., .1, length(u_inverted)*1.));\n        \n        // Blend the two rendered colors\n        c = mix(c_normal, c_inverted, blendFactor);\n        o.rgb = tanh(c*c/6e7/length(mix(u_normal, u_inverted, blendFactor)-.3)+.1*length(mix(u_normal, u_inverted, blendFactor)));\n    }\n}\n// multisampling, from \"Weyl Supersample Any Shader\" by spalmer https://www.shadertoy.com/view/WXjXRt\n// (forked from from \"postprocess existing shaders\" by FabriceNeyret2 https://www.shadertoy.com/view/NdyfRz \nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 1.+ float(AA), k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n} ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3ftBRl",
    "date": "1766164973",
    "viewed": 102,
    "name": "Chronotronic KIFS Organism",
    "description": "I went looking for a xmas tree fractal in the KIFS dimension and found this instead.",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fractal",
     "animated",
     "folding",
     "kifs",
     "symmetry"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define ITERATIONS sinl(12.0, lTime, 6.0, 10.0)\n#define PRIMX sinl(0.15, iTime, 0.05, 0.2345)\n#define PRIMY sinl(0.15, mTime, 0.05, 0.2345)\n#define PRIMZ sinl(0.15, lTime, 0.05, 0.2345)\n#define PRIMR sinl(0.15, nTime, 0.05, 0.2345)\n\n#define MAX_STEPS 200\n#define MAX_DIST 250.0\n#define SURF_DIST 0.0001\n#define VOLUMETRIC 0\n#define SCALE 1.1\n#define STEP_MUL 0.8\n#define BAILOUT 200.0\n#define AA 2\n#define BG 0.0\n#define FOG 800.0\n#define CAM_DIST sinl(19.0, iTime, -4.0, 10.0)\n#define FOV 2.0\n#define SDF_EXPAND 0.0\n#define OFFSETX sinl(0.1, nTime, 0.05, 7.0)\n#define OFFSETY sinl(0.1, mTime, 0.05, 3.0)\n#define OFFSETZ sinl(0.1, lTime, 0.05, 5.0)\n#define ITEROTX sinl(0.5, lTime, 0.5, 3.0)\n#define ITEROTY sinl(0.5, nTime, 0.5, 5.0)\n#define ITEROTZ sinl(0.5, mTime, 0.5, 7.0)\n\nmat2 rot2D(float a) { float s = sin(a), c = cos(a);return mat2(c, -s, s, c); }\n\nmat3 rotX(float a) { float s = sin(a), c = cos(a); return mat3(1, 0, 0, 0, c, -s, 0, s, c); }\n\nmat3 rotY(float a) { float s = sin(a), c = cos(a); return mat3(c, 0, s, 0, 1, 0, -s, 0, c); }\n\nmat3 rotZ(float a) { float s = sin(a), c = cos(a); return mat3(c, -s, 0, s, c, 0, 0, 0, 1); }\n\nvec3 foldPlane(vec3 p, vec3 normal, float offset) {\n\n   float d = dot(p, normal) - offset;\n   if (d < 0.0) p -= 2.0 * d * normal;\n   return p;\n}\n\nvec3 foldBox(vec3 p, vec3 size) { return clamp(p, -size, size) * 2.0 - p; }\n\nvec3 foldSphere(vec3 p, float minRadius, float maxRadius) {\n   float r2 = dot(p, p);\n   if (r2 < minRadius * minRadius) {\n       p *= maxRadius * maxRadius / (minRadius * minRadius);\n   } else if (r2 < maxRadius * maxRadius) {\n       p *= maxRadius * maxRadius / r2;\n   }\n   return p;\n}\n\nvec3 foldKaleidoscopic(vec3 p, float angle) {\n   float a = atan(p.y, p.x);\n   float r = length(p.xy);\n   a = mod(a + angle, 2.0 * angle) - angle;\n   p.xy = vec2(cos(a), sin(a)) * r;\n   return p;\n}\n\nvec3 foldKaleidoscopic2(vec3 p, float angle) {\n   float a = atan(p.z, p.x);\n   float r = length(p.xz);\n   a = mod(a + angle, 2.0 * angle) - angle;\n   p.xz = vec2(cos(a), sin(a)) * r;\n   return p;\n}\n\n\nvec3 fold(vec3 p, int ftype) {\n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    switch (ftype){\n        case 0: return abs(p);\n        case 1: return sqrt(p*p + 0.01);\n        case 2:  return sqrt(p*p + 0.02);\n        case 3:  return sqrt(p*p + 0.04);\n        case 4:  return sqrt(p*p + 0.08);\n        case 5: p.x = abs(p.x); return p;\n        case 6: p.y = abs(p.y); return p;\n        case 7: p.z = abs(p.z); return p;\n        case 8: p.xy = abs(p.xy); return p;\n        case 9: p.xz = abs(p.xz); return p;\n        case 10: p.yz = abs(p.yz); return p;\n        case 11: //p = abs(p); //octahedral\n   if (p.x - p.y<0.0) p.xy = p.yx;\n   if (p.x - p.z<0.0) p.xz = p.zx;\n   if (p.y - p.z<0.0) p.yz = p.zy;\n   return p;\n        case 12://p = abs(p);\n        if (p.x < p.y) p.xy = p.yx; //menger\n        if (p.x < p.y) p.xz = p.zx;\n        if (p.y < p.z) p.yz = p.zy;\n   return p;\n   case 13: //dodeca\n\n   vec3 n = normalize(vec3(0.0, 1.0, phi));\n   //p = abs(p);\n   p -= 2.0 * min(0.0, dot(p, n)) * n;\n   n = normalize(vec3(phi, 0.0, 1.0));\n   p -= 2.0 * min(0.0, dot(p, n)) * n;\n   n = normalize(vec3(1.0, phi, 0.0));\n   p -= 2.0 * min(0.0, dot(p, n)) * n;\n   return p;\n    case 14: //icosa\n       \n   vec3 n1 = normalize(vec3(1.0, phi, 0.0));\n   vec3 n2 = normalize(vec3(0.0, 1.0, phi));\n   vec3 n3 = normalize(vec3(phi, 0.0, 1.0));\n   //p = abs(p);\n   if (dot(p, n1) < 0.0) p -= 2.0 * dot(p, n1) * n1;\n   if (dot(p, n2) < 0.0) p -= 2.0 * dot(p, n2) * n2;\n   if (dot(p, n3) < 0.0) p -= 2.0 * dot(p, n3) * n3;\n   return p;\n    case 15: //sierp\n       if (p.x + p.y < 0.0) p.xy = -p.yx;\n   if (p.x + p.z < 0.0) p.xz = -p.zx;\n   if (p.y + p.z < 0.0) p.yz = -p.zy;\n   return p;\n\n    }\n}\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvec3 primitiveColor;\nfloat primitive(vec3 p, vec3 size, float round) {\n   vec3 d = abs(p) - size;\n   vec3 pcol = p;\n   p=clamp(p,vec3(-2,0.5, 0.4),vec3(2,0.85, 0.6));\n   primitiveColor = hsl2rgb(p);\n   return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0)-round;\n}\n\nvec3 orbitTrap;\nfloat lTime, mTime, nTime;\n\nfloat sinl(float value, float time, float amp, float freq){\n    return value+amp*sin(time/freq);\n}\nfloat map(vec3 p) {\n\n    orbitTrap = vec3(1e20);\n\n    vec3 offset = vec3(OFFSETX, OFFSETY, OFFSETZ); \n   \n    mat3 iterRot = rotX(ITEROTX) * rotY(ITEROTY) * rotZ(ITEROTZ); \n\n   float scale = SCALE;\n   float totalScale = scale;\n   \n   int   witer = int(floor(ITERATIONS));\n   float piter = fract(ITERATIONS);\n   vec3 pa, pb;\n   pb = p;\n   for (int i = 0; i <= witer; i++) {\n    orbitTrap = min(orbitTrap, abs(p)); \n       pa = p;\n\n\n    p = fold(p,11);\n    p = foldPlane(p,normalize(vec3(-.53,.296,-.384)), .136);\n    p = foldPlane(abs(p),normalize(vec3(.272,-.754,-.47)), -.222);\n    \n    \n    // for more volatile version:\n\n    //p = foldPlane(p,normalize(vec3(sinl(-.2, nTime, .3, 7.0),sinl(-.2, lTime, .3, 9.0),-sinl(-.2, iTime, .3, 5.0))), sinl(-.2, mTime, .3, 3.0));\n    //p = foldPlane(abs(p),normalize(vec3(sinl(-.2, lTime, .3, 3.0),sinl(-.2, iTime, .3, 7.0),-sinl(-.2, mTime, .3, 9.0))), sinl(-.2, nTime, .3, 5.0));\n\n\n    p = abs(p);\n\n    p = iterRot * p;\n       \n\n    p = p * scale - offset;\n       \n\n    totalScale *= scale;\n       \n       pb = p;\n       if (dot(p, p) > BAILOUT * BAILOUT) break;\n   }\n\n   p = mix(pa,pb, piter);\n       \n\n\n    float de = primitive(p, vec3(PRIMX,PRIMY,PRIMZ), PRIMR);\n\n   return (de / totalScale)-SDF_EXPAND;\n}\n// Volumetric raymarch - samples density throughout the volume\nvec4 raymarch_volumetric(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 color = vec3(0);\n    float alpha = 0.0;\n    \n    float stepSize = 0.1;\n\n    \n    for (int i = 0; i < 650; i++) {\n        if (alpha > 0.99) break;\n        \n        vec3 p = ro + rd * t;\n        float d = map(p);\n        float density = max(0.0, -d * 10.0); \n        \n        // Alternative: soft density falloff\n       density += exp(-max(d, 0.0) * 100.0) * 0.1;\n        \n        if (density > 0.01) {\n\n              vec3 sampleCol = vec3(\n        0.5 + 0.5 * sin(orbitTrap.x * 3.0),\n        0.5 + 0.5 * sin(orbitTrap.y * 3.0 + 2.0),\n        0.5 + 0.5 * sin(orbitTrap.z * 3.0 + 4.0)\n    );\n            // Accumulate color and alpha\n            float sampleAlpha = density * stepSize;\n            color += sampleCol * sampleAlpha * (1.0 - alpha);\n            alpha += sampleAlpha * (1.0 - alpha);\n        }\n        \n        t += stepSize;\n        if (t > MAX_DIST) break;\n    }\n    \n    return vec4(color, alpha)*alpha*alpha*alpha;\n}\n//\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if (abs(d) < SURF_DIST) break;\n        if (t > MAX_DIST) break;\n        t += d * STEP_MUL;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.0003, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nfloat getAO(vec3 p, vec3 n) {\n    float ao = 0.0;\n    float w = 1.0;\n    for (int i = 1; i <= 5; i++) {\n        float d = float(i) * 0.08;\n        ao += w * (d - map(p + n * d));\n        w *= 0.5;\n    }\n    return 1.0 - clamp(ao * 2.5, 0.0, 1.0);\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float tmax) {\n    float res = 1.0;\n    float t = 0.02;\n    for (int i = 0; i < 64; i++) {\n        float d = map(ro + rd * t);\n        if (d < 0.0005) return 0.0;\n        res = min(res, 10.0 * d / t);\n        t += clamp(d, 0.01, 0.15);\n        if (t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 shade(vec3 p, vec3 rd, float t) {\n\n       \n        vec3 n = getNormal(p);\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 2.0, 1.5));\n        vec3 lightDir2 = normalize(vec3(-1.0, 0.5, -1.0));\n        vec3 viewDir = -rd;\n        vec3 halfVec = normalize(lightDir + viewDir);\n        \n        float diff = max(dot(n, lightDir), 0.0);\n        float diff2 = max(dot(n, lightDir2), 0.0);\n        float spec = pow(max(dot(n, halfVec), 0.0), 32.0);\n        float fresnel = pow(1.0 - max(dot(n, viewDir), 0.0), 3.0);\n        \n        // Optional effects\n        float ao = getAO(p, n);\n        float shadow = getShadow(p + n * 0.002, lightDir, 8.0);\n        \n            // Color from orbit trap\n    vec3  matCol= vec3(\n        0.5 + 0.5 * sin(orbitTrap.x * 3.0),\n        0.5 + 0.5 * sin(orbitTrap.y * 3.0 + 2.0),\n        0.5 + 0.5 * sin(orbitTrap.z * 3.0 + 4.0)\n    );\n        matCol = mix(matCol, primitiveColor, ao);\n        // Compose lighting\n        vec3 col = matCol * 0.08; // Ambient\n        col += matCol * diff * shadow * 0.65;\n        col += vec3(0.2, 0.3, 0.4) * diff2 * 0.25;\n        col += vec3(1.0, 0.95, 0.9) * spec * shadow * 0.6;\n        col += vec3(0.3, 0.4, 0.5) * fresnel * 0.15;\n        col *= ao;\n        \n        // Distance fog\n        col = mix(col, vec3(BG), min(1.0,max(0.0,(t-sqrt(FOG))/25.)));\n        return col;\n}\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);}\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    lTime=(iTime+(fragCoord.x/iResolution.x))*3.0-(fragCoord.y/iResolution.y)*4.0;\n\n    mTime = iTime+(fragCoord.x/iResolution.x);\n\n    nTime = iTime+(fragCoord.y/iResolution.y)*2.0;\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float rotX = (mouse.x - 0.5) * 6.28318;\n    float rotY = (mouse.y - 0.5) * 3.14159;\n    \n    if (iMouse.z <= 0.0) {\n        rotX = iTime * 0.2;\n        rotY = 0.3;\n    }\n\n    vec3 ro = vec3(0.0, 0.0, CAM_DIST);\n    vec3 rd = normalize(vec3(uv, -FOV));\n\n    rd.yz *= rot2D(-rotY);\n    rd.xz *= rot2D(rotX);\n    ro.yz *= rot2D(-rotY);\n    ro.xz *= rot2D(rotX);\n\n    vec3 col = vec3(BG);\n    if(VOLUMETRIC==0){\n        float t = rayMarch(ro, rd);\n        vec3 p = ro + rd * t;\n        if (t < MAX_DIST) { col = shade(p, rd, t); }\n    } else {\n        col += raymarch_volumetric(ro, rd).rgb*10.;\n    }\n    //col = col / (col + vec3(1.0));\n   col = pow(col, vec3(0.3545));\n    col = contrast(col, 1.6);\n    fragColor = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = max(1.,float(AA)), k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tccBWj",
    "date": "1766318615",
    "viewed": 66,
    "name": "Randomised, subdivided KIFS",
    "description": "the KIFS fractals are randomised.\nBut the iterations, inc folds and transforms, are also randomised.\nThis produces more interesting shapes reminiscent of spaceships.\nSee more here: [url]https://www.sleditor.com/#id=a7zasp0vl[/url]",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "fractal",
     "kifs",
     "realtime",
     "recursion"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Forked from:\n// recursively split raymarching by MJK123 https://www.shadertoy.com/view/3cVcDG\n\n// and:          Random KIFS       https://www.sleditor.com/#id=a7zasp0vl\n// see also:    KIFS organism      https://www.shadertoy.com/view/3ftBRl\n// and:          KIFS explorer     https://www.sleditor.com/#id=h05ibfmqh\n\n#define AA 2  // lower or increase this for better FPS or better quality, respectively.\n\n#define MAX_STEPS 120\n#define MAX_DIST 100.0\n#define SURF_DIST 0.0001\n#define STEP_MUL 0.8\n#define FOG 400.0\n#define CAM_DIST 1.0\n#define FOV 3.0\n\n\n// Subdivision settings\n\n#define R iResolution.xy\n#define ASPECT (iResolution.x / iResolution.y)\nconst float TAU = 6.283185307179586;\n\nvec2 cellId;\nuint gSeed;\nfloat currentKifsSeed;\nfloat cellBG;\n\n// Hash functions for subdivision\nuint hash(uint x) {\n    x += x << 10u; x ^= x >> 6u;\n    x += x << 3u;  x ^= x >> 11u;\n    x += x << 15u; return x;\n}\nuint hash(uvec2 v) { return hash(v.x ^ hash(v.y)); }\nuint hash(uvec3 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z)); }\n\nvoid initSeed(vec2 v)  { gSeed = hash(floatBitsToUint(v)); }\nvoid initSeed(vec3 v)  { gSeed = hash(floatBitsToUint(v)); }\n\nfloat floatConstruct(uint m) {\n    const uint M = 0x007FFFFFu;\n    const uint O = 0x3F800000u;\n    return uintBitsToFloat((m & M) | O) - 1.0;\n}\n\nfloat random() { gSeed = hash(gSeed); return floatConstruct(gSeed); }\n\nmat2 rot2D(float a) { float s = sin(a), c = cos(a); return mat2(c, -s, s, c); }\n\nvec3 hsl2rgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));\n}\n\nfloat hash11(float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash31(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 fold(vec3 p, vec3 normal, float offset) {\n    float d = dot(p, normal) - offset;\n    return p - 2.0 * min(d, 0.0) * normal;\n}\n\nvec3 primitiveColor;\nfloat primitive(vec3 p, vec3 size, float round) {\n    vec3 d = abs(p) - size;\n    p = clamp(p, vec3(0, 0.5, 0.4), vec3(2, 0.85, 0.6));\n    primitiveColor = hsl2rgb(p);\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0) - round;\n}\n\nvec3 orbitTrap;\nfloat kifs(vec3 p, float seed) {\n    orbitTrap = vec3(1e20);\n    int maxIter = 3 + int(hash11(seed) * 8.0);\n    vec3 primSize = vec3(0.3, 0.5, 0.7) * (0.5 + hash31(seed + 100.0));\n    float primRound = hash11(seed + 200.0) * 0.3;\n    float scale = 1.0;\n    const float BAILOUT = 100.0;\n    const float MAX_SCALE = 1e6;\n    float iterSeed = seed;\n    \n    for(int i = 0; i < 8; i++) {\n        if(i >= maxIter) break;\n        if(length(p) > BAILOUT) break;\n        if(scale > MAX_SCALE) break;\n        orbitTrap = min(orbitTrap, abs(p));\n        \n        iterSeed = hash11(iterSeed + 42.0) > 0.5 ? iterSeed + float(i) * 17.31 : iterSeed;\n        p = abs(p);\n        \n        float foldType = hash11(iterSeed + 50.0);\n        if(foldType < 0.33) {\n            vec3 c = hash31(iterSeed + 51.0) * 0.3;\n            p = abs(p - c) - c * 0.5;\n        } else if(foldType < 0.66) {\n            if(hash11(iterSeed + 52.0) < 0.5) p = p.yzx;\n            else p = p.zxy;\n        }\n        \n        int folds = 1 + int(hash11(iterSeed) * 3.0);\n        for(int j = 0; j < 3; j++) {\n            if(j >= folds) break;\n            vec3 n = normalize(hash31(iterSeed + float(j) * 7.77) * 2.0 - 1.0);\n            p = fold(p, n, 0.0);\n        }\n        \n        vec3 translation = hash31(iterSeed + 1.0) * 0.3;\n        float iterScale = 1.6 + hash11(iterSeed + 2.0) * 0.6;\n        p = p * iterScale - translation;\n        scale *= iterScale;\n    }\n    \n    return primitive(p, primSize, primRound) / scale;\n}\n\nfloat map(vec3 p) {\n    return kifs(p, currentKifsSeed);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if(abs(d) < SURF_DIST) break;\n        if(t > MAX_DIST) break;\n        t += d * STEP_MUL;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.0003, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nfloat getAO(vec3 p, vec3 n) {\n    float ao = 0.0, w = 1.0;\n    for(int i = 1; i <= 5; i++) {\n        float d = float(i) * 0.08;\n        ao += w * (d - map(p + n * d));\n        w *= 0.5;\n    }\n    return 1.0 - clamp(ao * 2.5, 0.0, 1.0);\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float tmax) {\n    float res = 1.0, t = 0.02;\n    for(int i = 0; i < 48; i++) {\n        float d = map(ro + rd * t);\n        if(d < 0.0005) return 0.0;\n        res = min(res, 10.0 * d / t);\n        t += clamp(d, 0.01, 0.15);\n        if(t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 shade(vec3 p, vec3 rd, float t) {\n    vec3 n = getNormal(p);\n    \n    vec3 lightDir = normalize(vec3(1.0, 2.0, 1.5));\n    vec3 lightDir2 = normalize(vec3(-1.0, 0.5, -1.0));\n    vec3 viewDir = -rd;\n    vec3 halfVec = normalize(lightDir + viewDir);\n    \n    float diff = max(dot(n, lightDir), 0.0);\n    float diff2 = max(dot(n, lightDir2), 0.0);\n    float spec = pow(max(dot(n, halfVec), 0.0), 32.0);\n    float fresnel = pow(1.0 - max(dot(n, viewDir), 0.0), 3.0);\n    \n    float ao = getAO(p, n);\n    float shadow = getShadow(p + n * 0.002, lightDir, 8.0);\n    \n    vec3 matCol = vec3(\n        0.5 + 0.5 * sin(orbitTrap.x * 3.0),\n        0.5 + 0.5 * sin(orbitTrap.y * 3.0 + 2.0),\n        0.5 + 0.5 * sin(orbitTrap.z * 3.0 + 4.0)\n    );\n    matCol = mix(primitiveColor,matCol, ao);\n    \n    vec3 col = matCol * 0.08;\n    col += matCol * diff * shadow * 0.65;\n    col += vec3(0.2, 0.3, 0.4) * diff2 * 0.25;\n    col += vec3(1.0, 0.95, 0.9) * spec * shadow * 0.6;\n    col += vec3(0.3, 0.4, 0.5) * fresnel * 0.15;\n    col *= ao;\n    \n    col = mix(col, vec3(cellBG), min(1.0, max(0.0, (t - sqrt(FOG)) / 25.0)));\n    return col;\n}\n\nvec3 contrast(vec3 color, float value) { return 0.5 + value * (color - 0.5); }\n\nvec4 applySubd(vec2 uv, float timeIndex) {\n    cellId = vec2(0);\n    vec4 cell = vec4(0, 0, 1, 1);\n    \n    // Moderate settings\n    const float MIN_SPLITS = 1.0;\n    const float MAX_SPLITS = 8.0;\n    const float COMPLEXITY_MIN = 2.0;\n    const float COMPLEXITY_RANGE = 2.5;\n    \n    initSeed(vec2(timeIndex, 777.0));\n    float baseComplexity = COMPLEXITY_MIN + random() * COMPLEXITY_RANGE;\n    \n    for(float i = 0.0; i < MAX_SPLITS; i++) {\n        initSeed(vec3(cellId, timeIndex));\n        float r = mix(0.35, 0.65, random());\n        \n        if(i >= MIN_SPLITS) {\n            float stopProb = (i - MIN_SPLITS + 0.5) / baseComplexity;\n            stopProb = clamp(stopProb * stopProb, 0.0, 0.8);\n            if(random() < stopProb) break;\n        }\n        \n        if(random() > 0.5) {\n            float split = cell.x + cell.z * r;\n            if(uv.x > split) {\n                cell.x += cell.z * r;\n                cell.z *= 1.0 - r;\n                cellId.x += exp2(i);\n            } else {\n                cell.z *= r;\n            }\n        } else {\n            float split = cell.y + cell.w * r;\n            if(uv.y > split) {\n                cell.y += cell.w * r;\n                cell.w *= 1.0 - r;\n                cellId.y += exp2(i);\n            } else {\n                cell.w *= r;\n            }\n        }\n    }\n    \n    return cell;\n}\n\nvoid mainImage0(out vec4 O, in vec2 I) {\n    vec2 uv = I / R;\n    \n    // Continuous horizontal scroll\n    float scrollSpeed = 0.12; // Screens per second (adjust to taste)\n    float scrollOffset = fract(iTime * scrollSpeed);\n    float currentIdx = floor(iTime * scrollSpeed);\n    float nextIdx = currentIdx + 1.0;\n    \n    // Offset UV horizontally\n    vec2 scrolledUV = uv;\n    scrolledUV.x = scrolledUV.x + scrollOffset;\n    \n    // Determine which arrangement\n    float timeIndex;\n    if(scrolledUV.x < 1.0) {\n        timeIndex = currentIdx;\n    } else {\n        timeIndex = nextIdx;\n        scrolledUV.x -= 1.0;\n    }\n    \n    // Get cell for this pixel\n    vec4 cell = applySubd(scrolledUV, timeIndex);\n    \n    // Per-cell random values\n    initSeed(vec3(cellId, timeIndex));\n    currentKifsSeed = random() * 10000.0;\n    float rotSeed1 = random();\n    float rotSeed2 = random();\n    \n    \n    // Local UV within cell\n    vec2 ndc = (scrolledUV - cell.xy) / cell.zw * 2.0 - 1.0;\n    float cellAspect = (cell.z * R.x) / (cell.w * R.y);\n    ndc.x *= cellAspect;\n    cellBG = random() * 0.03;\n    // Camera\n    vec3 ro = vec3(0.0, 0.0, CAM_DIST);\n    vec3 rd = normalize(vec3(ndc, -FOV));\n    \n    // Per-cell rotation\n    float angle1 = rotSeed1 * TAU + iTime * 0.3;\n    float angle2 = rotSeed2 * TAU + iTime * 0.17;\n    ro.xz *= rot2D(angle1);\n    rd.xz *= rot2D(angle1);\n    ro.yz *= rot2D(angle2);\n    rd.yz *= rot2D(angle2);\n    \n    // Render\n    vec3 col = vec3(random() * 0.035,random() * 0.02,random() * 0.05);\n    float t = rayMarch(ro, rd);\n    \n    if(t < MAX_DIST) {\n        vec3 p = ro + rd * t;\n        col = shade(p, rd, t);\n    }\n    \n    col = pow(col, vec3(0.4));\n    col = contrast(col, 1.4);\n    \n    // Cell outline\n    vec2 uvA = scrolledUV; uvA.x *= ASPECT;\n    vec2 cA = cell.xy; cA.x *= ASPECT;\n    vec2 sA = cell.zw; sA.x *= ASPECT;\n    float dx = min(uvA.x - cA.x, (cA.x + sA.x) - uvA.x);\n    float dy = min(uvA.y - cA.y, (cA.y + sA.y) - uvA.y);\n    //col += smoothstep(1.0, 0.002, min(dx, dy)/1.01);\n    \n    O = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = max(1.,float(AA)), k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfdfW2",
    "date": "1766366443",
    "viewed": 56,
    "name": "Attack ships on fire",
    "description": "..off the shoulder of Orion\n\nClick to change",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fire",
     "kifs",
     "tearsinrain"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec3 fireGradient(float t) {\n    // Black -> Red -> Orange -> Yellow -> White\n    return vec3(\n        smoothstep(0.0, 0.35, t),\n        smoothstep(0.25, 0.7, t) * smoothstep(0.0, 0.2, t),\n        smoothstep(0.6, 1.0, t)\n    ) * smoothstep(0.0, 0.1, t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float fire = texture(iChannel0, uv).r;\n    \n    // Apply fire colors\n    vec3 col = fireGradient(fire) * (0.8 + fire * 1.5);\n    \n    // Optional: add glow\n    col += fireGradient(fire * 0.5) * 0.3;\n    \n    fragColor =  atan(texture(iChannel1, uv) + vec4(col, 1.0)/2.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define MAX_STEPS 200\n#define MAX_DIST 250.0\n#define SURF_DIST 0.0001\n#define VOLUMETRIC 0 // dont turn this on its too slow unless youre on a 4090\n#define SCALE 1.1\n#define STEP_MUL 0.8\n#define AA 1\n#define BG 0.0\n#define FOG 800.0\n#define CAM_DIST 2.5\n#define FOV 1.0\nvec2 cellID;\nvec4 guv;\nmat2 rot2D(float a) { float s = sin(a), c = cos(a);return mat2(c, -s, s, c); }\n\nmat3 rotX(float a) { float s = sin(a), c = cos(a); return mat3(1, 0, 0, 0, c, -s, 0, s, c); }\n\nmat3 rotY(float a) { float s = sin(a), c = cos(a); return mat3(c, 0, s, 0, 1, 0, -s, 0, c); }\n\nmat3 rotZ(float a) { float s = sin(a), c = cos(a); return mat3(c, -s, 0, s, c, 0, 0, 0, 1); }\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nfloat hash11(float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash31(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 fold(vec3 p, vec3 normal, float offset) {\n    float d = dot(p, normal) - offset;\n    return p - 2.0 * min(d, 0.0) * normal;\n}\nvec3 primitiveColor;\nfloat primitive(vec3 p, vec3 size, float round) {\n   vec3 d = abs(p) - size;\n   vec3 pcol = p;\n   p=clamp(p,vec3(-2,0.5, 0.4),vec3(2,0.85, 0.6));\n   primitiveColor = hsl2rgb(p);\n   return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0)-round;\n}\n//float primitive(vec3 p, vec3 size, float round) { vec3 d = abs(p) - size;return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0) - round;}\nvec3 orbitTrap;\nfloat kifs(vec3 p, float seed) {\n     orbitTrap = vec3(1e20);\n    int maxIter = 3 + int(hash11(seed) * 8.0);\n    vec3 primSize = vec3(0.3, 0.5, 0.7) * (0.5 + hash31(seed + 100.0));\n    float primRound = hash11(seed + 200.0) * 0.3;\n    float scale = 1.0;\n    const float BAILOUT = 100.0;\n    const float MAX_SCALE = 1e6;\n    float iterSeed = seed;\n    for(int i = 0; i < 8; i++) {\n        if(i >= maxIter) break;\n        \n        // Bailout detection - point escaping\n        if(length(p) > BAILOUT) break;\n        \n        // Runaway scale detection\n        if(scale > MAX_SCALE) break;\n        orbitTrap = min(orbitTrap, abs(p)); \n\n        iterSeed = hash11(iterSeed + 42.0)>0.3?iterSeed + float(i) * 17.31:iterSeed;\n        \n        // Core abs fold\n        p = abs(p);\n        \n        // Additional axis-aligned operations\n        float foldType = hash11(iterSeed + 50.0);\n        if(foldType < 0.33) {\n            // Offset fold (Menger-style)\n            vec3 c = hash31(iterSeed + 51.0) * 0.3;\n            p = abs(p - c) - c * 0.5;\n        } else if(foldType < 0.66) {\n            // Component rotation for variety\n            if(hash11(iterSeed + 52.0) < 0.5) p = p.yzx;\n            else p = p.zxy;\n        }\n        \n        // 1-3 random plane folds (increased from 1-2)\n        int folds = 1 + int(hash11(iterSeed) * 3.0);\n        for(int j = 0; j < 3; j++) {\n            if(j >= folds) break;\n            vec3 n = normalize(hash31(iterSeed + float(j) * 7.77) * 2.0 - 1.0);\n            p = fold(p, n, 0.0);\n        }\n        \n        // Scale and translate\n        vec3 translation = hash31(iterSeed + 1.0) * 0.3;\n        float iterScale = 1.4 + hash11(iterSeed + 2.0) * 0.2;\n        \n        p = p * iterScale - translation;\n        scale *= iterScale;\n    }\n    \n    return primitive(p, primSize, primRound) / scale;\n}\n\nfloat map(vec3 p) {\n    float seed = iMouse.x+iMouse.y/100.+cellID.x + (cellID.y / 10.); ;//floor(iTime);\n    return kifs(p, seed);\n}\n\n\n// Volumetric raymarch - samples density throughout the volume\nvec4 raymarch_volumetric(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 color = vec3(0);\n    float alpha = 0.0;\n    \n    float stepSize = 0.1;\n\n    \n    for (int i = 0; i < 650; i++) {\n        if (alpha > 0.99) break;\n        \n        vec3 p = ro + rd * t;\n        float d = map(p);\n        float density = max(0.0, -d * 10.0); \n        \n        // Alternative: soft density falloff\n       density += exp(-max(d, 0.0) * 100.0) * 0.1;\n        \n        if (density > 0.01) {\n\n              vec3 sampleCol = vec3(\n        0.5 + 0.5 * sin(orbitTrap.x * 3.0),\n        0.5 + 0.5 * sin(orbitTrap.y * 3.0 + 2.0),\n        0.5 + 0.5 * sin(orbitTrap.z * 3.0 + 4.0)\n    );\n            // Accumulate color and alpha\n            float sampleAlpha = density * stepSize;\n            color += sampleCol * sampleAlpha * (1.0 - alpha);\n            alpha += sampleAlpha * (1.0 - alpha);\n        }\n        \n        t += stepSize;\n        if (t > MAX_DIST) break;\n    }\n    \n    return vec4(color, alpha)*alpha*alpha*alpha;\n}\n//\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if (abs(d) < SURF_DIST) break;\n        if (t > MAX_DIST) break;\n        t += d * STEP_MUL;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.0003, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nfloat getAO(vec3 p, vec3 n) {\n    float ao = 0.0;\n    float w = 1.0;\n    for (int i = 1; i <= 5; i++) {\n        float d = float(i) * 0.08;\n        ao += w * (d - map(p + n * d));\n        w *= 0.5;\n    }\n    return 1.0 - clamp(ao * 2.5, 0.0, 1.0);\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float tmax) {\n    float res = 1.0;\n    float t = 0.02;\n    for (int i = 0; i < 64; i++) {\n        float d = map(ro + rd * t);\n        if (d < 0.0005) return 0.0;\n        res = min(res, 10.0 * d / t);\n        t += clamp(d, 0.01, 0.15);\n        if (t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 shade(vec3 p, vec3 rd, float t) {\n\n       \n        vec3 n = getNormal(p);\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 2.0, 1.5));\n        vec3 lightDir2 = normalize(vec3(-1.0, 0.5, -1.0));\n        vec3 viewDir = -rd;\n        vec3 halfVec = normalize(lightDir + viewDir);\n        \n        float diff = max(dot(n, lightDir), 0.0);\n        float diff2 = max(dot(n, lightDir2), 0.0);\n        float spec = pow(max(dot(n, halfVec), 0.0), 32.0);\n        float fresnel = pow(1.0 - max(dot(n, viewDir), 0.0), 3.0);\n        \n        // Optional effects\n        float ao = getAO(p, n);\n        float shadow = getShadow(p + n * 0.002, lightDir, 8.0);\n        \n            // Color from orbit trap\n    vec3  matCol= vec3(\n        0.5 + 0.5 * sin(orbitTrap.x * 3.0),\n        0.5 + 0.5 * sin(orbitTrap.y * 3.0 + 2.0),\n        0.5 + 0.5 * sin(orbitTrap.z * 3.0 + 4.0)\n    );\n        matCol = mix(matCol, primitiveColor, ao);\n        // Compose lighting\n        vec3 col = matCol * 0.08; // Ambient\n        col += matCol * diff * shadow * 0.65;\n        col += vec3(0.2, 0.3, 0.4) * diff2 * 0.25;\n        col += vec3(1.0, 0.95, 0.9) * spec * shadow * 0.6;\n        col += vec3(0.3, 0.4, 0.5) * fresnel * 0.15;\n        col *= ao;\n        \n        // Distance fog\n        col = mix(col, vec3(BG), min(1.0,max(0.0,(t-sqrt(FOG))/25.)));\n        return col;\n}\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);}\nvec3 mainImage1(vec2 uv, vec2 cid) {\n\n\n    //vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float rotX = (mouse.x - 0.5) * 6.28318;\n    float rotY = (mouse.y - 0.5) * 3.14159;\n    \n    if (iMouse.z <= 0.0) {\n        rotX = iTime * 0.2;\n        rotY = 0.3;\n    }\n\n    vec3 ro = vec3(0.0, 0.0, CAM_DIST);\n    vec3 rd = normalize(vec3(uv, -FOV));\n    // XZ rotation\n    float angle1 = iTime * 2.0* (-0.5+hash11(cid.x+cid.y + 2.0));\n    float c1 = cos(angle1), s1 = sin(angle1);\n    ro.xz = mat2(c1, s1, -s1, c1) * ro.xz;\n    rd.xz = mat2(c1, s1, -s1, c1) * rd.xz;\n    \n    // YZ rotation (second axis)\n    float angle2 = iTime * 2.0*(-0.5+hash11(cid.x+cid.y + 4.0));\n    float c2 = cos(angle2), s2 = sin(angle2);\n    ro.yz = mat2(c2, s2, -s2, c2) * ro.yz;\n    rd.yz = mat2(c2, s2, -s2, c2) * rd.yz;\n    //rd.yz *= rot2D(-rotY);\n    //rd.xz *= rot2D(rotX);\n    //ro.yz *= rot2D(-rotY);\n    //ro.xz *= rot2D(rotX);\n\n    vec3 col = vec3(BG);\n    if(VOLUMETRIC==0){\n        float t = rayMarch(ro, rd);\n        vec3 p = ro + rd * t;\n        if (t < MAX_DIST) { col = shade(p, rd, t); }\n    } else {\n        col += raymarch_volumetric(ro, rd).rgb*10.;\n    }\n    //col = col / (col + vec3(1.0));\n   col = pow(col, vec3(0.4));\n    col = contrast(col, 1.4);\n    return col;\n}\n\nvoid compute_things(in vec2 p, out vec2 h, out vec2 ddx, out vec2 ddy) {\n    const float TAU = 6.28318530718;\n    const mat2 M = mat2(8.0, 5.0, -5.0, 8.0);\n\n    vec2 r = iResolution.xy;\n    vec2 s = sqrt(r / r.yx);\n    vec2 a = 2.0 / r * s;\n    vec2 u = a * p - s;\n    \n    float S = dot(u, u) + 1.0;\n    float invS = 1.0 / S;\n    float invS2 = invS * invS;\n\n    vec3 g = vec3(1.0, u.yx) * invS + vec3(-0.5, 0.0, 0.5);\n\n    float T = dot(g, g);\n    float invT = 1.0 / T;\n    float invT2 = invT * invT;\n\n    vec3 dg_dux = vec3(-2.0 * u.x * invS2, -2.0 * u.x * u.y * invS2, invS - 2.0 * u.x * u.x * invS2);\n    vec3 dg_duy = vec3(-2.0 * u.y * invS2, invS - 2.0 * u.y * u.y * invS2, -2.0 * u.x * u.y * invS2);\n\n    vec3 dg_dx = dg_dux * a.x;\n    vec3 dg_dy = dg_duy * a.y;\n\n    vec2 q = g.xy * invT;\n\n    float dTdx = 2.0 * dot(g, dg_dx);\n    float dTdy = 2.0 * dot(g, dg_dy);\n\n    vec2 dq_dx = dg_dx.xy * invT - g.xy * dTdx * invT2;\n    vec2 dq_dy = dg_dy.xy * invT - g.xy * dTdy * invT2;\n\n    float denom = dot(q, q);\n    float scale = 1.0 / (TAU * denom);\n\n    ddx = vec2(dq_dx.x * q.y - dq_dx.y * q.x, dot(dq_dx, q)) * scale;\n    ddy = vec2(dq_dy.x * q.y - dq_dy.y * q.x, dot(dq_dy, q)) * scale;\n\n    h = vec2(atan(q.x, q.y), log(length(q))) / TAU;\n    h += iTime * 0.07;\n\n    h *= M;\n    ddx *= M;\n    ddy *= M;\n}\n\nmat2 rotate(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage0(out vec4 c, vec2 p) {\n    \n    vec2 h, ddx, ddy;\n    compute_things(p, h, ddx, ddy);\n \n    float a = atan(ddx.x, ddy.x);\n    cellID = floor(h);\n    cellID = mod(cellID, vec2(8, 5));\n    vec2 cellUV = fract(h);\n    \n    vec2 uv = cellUV.yx * 2.0 - 1.0;\n    //uv = mix(  uv*rotate(3.2)  ,    uv*rotate(-a), guv.y*guv.y);\n    uv *= rotate(-a);\n    //uv *= rotate(2.6);\n    vec3 col = mainImage1(uv, cellID);\n    c = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\n    vec2 j = vec2(.5);\n    fragColor = vec4(0);\n    vec4 c;\n    mainImage0(c, fragCoord);\n    float s = float(AA);\n    float k;\n    for (k = s; k-- > .5;) {\n        mainImage0(c, fragCoord + j - .5);\n        fragColor += c;\n        j = fract(j + vec2(.755, .57).yx);\n    }\n    fragColor /= s;\n    fragColor.a = 1.;\n    \n    vec3 color = fragColor.rgb;\n    \n   \n    fragColor = vec4(color, 1.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "float hash11(float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 px = 1.0 / iResolution.xy;\n    \n    // Wobble noise (coherent)\n    float wobble = sin(uv.y * 90.0 + iTime * (15.0+ hash11(uv.x))) * hash11(uv.y)\n                 + sin(uv.y * 120.0 - iTime * (15.0 + hash11(uv.y))+ uv.x * 10.0) * hash11(uv.x);\n    \n    // Sample from below with horizontal wobble (fire rises)\n    vec2 offset = vec2(wobble*3.,-2.+wobble*-3.) * px *0.3;\n    \n    // Blur/diffuse while sampling previous frame\n    float fire = 0.0;\n    fire += texture(iChannel0, uv + offset).r * 0.5;\n    fire += texture(iChannel0, uv + offset + vec2(px.x, 0.0)).r * 0.15;\n    fire += texture(iChannel0, uv + offset - vec2(px.x, 0.0)).r * 0.15;\n    fire += texture(iChannel0, uv + offset + vec2(px.x*2.0, px.y)).r * 0.1;\n    fire += texture(iChannel0, uv + offset - vec2(px.x*2.0, -px.y)).r * 0.1;\n    \n    // Cooling/decay\n    fire *= 0.985;\n    \n    // Add fresh fuel from source\n    float fuel = texture(iChannel1, uv).r;\n    fire = max(fire, fuel);\n    \n    fragColor = vec4(clamp(fire, 0.0, 1.0));\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcKfzh",
    "date": "1766696408",
    "viewed": 71,
    "name": "Binary Black Hole + CubeA",
    "description": "Shadertoy adapted version of a sleditor shader to use a generated cubemap\nBinary Black Holes by Nxrix\nNebula BG from LizardLover42\n",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "3d",
     "blackhole",
     "cubemapa"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzn",
       "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dX3Rr",
       "filepath": "/media/a//media/previz/cubemap00.png",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Forked from: \"Binary Black Holes + Cubemap\" by Cotterzz https://sleditor.com/#id=ajg43c1hu\n\n//         And: \"Binary Black Holes\" by Nxrix: \"https://www.shadertoy.com/view/Wc3BRl\"\n\n//         And: \"Nebula in Space\" by LizardLover42 https://www.shadertoy.com/view/33cSWX\n\n// The sleditor version uses a space cubemap as a skybox.\n// I had to create one using an adapted version of the Nebula in Space shader with Cube A buffer\n// Doesnt look as good as I had to change the noise to 3D and rework the stars, but I'm sure it can be improved.\n\n\nconst float  PI = 3.14159265;\nconst float TAU = 6.28318530;\n\n//#define AA 2\n\nconst float Rs1 = 2.0;\nconst float Rs2 = 1.0;\n\n// Lensing strength multiplier (1.0 = physically accurate, <1.0 = reduced lensing)\nconst float LENSING_STRENGTH = 1.0;\n\n// Roche potential parameters\n// The disk exists where potential is between these values\nconst float POTENTIAL_INNER = -0.3;  // Inner edge (closer to black holes, more negative)\nconst float POTENTIAL_OUTER = -0.09;  // Outer edge (farther out, less negative)\nconst float DISK_THICKNESS = 0.5;\n\nconst vec3 BH1_POS = vec3(-27.0, 0.0, 0.0);\nconst vec3 BH2_POS = vec3( 32.0, 0.0, 0.0);\n\n// Disk lies in XZ plane (Y = 0)\nconst vec3 DISK_AXIS = vec3(0.0, 1.0, 0.0);\n\nconst int MAX_STEPS = 100;\n\nconst float INV_PI = 1.0 / PI;\nconst float INV_SIX_RS1 = 1.0 / (6.0 * Rs1);\nconst float INV_SIX_RS2 = 1.0 / (6.0 * Rs2);\n\nfloat ls(float x) {\n    return 1.0 - abs(mod(x * INV_PI, 2.0) - 1.0) * 2.0;\n}\n\nfloat noise(vec2 p) {\n    return texture(iChannel1, p / 128.0).r;\n}\n\n// Calculate Roche-like gravitational potential\n// More negative = deeper in gravity well\nfloat rochePotential(vec3 p) {\n    float r1 = length(p - BH1_POS);\n    float r2 = length(p - BH2_POS);\n    \n    // Gravitational potential from both black holes\n    // Using Schwarzschild radius as mass proxy\n    float phi = -Rs1 / max(r1, 0.1) - Rs2 / max(r2, 0.1);\n    \n    // Optional: Add centrifugal term for rotating frame\n    vec3 centerOfMass = (BH1_POS * Rs1 + BH2_POS * Rs2) / (Rs1 + Rs2);\n    float rCM = length(p.xz - centerOfMass.xz);\n    // phi -= 0.001 * rCM * rCM;  // Centrifugal term\n    \n    return phi;\n}\n\nvec3 diskColor(float temp, float angle, float dop, float blend) {\n    float t_noise = temp * 0.6 + 0.5 * noise(vec2((temp - iTime * 0.1) * 40.0, ls(angle - iTime) * 6.0));\n    float d_factor = -clamp(dop, -1.0, 1.0) * 0.15 + 1.1;\n    float t_adjusted = t_noise * 1.5 / (t_noise * d_factor + 0.5);\n    float t_factor = t_adjusted * 0.5 + 0.5;\n    float t_half = t_adjusted * 0.5 + 0.4;\n    float t_pow5 = exp(5.0 * log(max(t_adjusted, 0.001)));\n    float t_pow20 = exp(20.0 * log(max(t_adjusted, 0.001)));\n    \n    // Base warm color (orange/yellow)\n    vec3 warm = vec3(t_half, t_pow5 * 0.6, t_pow20 * 0.3) * t_factor;\n    warm = mix(warm, vec3(temp, 0.0, 0.0), clamp(1.0 - pow(temp, 0.3), 0.0, 1.0));\n    \n    // Cool color (blue/cyan) - swap R and B channels\n    vec3 cool = warm.zyx;\n    \n    return mix(warm, cool, blend) * 1.2;\n}\n\nvec3 bend(vec3 ro, vec3 rd, vec3 p, float rs) {\n    vec3 r = ro - p;\n    float r2 = dot(r, r);\n    float r1 = inversesqrt(r2);\n    vec3 L = cross(r, rd);\n    return -1.5 * rs * LENSING_STRENGTH * (r * dot(L, L)) * (r1 / (r2 * r2));\n}\n\nvoid advance(inout vec3 o, inout vec3 d, float h) {\n    vec3 acc = bend(o, d, BH1_POS, Rs1) + bend(o, d, BH2_POS, Rs2);\n    d = normalize(d + acc * h);\n    o += d * h;\n}\n\n// Disk opacity (0 = fully transparent, 1 = fully opaque)\nconst float DISK_OPACITY = 0.85;\n\n// Check if ray crosses the Roche potential disk\n// Returns opacity in col.a (using vec4)\nbool hit_roche_disk(vec3 oro, vec3 ro, vec3 rd, inout vec4 colAlpha) {\n    // Check if we crossed the disk plane (Y = 0)\n    float s1 = oro.y;\n    float s2 = ro.y;\n    if (s1 * s2 >= 0.0) return false;\n    \n    // Find intersection point\n    float t = s1 / (s1 - s2);\n    if (t < 0.0 || t > 1.0) return false;\n    \n    vec3 p = mix(oro, ro, t);\n    \n    // Distance to each black hole\n    float d1 = length(p - BH1_POS);\n    float d2 = length(p - BH2_POS);\n    \n    // Minimum distance from event horizons\n    float minDist1 = Rs1 * 3.0;\n    float minDist2 = Rs2 * 3.0;\n    if (d1 < minDist1 || d2 < minDist2) return false;\n    \n    // Calculate Roche potential at this point\n    float potential = rochePotential(p);\n    \n    // Check if within disk bounds\n    if (potential < POTENTIAL_INNER || potential > POTENTIAL_OUTER) return false;\n    \n    // Temperature based on potential (hotter = deeper in well)\n    float temp = (potential - POTENTIAL_OUTER) / (POTENTIAL_INNER - POTENTIAL_OUTER);\n    temp = pow(temp, 0.6);\n    \n    // Boost temperature near the L1 point (saddle point of potential)\n    vec3 L1 = mix(BH1_POS, BH2_POS, Rs1 / (Rs1 + Rs2));\n    float distToL1 = length(p.xz - L1.xz);\n    float pinchBoost = exp(-distToL1 * 0.08) * 0.4;\n    temp = min(temp + pinchBoost, 1.0);\n    \n    // Color blend: 0 = near BH1 (warm), 1 = near BH2 (cool)\n    float blend = d1 / (d1 + d2);\n    \n    // Angle for texture - use center of mass as reference\n    vec3 centerOfMass = (BH1_POS * Rs1 + BH2_POS * Rs2) / (Rs1 + Rs2);\n    vec2 relCM = p.xz - centerOfMass.xz;\n    float globalAngle = atan(relCM.y, relCM.x);\n    \n    // Add swirl based on potential gradient for organic flow\n    float potentialPhase = potential * 20.0;\n    float angle = globalAngle + potentialPhase;\n    \n    // Doppler shift - gas orbits around nearer black hole\n    vec3 toBH1 = normalize(vec3(p.x - BH1_POS.x, 0.0, p.z - BH1_POS.z));\n    vec3 toBH2 = normalize(vec3(p.x - BH2_POS.x, 0.0, p.z - BH2_POS.z));\n    vec3 toNearest = normalize(mix(toBH1, toBH2, blend));\n    vec3 tangent = normalize(vec3(-toNearest.z, 0.0, toNearest.x));\n    \n    // Add flow toward L1 point in the connecting stream\n    vec3 toL1 = normalize(vec3(L1.x - p.x, 0.0, L1.z - p.z));\n    float streamFactor = exp(-distToL1 * 0.05);\n    tangent = normalize(mix(tangent, toL1, streamFactor * 0.5));\n    \n    float dop = dot(tangent, rd);\n    vec3 diskCol = diskColor(temp, angle, dop, blend);\n    \n    // Opacity based on temperature (hotter = more opaque) and base opacity\n    float opacity = DISK_OPACITY * (0.5 + 0.5 * temp);\n    \n    colAlpha = vec4(diskCol, opacity);\n    return true;\n}\n\n// Escape distance - rays further than this from both black holes sample the skybox\nconst float ESCAPE_DIST = 200.0;\n\n// Camera distance from scene center (adjust to frame the black holes nicely)\nconst float CAM_DIST = 75.0;\n\nvec3 trace(vec3 ro, vec3 rd) {\n    // Accumulated disk color and opacity\n    vec3 accumulatedColor = vec3(0.0);\n    float accumulatedAlpha = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 to_bh1 = ro - BH1_POS;\n        vec3 to_bh2 = ro - BH2_POS;\n        float r1 = length(to_bh1);\n        float r2 = length(to_bh2);\n        \n        // Ray fell into a black hole - return accumulated disk over black\n        if (r1 < Rs1 || r2 < Rs2) {\n            return accumulatedColor;  // Black background, disk on top\n        }\n        \n        // Ray escaped far enough - blend disk over lensed skybox\n        if (r1 > ESCAPE_DIST && r2 > ESCAPE_DIST) {\n            vec3 skybox = texture(iChannel0, rd).rgb;\n            // Composite: disk over background\n            return accumulatedColor + (1.0 - accumulatedAlpha) * skybox;\n        }\n        \n        vec3 oro = ro;\n        float h = clamp(min(r1 * INV_SIX_RS1, r2 * INV_SIX_RS2), 1.0, 16.0);\n        advance(ro, rd, h);\n        \n        vec4 diskHit = vec4(0.0);\n        if (hit_roche_disk(oro, ro, rd, diskHit)) {\n            // Front-to-back alpha compositing\n            float alpha = diskHit.a * (1.0 - accumulatedAlpha);\n            accumulatedColor += diskHit.rgb * alpha;\n            accumulatedAlpha += alpha;\n            \n            // Early exit if nearly opaque\n            if (accumulatedAlpha > 0.99) {\n                return accumulatedColor;\n            }\n        }\n    }\n    \n    // Max steps reached - blend disk over skybox\n    vec3 skybox = texture(iChannel0, rd).rgb;\n    return accumulatedColor + (1.0 - accumulatedAlpha) * skybox;\n}\n\nvec3 render(vec2 fragCoord) {\n\n    float rotX = (iMouse.x / iResolution.x) * 2.0 * PI;\n    float rotY = (iMouse.y / iResolution.y) * PI;\n    if (iMouse.z <= 0.0) {\n        rotX = iTime * 0.2;\n        rotY = PI * 0.5;\n    }\n    vec2 uv = 2.5 * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xx;\n    vec3 camO = vec3(cos(rotX), cos(rotY)+0.3, sin(rotX));\n    vec3 camD = normalize(vec3(0.0) - camO);\n    vec3 camR = normalize(cross(camD, vec3(0.0, 1.0, 0.0)));\n    vec3 camU = cross(camR, camD);\n    vec3 rd = normalize(uv.x * camR + uv.y * camU + camD);\n    vec3 sceneCenter = vec3(2.5, 0.0, 0.0);\n    vec3 ro = sceneCenter + camO * CAM_DIST;\n    \n    return tanh(trace(ro, rd)*1.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0);\n    #ifdef AA\n    for (int x = 0; x < AA; x++) {\n        for (int y = 0; y < AA; y++) {\n            vec2 jitter = vec2(float(x), float(y)) / float(AA) - 0.5;\n            col += render(fragCoord + jitter);\n        }\n    }\n    col /= float(AA * AA);\n    #else\n    col = render(fragCoord);\n    #endif\n    fragColor = vec4(col, 1);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dX3Rr",
       "filepath": "/media/a//media/previz/cubemap00.png",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dX3Rr",
       "channel": 0
      }
     ],
     "code": "// Space Background for Shadertoy Cubemap A Buffer\n// Put this in \"Cubemap A\" buffer, then sample it in your main shader with:\n//   texture(iChannel0, rayDirection)\n//\n// This only renders on frame 0, then is cached by Shadertoy.\n// Based on space.glsl, uses 3D noise for seamless sphere mapping.\n\n// ============================================\n// 3D NOISE - seamless on sphere, no seams!\n// ============================================\n\nfloat hash3(vec3 p) {\n    p = fract(p * vec3(443.897, 441.423, 437.195));\n    p += dot(p, p.yzx + 19.19);\n    return fract((p.x + p.y) * p.z);\n}\n\n// 3D value noise - naturally seamless when sampling by direction\nfloat noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);  // Smoothstep\n    \n    return mix(\n        mix(mix(hash3(i + vec3(0,0,0)), hash3(i + vec3(1,0,0)), f.x),\n            mix(hash3(i + vec3(0,1,0)), hash3(i + vec3(1,1,0)), f.x), f.y),\n        mix(mix(hash3(i + vec3(0,0,1)), hash3(i + vec3(1,0,1)), f.x),\n            mix(hash3(i + vec3(0,1,1)), hash3(i + vec3(1,1,1)), f.x), f.y),\n        f.z\n    );\n}\n\n// 3D FBM - completely seamless\nfloat fbm3(vec3 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    for (int i = 0; i < 5; i++) {  // 5 octaves (was 6, slightly faster)\n        value += amplitude * noise3(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// ============================================\n// STARS - triplanar projection, fixed blending\n// ============================================\n\n// 2D hash for star grid\nfloat hash2(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat metaDiamond(vec2 p, vec2 pixel, float r) {\n    vec2 d = abs(p - pixel);\n    return r / (d.x + d.y + 0.001);\n}\n\n// Generate stars on one projection plane\nvec3 starsOnPlane(vec2 uv, vec2 cellOffset) {\n    vec3 col = vec3(0.0);\n    vec2 grid = floor(uv);\n    \n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 cell = grid + vec2(x, y) + cellOffset;\n            vec2 starPos = cell + vec2(hash2(cell), hash2(cell.yx)) - 0.5;\n            float starSize = hash2(cell * 1.5) * 0.008;\n            float brightness = metaDiamond(uv, starPos, starSize);\n            vec3 tint = vec3(1.0, 0.95, 0.9) + 0.1 * vec3(\n                hash2(cell * 2.0) - 0.5,\n                hash2(cell * 3.0) - 0.5,\n                hash2(cell * 4.0) - 0.5\n            );\n            col += tint * brightness;\n        }\n    }\n    return col;\n}\n\nvec3 generateStars(vec3 dir) {\n    dir = normalize(dir);\n    vec3 starColor = vec3(0.0);\n    \n    // Blend weights - use squared instead of pow 4 for gentler falloff\n    vec3 blend = abs(dir);\n    blend =sqrt( blend );  // Gentler than pow 4\n    blend /= (blend.x + blend.y + blend.z + 0.01);\n    \n\n    {\n        vec2 uv = dir.yz * sign(dir.x) * 16.0;\n        starColor += starsOnPlane(uv, vec2(0.0, 0.0)) * blend.x;\n    }\n    \n    {\n        vec2 uv = dir.xz * sign(dir.y) * 16.0;\n        starColor += starsOnPlane(uv, vec2(100.0, 0.0)) * blend.y;\n    }\n    \n    {\n        vec2 uv = dir.xy * sign(dir.z) * 16.0;\n        starColor += starsOnPlane(uv, vec2(0.0, 100.0)) * blend.z;\n    }\n    \n    return starColor*1.4;\n}\n\n\n\nvec3 generateNebula(vec3 dir) {\n    dir = normalize(dir);\n    \n    vec3 p = dir * 2.0;\n    \n    float q = fbm3(p * 3.5);\n    float r = fbm3(p + q + vec3(1.7, 9.2, 3.1));\n    float f = fbm3(p + r * 1.5);\n    \n    f = f*f*f;\n\n    vec3 nebulaColor = mix(vec3(0.05, 0.0, 0.1), vec3(0.5, 0.1, 0.4), f * 2.0);\n    nebulaColor = mix(nebulaColor, vec3(0.7, 0.2, 0.5), q * 0.8);\n    nebulaColor = mix(nebulaColor, vec3(0.9, 0.5, 0.2), r * 0.4);\n    nebulaColor = mix(nebulaColor, vec3(0.3, 0.1, 0.4), smoothstep(0.3, 0.7, f));\n\n    nebulaColor = nebulaColor * f * f + nebulaColor * f * 0.1;\n    \n    nebulaColor += vec3(0.02, 0.0, 0.03);\n    \n    return nebulaColor;\n}\n\nvec3 generateGalacticBand(vec3 dir) {\n    dir = normalize(dir);\n\n    float bandDist = abs(dir.y);\n    float band = smoothstep(0.4, 0.0, bandDist);\n\n    float variation = fbm3(dir * 3.0) * 0.5 + 0.5;\n    band *= variation;\n\n    vec3 bandColor = mix(vec3(0.4, 0.1, 0.3), vec3(0.6, 0.2, 0.4), variation);\n    \n    return bandColor * band * 0.4;\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    // BUFFERING: Only render on first frame, Shadertoy caches the result!\n    // After frame 0, this buffer is static and free to sample.\n    if (iFrame > 0) {\n        fragColor = textureLod(iChannel0, rayDir, 0.0);  // Return cached\n        return;\n    }\n    \n    // rayDir is provided by Shadertoy for cubemap buffers\n    vec3 dir = rayDir;\n    \n    // Generate space background for this direction\n    vec3 stars = generateStars(dir);\n    vec3 nebula = generateNebula(dir);\n    vec3 galactic = generateGalacticBand(dir);\n    \n    vec3 finalColor = nebula + galactic + stars;\n    \n    // Slight color grade - boost the pink/purple\n    finalColor *= vec3(1.0, 0.92, 1.15);\n    \n    fragColor = vec4(finalColor, 1.0);\n}\n\n",
     "name": "Cube A",
     "description": "",
     "type": "cubemap"
    }
   ]
  }
 ]
}