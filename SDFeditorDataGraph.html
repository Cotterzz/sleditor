<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="author" content="John Cotterell">
    <title>SDF Builder</title>
    <link href="https://fonts.googleapis.com/css?family=Abel|Quicksand:500|Source+Code+Pro" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        #rootnode {
            font-size: 20px;
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

.node {
            font-family: 'Quicksand', sans-serif;
            font-size: .9em;
            padding: 8px 12px;
            border: 2px solid #cccccc;
            border-radius: 5px;
            background: #eeeeee;
            position: absolute;
            z-index: 9;
            cursor: default;
            min-width: 80px;
            text-align: center;
        }

.node .detach-wrapper {
    position: absolute;
    top: -32px;
    left: 50%;
    transform: translateX(-50%);
    width: 120px;
    height: 40px;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.35);
    border: 1px dashed rgba(197, 48, 48, 0.6);
    opacity: 0;
    pointer-events: auto;
}

.detach-wrapper .detach-handle {
    position: absolute;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    width: 22px;
    height: 22px;
    border-radius: 50%;
    border: 2px solid rgba(0, 0, 0, 0.25);
    background: #fff;
    color: #c53030;
    font-size: 13px;
    line-height: 22px;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    opacity: 0;
    pointer-events: auto;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
}

.detach-wrapper .detach-handle::selection {
    background: transparent;
}

.node .detach-wrapper:hover,
.detach-wrapper.force-visible,
.detach-wrapper:focus-within {
    opacity: 1;
    pointer-events: auto;
}

        .node.scene {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #5a67d8;
            color: white;
        }

        .node.operation {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-color: #ed64a6;
            color: white;
        }

        .node.modifier {
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
            border-color: #f6ad55;
            color: #2d3748;
        }

        .node.primitive {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border-color: #38b2ac;
            color: white;
        }

        .node.selected {
            box-shadow: 0 0 0 3px #ffd700;
        }

        .node.invalid {
            opacity: 0.5;
        }

        .nodetitle {
            font-weight: 500;
            pointer-events: none;
        }

        #sidebar {
            font-family: 'Abel', sans-serif;
            font-size: 16px;
            position: fixed;
            left: 0;
            top: 0;
            width: 200px;
            height: 100%;
            background: #2d3748;
            color: white;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 100;
        }

        #sidebar h3 {
            margin: 15px 0 10px 0;
            font-size: 14px;
            text-transform: uppercase;
            color: #a0aec0;
            border-bottom: 1px solid #4a5568;
            padding-bottom: 5px;
        }

        .menu-item {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            cursor: grab;
        }

        .menu-item:hover {
            background: #4a5568;
        }

        .menu-item.primitive {
            border-left: 3px solid #4facfe;
        }

        .menu-item.operation {
            border-left: 3px solid #f5576c;
        }

        .menu-item.modifier {
            border-left: 3px solid #f6ad55;
        }

        #paramPanel {
            font-family: 'Abel', sans-serif;
            position: fixed;
            right: 0;
            top: 0;
            width: 280px;
            height: 100%;
            background: #2d3748;
            color: white;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        #paramPanel.visible {
            display: block;
        }

        #paramPanel h3 {
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #4a5568;
        }

        .param-group {
            margin-bottom: 15px;
        }

        .param-group label {
            display: block;
            font-size: 12px;
            color: #a0aec0;
            margin-bottom: 5px;
        }

        .param-group input[type="range"] {
            width: 100%;
            margin-bottom: 3px;
        }

        .param-group .value-display {
            font-size: 11px;
            color: #718096;
            text-align: right;
        }

        .param-section {
            margin-bottom: 20px;
        }

        .param-section-title {
            font-size: 13px;
            color: #ed64a6;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
#glCanvas {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

        #codeOutput {
            position: absolute;
            left: calc(220px + 20px);
            top: 20px;
            width: 360px;
            height: 240px;
            background: #1a202c;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
            display: none;
            z-index: 90;
            padding: 0;
            resize: both;
            overflow: auto;
        }

        #codeOutput pre {
            font-family: 'Source Code Pro', monospace;
            font-size: 11px;
            margin: 0;
            padding: 12px;
            color: #68d391;
            white-space: pre;
            min-width: 100%;
            min-height: 100%;
            box-sizing: border-box;
        }

        #sidebarControls {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #sidebarControls button {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-family: 'Abel', sans-serif;
            font-size: 14px;
            cursor: pointer;

        }

        #sidebarControls #toggleCode {
            background: #4a5568;
            color: #fff;
        }

        #sidebarControls #toggleCode:hover {
            background: #5a67d8;
        }

        #sidebarControls #exportShader {
            background: #68d391;
            color: #1a202c;
        }

        #sidebarControls #exportShader:hover {
            background: #9ae6b4;
        }

        #recycleBin {
            position: absolute;
            left: calc(220px + 20px);
            bottom: 20px;
            width: 160px;
            height: 90px;
            border: 2px dashed rgba(255, 99, 71, 0.6);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: rgba(63, 34, 34, 0.85);
            background: rgba(255, 99, 71, 0.08);
            font-family: 'Abel', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 36px;
            transition: background 0.2s, transform 0.2s, border-color 0.2s;
            z-index: 80;
        }

        #recycleBin.active {
            background: rgba(255, 99, 71, 0.25);
            border-color: rgba(255, 255, 255, 0.9);
            transform: scale(1.05);
        }

        svg {
            position: absolute;
            pointer-events: none;
        }

        #drawing {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 5;
        }
        #statusBar {
            position: fixed;
            bottom: 0;
            left: 200px;
            right: 280px;
            height: 28px;
            display: flex;
            align-items: center;
            padding: 0 12px;
            background: rgba(0, 0, 0, 0.45);
            color: #f5f5f5;
            font-family: 'Abel', sans-serif;
            font-size: 13px;
            z-index: 150;
            pointer-events: auto;
        }

        #pixelScaleControl {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-right: 12px;
            pointer-events: auto;
        }

        #pixelScaleSlider {
            width: 120px;
        }

        .status-meter {
            pointer-events: none;
            margin-left: 16px;
        }
    </style>
</head>
<body>

<div id="sidebar">
    <h3>Primitives</h3>
    <div class="menu-item primitive" data-type="Sphere">Sphere</div>
    <div class="menu-item primitive" data-type="Box">Box</div>
    <div class="menu-item primitive" data-type="Torus">Torus</div>
    <div class="menu-item primitive" data-type="Cylinder">Cylinder</div>
    <div class="menu-item primitive" data-type="Octahedron">Octahedron</div>
    <div class="menu-item primitive" data-type="Cone">Cone</div>
    <div class="menu-item primitive" data-type="RoundCone">Round Cone</div>
    <div class="menu-item primitive" data-type="VerticalCapsule">Vertical Capsule</div>
    <div class="menu-item primitive" data-type="CutHollowSphere">Cut Hollow Sphere</div>
    <div class="menu-item primitive" data-type="DeathStar">Death Star</div>
    <div class="menu-item primitive" data-type="VesicaSegment">Vesica Segment</div>
    
    <h3>Operations</h3>
    <div class="menu-item operation" data-type="opUnion">Union</div>
    <div class="menu-item operation" data-type="opSmoothUnion">Smooth Union</div>
    <div class="menu-item operation" data-type="opSubtraction">Subtraction</div>
    <div class="menu-item operation" data-type="opSmoothSubtraction">Smooth Subtract</div>
    <div class="menu-item operation" data-type="opIntersection">Intersection</div>
    <div class="menu-item operation" data-type="opSmoothIntersection">Smooth Intersect</div>
    <div class="menu-item operation" data-type="opXor">XOR</div>

    <h3>Modifiers</h3>
    <div class="menu-item modifier" data-type="opRound">Round (Bevel)</div>
    <div class="menu-item modifier" data-type="opOnion">Onion (Shell)</div>
    <div class="menu-item modifier" data-type="opTwist">Twist</div>
    <div class="menu-item modifier" data-type="opElongate">Elongate</div>
    <div class="menu-item modifier" data-type="opCheapBend">Cheap Bend</div>
    <div class="menu-item modifier" data-type="opSymX">Mirror X</div>
</div>

<div id="paramPanel">
    <h3 id="paramNodeName">Parameters</h3>
    <div id="paramContent"></div>
</div>

<div id="drawing"></div>
<div id="rootnode">
    <div class="node scene" id="scene" data-type="Scene" style="left: 50%; top: 5%;">
        <div class="nodetitle">Scene</div>
    </div>
</div>

<canvas id="glCanvas"></canvas>
<div id="recycleBin">
    <div>♻</div>
    <small>Recycle</small>
</div>
<div id="statusBar">
    <div id="pixelScaleControl">
        <label for="pixelScaleSlider">Pixel size:</label>
        <input type="range" id="pixelScaleSlider" min="0" max="4" step="1" value="0">
        <span id="pixelScaleLabel">1x</span>
    </div>
    <span class="status-meter" id="uboMemoryDisplay">UBO Memory: calculating…</span>
    <span class="status-meter" id="uniformArrayMemoryDisplay"> Uniform Memory: calculating…</span>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/2.7.1/svg.min.js"></script>
<script>
// Node type definitions
const NODE_TYPES = {
    Scene: {
        category: 'scene',
        maxChildren: 99,
        params: {}
    },
    Sphere: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            radius: { default: 0.5, min: 0.05, max: 3, step: 0.05 }
        }
    },
    Box: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            sizeX: { default: 0.5, min: 0.05, max: 3, step: 0.05 },
            sizeY: { default: 0.5, min: 0.05, max: 3, step: 0.05 },
            sizeZ: { default: 0.5, min: 0.05, max: 3, step: 0.05 }
        }
    },
    Torus: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            majorRadius: { default: 0.5, min: 0.1, max: 2, step: 0.05 },
            minorRadius: { default: 0.2, min: 0.05, max: 1, step: 0.05 }
        }
    },
    Cylinder: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            radius: { default: 0.3, min: 0.05, max: 2, step: 0.05 },
            height: { default: 1.0, min: 0.1, max: 5, step: 0.1 }
        }
    },
    Octahedron: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            size: { default: 0.75, min: 0.1, max: 3.0, step: 0.05 }
        }
    },
    Cone: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            height: { default: 1.5, min: 0.1, max: 5.0, step: 0.05 },
            angleDeg: { default: 45, min: 1, max: 89, step: 1 }
        }
    },
    RoundCone: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            radiusTop: { default: 0.4, min: 0.01, max: 3.0, step: 0.01 },
            radiusBottom: { default: 0.1, min: 0.01, max: 3.0, step: 0.01 },
            height: { default: 1.25, min: 0.1, max: 5.0, step: 0.05 }
        }
    },
    VerticalCapsule: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            height: { default: 1.0, min: 0.1, max: 5.0, step: 0.05 },
            radius: { default: 0.25, min: 0.01, max: 2.5, step: 0.01 }
        }
    },
    CutHollowSphere: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            radius: { default: 1.0, min: 0.1, max: 4.0, step: 0.05 },
            height: { default: 0.35, min: 0.0, max: 3.5, step: 0.05 },
            thickness: { default: 0.1, min: 0.001, max: 2.0, step: 0.01 }
        }
    },
    DeathStar: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            radiusA: { default: 1.0, min: 0.1, max: 5.0, step: 0.05 },
            radiusB: { default: 0.4, min: 0.05, max: 4.0, step: 0.05 },
            offset: { default: 0.6, min: 0.0, max: 5.0, step: 0.05 }
        }
    },
    VesicaSegment: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            ax: { default: -0.5, min: -3, max: 3, step: 0.1 },
            ay: { default: 0.0, min: -3, max: 3, step: 0.1 },
            az: { default: 0.0, min: -3, max: 3, step: 0.1 },
            bx: { default: 0.5, min: -3, max: 3, step: 0.1 },
            by: { default: 0.0, min: -3, max: 3, step: 0.1 },
            bz: { default: 0.0, min: -3, max: 3, step: 0.1 },
            width: { default: 0.25, min: 0.01, max: 3.0, step: 0.01 }
        }
    },
    opUnion: {
        category: 'operation',
        maxChildren: 2,
        params: {}
    },
    opSmoothUnion: {
        category: 'operation',
        maxChildren: 2,
        params: {
            k: { default: 0.3, min: 0.01, max: 1, step: 0.01 }
        }
    },
    opSubtraction: {
        category: 'operation',
        maxChildren: 2,
        params: {}
    },
    opSmoothSubtraction: {
        category: 'operation',
        maxChildren: 2,
        params: {
            k: { default: 0.3, min: 0.01, max: 1, step: 0.01 }
        }
    },
    opIntersection: {
        category: 'operation',
        maxChildren: 2,
        params: {}
    },
    opSmoothIntersection: {
        category: 'operation',
        maxChildren: 2,
        params: {
            k: { default: 0.3, min: 0.01, max: 1, step: 0.01 }
        }
    },
    opXor: {
        category: 'operation',
        maxChildren: 2,
        params: {}
    },
    opRound: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            roundRadius: { default: 0.1, min: 0.0, max: 1.0, step: 0.01 }
        }
    },
    opOnion: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            shellThickness: { default: 0.05, min: 0.0, max: 1.0, step: 0.01 }
        }
    },
    opTwist: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            twistAmount: { default: 2.0, min: -20.0, max: 20.0, step: 0.1 }
        }
    },
    opElongate: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            extentX: { default: 0.3, min: 0.0, max: 2.0, step: 0.05 },
            extentY: { default: 0.3, min: 0.0, max: 2.0, step: 0.05 },
            extentZ: { default: 0.3, min: 0.0, max: 2.0, step: 0.05 }
        }
    },
    opCheapBend: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            bendAmount: { default: 2.0, min: -20.0, max: 20.0, step: 0.1 }
        }
    },
    opSymX: {
        category: 'modifier',
        maxChildren: 1,
        params: {}
    }
};

const TRANSFORM_PARAMS = {
    posX: { default: 0, min: -5, max: 5, step: 0.1 },
    posY: { default: 0, min: -5, max: 5, step: 0.1 },
    posZ: { default: 0, min: -5, max: 5, step: 0.1 },
    rotX: { default: 0, min: -180, max: 180, step: 1 },
    rotY: { default: 0, min: -180, max: 180, step: 1 },
    rotZ: { default: 0, min: -180, max: 180, step: 1 },
    scale: { default: 1.0, min: 0.1, max: 5.0, step: 0.05 }
};

function getNodeParams(node) {
    if (node._sdfParams) return node._sdfParams;
    const parsed = node.dataset.params ? JSON.parse(node.dataset.params) : {};
    node._sdfParams = parsed;
    return parsed;
}

function setNodeParams(node, params) {
    node._sdfParams = params;
    node.dataset.params = JSON.stringify(params);
}

function ensureDetachHandle(node) {
    if (node.dataset.type === 'Scene') return;
    if (!node.querySelector('.detach-wrapper')) {
        const wrapper = document.createElement('div');
        wrapper.className = 'detach-wrapper';
        const handle = document.createElement('div');
        handle.className = 'detach-handle';
        handle.textContent = '×';
        wrapper.appendChild(handle);
        node.appendChild(wrapper);
    }
    attachNodeHoverHandlers(node);
    attachDetachWrapperHandlers(node);
}

// State
let dragging = false;
let dragged = null;
let detached = false;
let dragFromMenu = false;
let pos1, pos2, pos3, pos4;
let selectedNode = null;
let nodeCounter = 0;

let dropPreview = null;
let currentDropTarget = null;

const draw = SVG('drawing').size('100%', '100%');
let nodesArray = [];
let lines = [];
const recycleBin = document.getElementById('recycleBin');
const recycleRect = () => recycleBin.getBoundingClientRect();
let recycleActive = false;
const codeOutput = document.getElementById('codeOutput');
const codeOutputContent = document.getElementById('codeOutputContent');
const uboMemoryDisplay = document.getElementById('uboMemoryDisplay');
const uniformArrayMemoryDisplay = document.getElementById('uniformArrayMemoryDisplay');
const pixelScaleSlider = document.getElementById('pixelScaleSlider');
const pixelScaleLabel = document.getElementById('pixelScaleLabel');

const MAX_DATA_NODES = 64;
const MAX_PARAM_SLOTS = 64;
const NODE_TYPE_SPHERE = 0;
const NODE_TYPE_BOX = 1;
const NODE_TYPE_TORUS = 2;
const NODE_TYPE_CYLINDER = 3;
const NODE_TYPE_OCTAHEDRON = 4;
const NODE_TYPE_CONE = 5;
const NODE_TYPE_ROUND_CONE = 6;
const NODE_TYPE_VERTICAL_CAPSULE = 7;
const NODE_TYPE_CUT_HOLLOW_SPHERE = 8;
const NODE_TYPE_DEATH_STAR = 9;
const NODE_TYPE_VESICA = 10;
const NODE_TYPE_UNION = 11;
const NODE_TYPE_SMOOTH_UNION = 12;
const NODE_TYPE_SUBTRACTION = 13;
const NODE_TYPE_SMOOTH_SUBTRACTION = 14;
const NODE_TYPE_INTERSECTION = 15;
const NODE_TYPE_SMOOTH_INTERSECTION = 16;
const NODE_TYPE_XOR = 17;
const NODE_BUFFER_BINDING = 0;
const STAGE_SLOT_INDEX = 0;

const NODE_TYPE_ID_MAP = {
    Sphere: NODE_TYPE_SPHERE,
    Box: NODE_TYPE_BOX,
    Torus: NODE_TYPE_TORUS,
    Cylinder: NODE_TYPE_CYLINDER,
    Octahedron: NODE_TYPE_OCTAHEDRON,
    Cone: NODE_TYPE_CONE,
    RoundCone: NODE_TYPE_ROUND_CONE,
    VerticalCapsule: NODE_TYPE_VERTICAL_CAPSULE,
    CutHollowSphere: NODE_TYPE_CUT_HOLLOW_SPHERE,
    DeathStar: NODE_TYPE_DEATH_STAR,
    VesicaSegment: NODE_TYPE_VESICA,
    opUnion: NODE_TYPE_UNION,
    opSmoothUnion: NODE_TYPE_SMOOTH_UNION,
    opSubtraction: NODE_TYPE_SUBTRACTION,
    opSmoothSubtraction: NODE_TYPE_SMOOTH_SUBTRACTION,
    opIntersection: NODE_TYPE_INTERSECTION,
    opSmoothIntersection: NODE_TYPE_SMOOTH_INTERSECTION,
    opXor: NODE_TYPE_XOR
};

window.SDF_DATA_DEBUG = false;
function dgLog(...args) {
    if (!window.SDF_DATA_DEBUG) return;
    console.log('[SDF-DATA]', ...args);
}

const uniformArrays = {
    pos: new Float32Array(MAX_PARAM_SLOTS * 4),
    rotScale: new Float32Array(MAX_PARAM_SLOTS * 4),
    params: new Float32Array(MAX_PARAM_SLOTS * 4)
};
uniformArrays.rotScale[3] = 1.0;
uniformArrays.params[0] = 1.0;

let uniformLocations = { pos: null, rotScale: null, params: null };
let uniformsDirty = true;
let framePending = false;
let nextSlotIndex = 1;
const freeSlotStack = [];
const pendingSliderUpdates = new Map();
let sliderInputHandle = null;
let sliderFlushHandle = null;
let activeSlotCount = 0;

let previewScaleIndex = 0;
const PREVIEW_PIXEL_SCALES = [1, 2, 4, 8, 16];

let uboBudget = { totalKB: 0, usedKB: 0 };
const RESERVED_UNIFORM_VECS = 12;
let uniformArrayBudget = { totalVecs: 0, usedVecs: 0 };
let dataShaderSource = null;
let nodeBuffer = null;
let nodeBufferData = null;
let dataGraphDirty = true;
let resolutionUniform = null;
let nodeBufferBindingPoint = NODE_BUFFER_BINDING;

// Camera state for preview orbit controls
const CAMERA_STATE = {
    yaw: 0,
    pitch: 0,
    distance: 4,
    target: { x: 0, y: 0, z: 0 }
};
let cameraUniformLocations = { pos: null, target: null };
let cameraDragMode = null;
let cameraLastX = 0;
let cameraLastY = 0;

function logDataLimits(gl) {
    const uniformVec4s = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    let blockSize = 0;
    let blockCount = 0;
    if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
        blockSize = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE);
        blockCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_BLOCKS);
    }
    const totalUBOBytes = blockSize && blockCount ? blockSize * blockCount : 0;
    console.log('Uniform vec4s:', uniformVec4s);
    if (totalUBOBytes > 0) {
        console.log(`UBO max: ${blockCount} × ${(blockSize / 1024).toFixed(1)}KB = ${(totalUBOBytes / 1024).toFixed(1)}KB`);
    }
    return {
        uniformVec4s,
        blockSize,
        blockCount,
        totalBytes: totalUBOBytes
    };
}

function updateUBOMemoryUsage(bytesUsed) {
    uboBudget.usedKB = Math.max(0, bytesUsed) / 1024;
    if (!uboMemoryDisplay) return;
    if (uboBudget.totalKB <= 0) {
        uboMemoryDisplay.textContent = 'UBO Memory: not available';
        return;
    }
    const totalKB = uboBudget.totalKB;
    const percent = Math.min(100, (uboBudget.usedKB / totalKB) * 100).toFixed(1);
    uboMemoryDisplay.textContent = `UBO Memory: ${percent}% (${uboBudget.usedKB.toFixed(1)} / ${totalKB.toFixed(1)} KB) -`;
}

function initUniformArrayBudget(uniformVec4s) {
    const availableVecs = Math.max(0, (uniformVec4s || 0) - RESERVED_UNIFORM_VECS);
    uniformArrayBudget.totalVecs = availableVecs;
    updateUniformArrayUsage();
}

function getActiveSlotCount() {
    return activeSlotCount;
}

function updateUniformArrayUsage() {
    if (!uniformArrayMemoryDisplay) return;
    if (uniformArrayBudget.totalVecs <= 0) {
        uniformArrayMemoryDisplay.textContent = ' Uniform Memory: not available';
        return;
    }
    const slotCount = getActiveSlotCount();
    const usedVecs = Math.min(uniformArrayBudget.totalVecs, (slotCount + 1) * 3);
    uniformArrayBudget.usedVecs = usedVecs;
    const totalBytes = uniformArrayBudget.totalVecs * 16;
    const usedBytes = usedVecs * 16;
    const percent = Math.min(100, (usedVecs / uniformArrayBudget.totalVecs) * 100).toFixed(1);
    uniformArrayMemoryDisplay.textContent = `- Uniform Memory: ${percent}% (${(usedBytes / 1024).toFixed(1)} / ${(totalBytes / 1024).toFixed(1)} KB)`;
}

function markDataGraphDirty() {
    dataGraphDirty = true;
    dgLog('markDataGraphDirty');
    requestPreviewRender();
}

function markUniformsDirty() {
    uniformsDirty = true;
    dgLog('markUniformsDirty');
    requestPreviewRender();
}

function getPreviewScale() {
    return PREVIEW_PIXEL_SCALES[previewScaleIndex] || 1;
}

function updatePixelScaleLabel() {
    if (!pixelScaleLabel) return;
    pixelScaleLabel.textContent = `${getPreviewScale()}x`;
}

function applyPreviewScale() {
    const canvas = document.getElementById('glCanvas');
    if (!canvas) return;
    const scale = getPreviewScale();
    const width = Math.max(32, Math.floor(window.innerWidth / scale));
    const height = Math.max(32, Math.floor(window.innerHeight / scale));
    canvas.width = width;
    canvas.height = height;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    if (gl) {
        gl.viewport(0, 0, canvas.width, canvas.height);
        if (program && resolutionUniform !== null) {
            gl.useProgram(program);
            gl.uniform2f(resolutionUniform, canvas.width, canvas.height);
        }
        requestPreviewRender();
    }
}

function handlePixelScaleInput(event) {
    const rawValue = parseInt(event.target.value, 10);
    const clamped = Math.max(0, Math.min(PREVIEW_PIXEL_SCALES.length - 1, isNaN(rawValue) ? 0 : rawValue));
    if (clamped === previewScaleIndex) return;
    previewScaleIndex = clamped;
    updatePixelScaleLabel();
    applyPreviewScale();
}

function requestPreviewRender() {
    if (framePending) return;
    framePending = true;
    dgLog('requestPreviewRender scheduled');
    requestAnimationFrame(() => {
        framePending = false;
        drawPreviewFrame();
    });
}

function drawPreviewFrame() {
    if (!gl || !program) return;
    dgLog('drawPreviewFrame start', { uniformsDirty, dataGraphDirty });
    refreshDataGraph();
    uploadUniforms();
    updateCameraUniforms();
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    dgLog('drawPreviewFrame end');
}

function degToRad(value) {
    return value * Math.PI / 180;
}

function nodeRequiresSlot(node) {
    if (!node || node.dataset.type === 'Scene') return false;
    const typeDef = NODE_TYPES[node.dataset.type];
    if (!typeDef) return false;
    if (typeDef.category === 'primitive') return true;
    if (typeDef.category === 'operation') {
        return !!(typeDef.params && Object.keys(typeDef.params).length);
    }
    return false;
}

function allocateSlotIndex() {
    if (freeSlotStack.length > 0) {
        return freeSlotStack.pop();
    }
    const slot = nextSlotIndex++;
    if (slot >= MAX_PARAM_SLOTS) {
        console.warn('Reached MAX_PARAM_SLOTS limit');
        return STAGE_SLOT_INDEX;
    }
    return slot;
}

function ensureNodeSlot(node) {
    if (!nodeRequiresSlot(node)) {
        return STAGE_SLOT_INDEX;
    }
    if (node.dataset.slotIndex !== undefined) {
        return parseInt(node.dataset.slotIndex, 10);
    }
    const slot = allocateSlotIndex();
    node.dataset.slotIndex = String(slot);
    if (slot > STAGE_SLOT_INDEX) {
        activeSlotCount++;
        updateUniformArrayUsage();
    }
    return slot;
}

function releaseNodeSlot(node) {
    if (!nodeRequiresSlot(node)) return;
    const slot = parseInt(node.dataset.slotIndex ?? '-1', 10);
    if (!Number.isNaN(slot) && slot > STAGE_SLOT_INDEX) {
        const base = slot * 4;
        uniformArrays.pos.fill(0, base, base + 4);
        uniformArrays.rotScale.fill(0, base, base + 4);
        uniformArrays.params.fill(0, base, base + 4);
        freeSlotStack.push(slot);
        activeSlotCount = Math.max(0, activeSlotCount - 1);
        updateUniformArrayUsage();
    }
    delete node.dataset.slotIndex;
    markUniformsDirty();
}

function updateNodeUniformData(node) {
    if (!nodeRequiresSlot(node)) return;
    const slot = ensureNodeSlot(node);
    if (slot >= MAX_PARAM_SLOTS) return;
    const params = getNodeParams(node) || {};
    const base = slot * 4;
    const posArray = uniformArrays.pos;
    posArray[base + 0] = params.posX ?? 0;
    posArray[base + 1] = params.posY ?? 0;
    posArray[base + 2] = params.posZ ?? 0;
    posArray[base + 3] = 1.0;

    const rotScaleArray = uniformArrays.rotScale;
    rotScaleArray[base + 0] = degToRad(params.rotX ?? 0);
    rotScaleArray[base + 1] = degToRad(params.rotY ?? 0);
    rotScaleArray[base + 2] = degToRad(params.rotZ ?? 0);
    rotScaleArray[base + 3] = Math.max(params.scale ?? 1, 0.0001);

    writeNodeParams(node.dataset.type, params, uniformArrays.params, base);

    markUniformsDirty();
    dgLog('updateNodeUniformData', {
        nodeId: node.id,
        type: node.dataset.type,
        slot,
        params: { ...params }
    });
}

function writeNodeParams(nodeType, params, array, base) {
    array[base + 0] = 0.0;
    array[base + 1] = 0.0;
    array[base + 2] = 0.0;
    array[base + 3] = 0.0;
    switch (nodeType) {
        case 'Sphere': {
            const radius = params.radius ?? 0.5;
            array[base + 0] = radius;
            break;
        }
        case 'Box': {
            array[base + 0] = params.sizeX ?? 0.5;
            array[base + 1] = params.sizeY ?? 0.5;
            array[base + 2] = params.sizeZ ?? 0.5;
            break;
        }
        case 'Torus': {
            array[base + 0] = params.majorRadius ?? 0.5;
            array[base + 1] = params.minorRadius ?? 0.2;
            break;
        }
        case 'Cylinder': {
            array[base + 0] = params.radius ?? 0.3;
            array[base + 1] = params.height ?? 1.0;
            break;
        }
        case 'Octahedron': {
            array[base + 0] = params.size ?? 0.75;
            break;
        }
        case 'Cone': {
            const angleRad = degToRad(params.angleDeg ?? 45);
            array[base + 0] = Math.sin(angleRad);
            array[base + 1] = Math.cos(angleRad);
            array[base + 2] = params.height ?? 1.5;
            break;
        }
        case 'RoundCone': {
            array[base + 0] = params.radiusTop ?? 0.4;
            array[base + 1] = params.radiusBottom ?? 0.1;
            array[base + 2] = params.height ?? 1.25;
            break;
        }
        case 'VerticalCapsule': {
            array[base + 0] = params.height ?? 1.0;
            array[base + 1] = params.radius ?? 0.25;
            break;
        }
        case 'CutHollowSphere': {
            array[base + 0] = params.radius ?? 1.0;
            array[base + 1] = params.height ?? 0.35;
            array[base + 2] = params.thickness ?? 0.1;
            break;
        }
        case 'DeathStar': {
            array[base + 0] = params.radiusA ?? 1.0;
            array[base + 1] = params.radiusB ?? 0.4;
            array[base + 2] = params.offset ?? 0.6;
            break;
        }
        case 'VesicaSegment': {
            const lengthVal = params.length ?? Math.max(0.01, Math.abs((params.ax ?? -0.5) - (params.bx ?? 0.5)));
            const widthVal = params.width ?? 0.25;
            array[base + 0] = lengthVal;
            array[base + 1] = widthVal;
            break;
        }
        case 'opSmoothUnion':
        case 'opSmoothSubtraction':
        case 'opSmoothIntersection': {
            array[base + 0] = params.k ?? 0.3;
            break;
        }
        default: {
            array[base + 0] = params.radius ?? 0.0;
            break;
        }
    }
}

// Simple performance logger (toggle via window.SDF_PERF.enabled)
const SDF_PERF = {
    enabled: false
};

function perfNow() {
    return performance.now();
}

function perfLogDuration(label, startTime, extra = '') {
    return startTime;
}

function perfLogInfo(label, info) {
}

window.SDF_PERF = SDF_PERF;

// WebGL state
let gl, program;
let vertexBuffer = null;

// Initialize
function init() {
    scanNodes();
    addLines();
    initializeNodeParams();
    setupEventListeners();
    initWebGL();
    recompilePreview();
}

function scanNodes() {
    const nodesObject = document.getElementsByClassName("node");
    nodesArray = [];
    for (let i = 0; i < nodesObject.length; i++) {
        nodesArray.push(nodesObject[i]);
        if (!nodesObject[i].id || nodesObject[i].id === '') {
            nodesObject[i].id = 'node_' + nodeCounter++;
        }
        ensureDetachHandle(nodesObject[i]);
    }
}

function initializeNodeParams() {
    nodesArray.forEach(node => {
        if (!node.dataset.params) {
            const nodeType = node.dataset.type;
            const typeDef = NODE_TYPES[nodeType];
            const params = {};
            
            if (typeDef && typeDef.params) {
                for (const [key, val] of Object.entries(typeDef.params)) {
                    params[key] = val.default;
                }
            }
            
            if (nodeType !== 'Scene') {
                for (const [key, val] of Object.entries(TRANSFORM_PARAMS)) {
                    params[key] = val.default;
                }
            }
            
            setNodeParams(node, params);
        } else {
            node._sdfParams = JSON.parse(node.dataset.params);
        }
    });
    nodesArray.forEach(node => {
        if (!nodeRequiresSlot(node)) return;
        ensureNodeSlot(node);
        updateNodeUniformData(node);
    });
}

function addLines() {
    for (let i = 0; i < nodesArray.length; i++) {
        addLine(i);
    }
}

function addLine(num) {
    const node = nodesArray[num];
    const box1 = node.getBoundingClientRect();
    const box2 = node.parentNode.getBoundingClientRect();
    const x1 = box1.left + (box1.width / 2);
    const y1 = box1.top + (box1.height / 2);
    const x2 = box2.left + (box2.width / 2);
    const y2 = box2.top + (box2.height / 2);
    
    if (lines[num]) {
        lines[num].plot([['M', x1, y1], ['C', x1, y2, x2, y1, x2, y2]]);
    } else {
        lines[num] = draw.path([['M', x1, y1], ['C', x1, y2, x2, y1, x2, y2]])
            .fill('none')
            .stroke({ width: 2, color: "#888888" });
    }
    
    if (!node.parentNode.classList.contains("node")) {
        lines[num].hide();
    } else {
        lines[num].show();
    }
}
function generateShadertoyShader() {
    const sdfCode = generateExportGLSL();
    
    return `// Generated with SDF Builder
// Paste into Shadertoy

${sdfCode}

vec3 calcNormal(vec3 p) {
    vec2 e = vec2(0.001, 0.0);
    return normalize(vec3(
        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),
        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),
        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)
    ));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    
    vec3 ro = vec3(0.0, 0.0, 3.0);
    vec3 rd = normalize(vec3(uv, -1.0));
    
    float t = 0.0;
    vec3 col = vec3(1.0);
    
    for (int i = 0; i < 100; i++) {
        vec3 p = ro + rd * t;
        float d = sceneSDF(p);
        
        if (d < 0.001) {
            vec3 n = calcNormal(p);
            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
            float diff = max(dot(n, lightDir), 0.0);
            float amb = 0.3;
            col = vec3(0.85, 0.75, 0.7) * (diff + amb);
            break;
        }
        
        if (t > 20.0) break;
        t += d;
    }
    
    fragColor = vec4(col, 1.0);
}
`;
}

function downloadShadertoyShader() {
    const shaderCode = generateShadertoyShader();
    const blob = new Blob([shaderCode], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'sdf_shader.glsl';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
function updateLine(node) {
    const nodeIndex = nodesArray.indexOf(node);
    if (nodeIndex >= 0) {
        addLine(nodeIndex);
    }
    
    const children = node.querySelectorAll('.node');
    children.forEach(child => {
        const childIndex = nodesArray.indexOf(child);
        if (childIndex >= 0) {
            addLine(childIndex);
        }
    });
}

function setupEventListeners() {
    document.addEventListener('mousedown', onDocumentMouseDown, false);
    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('mouseup', onDocumentMouseUp, false);
    document.addEventListener('contextmenu', e => e.preventDefault(), false);
    
    window.addEventListener('resize', () => {
        updateLine(document.getElementById("rootnode"));
        applyPreviewScale();
    }, false);
    
    document.querySelectorAll('.menu-item').forEach(item => {
        item.addEventListener('mousedown', onMenuItemMouseDown, false);
    });

    if (pixelScaleSlider) {
        pixelScaleSlider.addEventListener('input', handlePixelScaleInput, false);
    }
    
    

    document.addEventListener('mousedown', onDetachHandleMouseDown);
    document.addEventListener('wheel', handleCameraWheel, { passive: false });
}

function onMenuItemMouseDown(event) {
    event.preventDefault();
    const nodeType = event.target.dataset.type;
    
    const newNode = createNode(nodeType);
    document.getElementById("rootnode").appendChild(newNode);
    nodesArray.push(newNode);
    
    newNode.style.left = event.clientX - 50 + "px";
    newNode.style.top = event.clientY - 15 + "px";
    
    addLine(nodesArray.length - 1);
    
    pos3 = event.clientX;
    pos4 = event.clientY;
    newNode.dataset.dragOffsetX = 50;
    newNode.dataset.dragOffsetY = 15;
    dragging = true;
    dragged = newNode;
    detached = true;
    dragFromMenu = true;
}

function createNode(nodeType) {
    const typeDef = NODE_TYPES[nodeType];
    const newNode = document.createElement("DIV");
    const newText = document.createElement("DIV");
    const detachWrapper = document.createElement('div');
    const detachHandle = document.createElement('div');
    
    newText.className = "nodetitle";
    newText.textContent = nodeType;
    
    newNode.className = "node " + typeDef.category;
    newNode.id = 'node_' + nodeCounter++;
    newNode.dataset.type = nodeType;
    
    const params = {};
    if (typeDef.params) {
        for (const [key, val] of Object.entries(typeDef.params)) {
            params[key] = val.default;
        }
    }
    for (const [key, val] of Object.entries(TRANSFORM_PARAMS)) {
        params[key] = val.default;
    }
    setNodeParams(newNode, params);
    if (nodeRequiresSlot(newNode)) {
        ensureNodeSlot(newNode);
        updateNodeUniformData(newNode);
    }
    
    if (nodeType !== 'Scene') {
        detachWrapper.className = 'detach-wrapper';
        detachHandle.className = 'detach-handle';
        detachHandle.textContent = '×';
        detachWrapper.appendChild(detachHandle);
        newNode.appendChild(detachWrapper);
    }
    attachNodeHoverHandlers(newNode);
    attachDetachWrapperHandlers(newNode);
    newNode.appendChild(newText);
    return newNode;
}

function attachNodeHoverHandlers(node) {
    if (node.dataset.type === 'Scene' || node._hoverHandlersAttached) return;
    node.addEventListener('mouseover', handleNodeMouseOver);
    node.addEventListener('mouseout', handleNodeMouseOut);
    node._hoverHandlersAttached = true;
}

function attachDetachWrapperHandlers(node) {
    if (node.dataset.type === 'Scene') return;
    const wrapper = node.querySelector('.detach-wrapper');
    if (!wrapper || wrapper._hoverHandlersAttached) return;
    wrapper.addEventListener('mouseenter', () => {
        node.classList.add('node-hover');
    });
    wrapper.addEventListener('mouseleave', (event) => {
        const related = event.relatedTarget;
        if (related && (node.contains(related) || wrapper.contains(related))) return;
        node.classList.remove('node-hover');
    });
    wrapper._hoverHandlersAttached = true;
}

function handleNodeMouseOver(event) {
    if (event.target !== event.currentTarget) return;
    event.currentTarget.classList.add('node-hover');
    const wrapper = event.currentTarget.querySelector('.detach-wrapper');
    if (wrapper) {
        wrapper.setAttribute('aria-label', 'Click to detach and drag this node');
    }
}

function handleNodeMouseOut(event) {
    if (event.target !== event.currentTarget) return;
    const related = event.relatedTarget;
    if (related && event.currentTarget.contains(related)) return;
    event.currentTarget.classList.remove('node-hover');
    const wrapper = event.currentTarget.querySelector('.detach-wrapper');
    if (wrapper) {
        wrapper.removeAttribute('aria-label');
    }
}

function getCameraPosition() {
    const dist = Math.max(0.5, CAMERA_STATE.distance);
    const cosPitch = Math.cos(CAMERA_STATE.pitch);
    const sinPitch = Math.sin(CAMERA_STATE.pitch);
    const cosYaw = Math.cos(CAMERA_STATE.yaw);
    const sinYaw = Math.sin(CAMERA_STATE.yaw);
    return {
        x: CAMERA_STATE.target.x + dist * cosPitch * sinYaw,
        y: CAMERA_STATE.target.y + dist * sinPitch,
        z: CAMERA_STATE.target.z + dist * cosPitch * cosYaw
    };
}

function getCameraBasis() {
    const pos = getCameraPosition();
    const target = CAMERA_STATE.target;
    let forward = normalizeVector({
        x: target.x - pos.x,
        y: target.y - pos.y,
        z: target.z - pos.z
    });
    let right = normalizeVector(crossVector(forward, { x: 0, y: 1, z: 0 }));
    if (lengthVector(right) < 0.001) {
        right = { x: 1, y: 0, z: 0 };
    }
    const up = normalizeVector(crossVector(right, forward));
    return { forward, right, up };
}

function updateCameraUniforms() {
    if (!gl || !program || !cameraUniformLocations.pos || !cameraUniformLocations.target) return;
    gl.useProgram(program);
    const pos = getCameraPosition();
    gl.uniform3f(cameraUniformLocations.pos, pos.x, pos.y, pos.z);
    gl.uniform3f(cameraUniformLocations.target, CAMERA_STATE.target.x, CAMERA_STATE.target.y, CAMERA_STATE.target.z);
}

function beginCameraDrag(mode, x, y) {
    cameraDragMode = mode;
    cameraLastX = x;
    cameraLastY = y;
    document.body.style.cursor = mode === 'pan' ? 'move' : 'grab';
}

function updateCameraDrag(x, y) {
    if (!cameraDragMode) return;
    const dx = x - cameraLastX;
    const dy = y - cameraLastY;
    cameraLastX = x;
    cameraLastY = y;
    const { right, up } = getCameraBasis();
    if (cameraDragMode === 'orbit') {
        CAMERA_STATE.yaw -= dx * 0.005;
        CAMERA_STATE.pitch = clamp(CAMERA_STATE.pitch + dy * 0.003, -1.4, 1.4);
    } else if (cameraDragMode === 'pan') {
        const panScale = CAMERA_STATE.distance * 0.002;
        CAMERA_STATE.target.x -= (dx * panScale) * right.x;
        CAMERA_STATE.target.y -= (dx * panScale) * right.y;
        CAMERA_STATE.target.z -= (dx * panScale) * right.z;
        CAMERA_STATE.target.x += (dy * panScale) * up.x;
        CAMERA_STATE.target.y += (dy * panScale) * up.y;
        CAMERA_STATE.target.z += (dy * panScale) * up.z;
    }
    updateCameraUniforms();
    renderPreview();
}

function endCameraDrag() {
    cameraDragMode = null;
    document.body.style.cursor = '';
}

function handleCameraWheel(event) {
    if (!isStageInteractionTarget(event.target)) return;
    event.preventDefault();
    const zoomFactor = Math.exp(event.deltaY * 0.001);
    CAMERA_STATE.distance = clamp(CAMERA_STATE.distance * zoomFactor, 0.8, 50);
    updateCameraUniforms();
    renderPreview();
}

function isStageInteractionTarget(target) {
    if (!target) return false;
    return !(
        target.closest('#sidebar') ||
        target.closest('#paramPanel') ||
        target.closest('.node') ||
        target.closest('.menu-item') ||
        target.closest('#sidebarControls') ||
        target.closest('#recycleBin') ||
        target.closest('.detach-wrapper')
    );
}

function normalizeVector(v) {
    const len = lengthVector(v);
    if (len < 1e-6) return { x: 0, y: 0, z: 0 };
    return { x: v.x / len, y: v.y / len, z: v.z / len };
}

function lengthVector(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

function crossVector(a, b) {
    return {
        x: a.y * b.z - a.z * b.y,
        y: a.z * b.x - a.x * b.z,
        z: a.x * b.y - a.y * b.x
    };
}

function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

function getNodeChildren(node) {
    return Array.from(node.children).filter(child => child.classList.contains('node'));
}

function canAcceptChild(parentNode) {
    const parentType = parentNode.dataset.type;
    const typeDef = NODE_TYPES[parentType];
    if (!typeDef) return false;
    
    const currentChildren = getNodeChildren(parentNode);
    return currentChildren.length < typeDef.maxChildren;
}

function attachNodeToParent(child, parent) {
    if (!canAcceptChild(parent)) {
        document.getElementById("rootnode").appendChild(child);
        positionNodeAtPoint(child, pos3, pos4);
        return false;
    }
    
    reparentNodePreservingPosition(child, parent);
    updateLine(child);
    markDataGraphDirty();
    return true;
}

function reparentNodePreservingPosition(node, newParent) {
    const nodeRect = node.getBoundingClientRect();
    const parentRect = newParent.getBoundingClientRect();
    newParent.appendChild(node);
    node.style.left = `${nodeRect.left - parentRect.left}px`;
    node.style.top = `${nodeRect.top - parentRect.top}px`;
}

function positionNodeAtPoint(node, clientX, clientY) {
    const parent = node.parentNode || document.getElementById('rootnode');
    const parentRect = parent.getBoundingClientRect();
    const offsetX = Number(node.dataset.dragOffsetX ?? node.offsetWidth / 2);
    const offsetY = Number(node.dataset.dragOffsetY ?? node.offsetHeight / 2);
    node.style.left = `${clientX - parentRect.left - offsetX}px`;
    node.style.top = `${clientY - parentRect.top - offsetY}px`;
}

function detachNodeToRoot(node) {
    const root = document.getElementById('rootnode');
    reparentNodePreservingPosition(node, root);
    updateLine(node);
    markDataGraphDirty();
}

function onDetachHandleMouseDown(event) {
    const wrapper = event.target.closest('.detach-wrapper');
    if (!wrapper) return;
    event.preventDefault();
    event.stopPropagation();
    const node = wrapper.closest('.node');
    if (!node || node.dataset.type === 'Scene') return;
    detachNodeToRoot(node);
    pos3 = event.clientX;
    pos4 = event.clientY;
    selectNode(node);
    startNodeDrag(node);
}

function selectNode(node) {
    if (selectedNode) {
        selectedNode.classList.remove('selected');
    }
    
    if (node && node.dataset.type !== 'Scene') {
        selectedNode = node;
        node.classList.add('selected');
        showParamPanel(node);
    } else {
        selectedNode = null;
        hideParamPanel();
    }
}

function showParamPanel(node) {
    const panel = document.getElementById('paramPanel');
    const content = document.getElementById('paramContent');
    const nodeName = document.getElementById('paramNodeName');
    
    const nodeType = node.dataset.type;
    const typeDef = NODE_TYPES[nodeType];
    const params = getNodeParams(node);
    
    nodeName.textContent = nodeType;
    content.innerHTML = '';
    
    if (typeDef.params && Object.keys(typeDef.params).length > 0) {
        const section = document.createElement('div');
        section.className = 'param-section';
        section.innerHTML = '<div class="param-section-title">Shape Parameters</div>';
        
        for (const [key, def] of Object.entries(typeDef.params)) {
            section.appendChild(createParamSlider(node, key, def, params[key]));
        }
        content.appendChild(section);
    }
    
    const transformSection = document.createElement('div');
    transformSection.className = 'param-section';
    transformSection.innerHTML = '<div class="param-section-title">Transform</div>';
    
    for (const [key, def] of Object.entries(TRANSFORM_PARAMS)) {
        transformSection.appendChild(createParamSlider(node, key, def, params[key]));
    }
    content.appendChild(transformSection);
    
    panel.classList.add('visible');
}

function createParamSlider(node, key, def, value) {
    const group = document.createElement('div');
    group.className = 'param-group';
    
    const label = document.createElement('label');
    label.textContent = key;
    
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = def.min;
    slider.max = def.max;
    slider.step = def.step;
    slider.value = value;
    
    const valueDisplay = document.createElement('div');
    valueDisplay.className = 'value-display';
    valueDisplay.textContent = value.toFixed(2);
    
    slider.addEventListener('input', () => {
        const numericValue = parseFloat(slider.value);
        valueDisplay.textContent = numericValue.toFixed(2);
        queueSliderUpdate(node, key, numericValue);
        dgLog('slider input', {
            nodeId: node.id,
            param: key,
            value: numericValue
        });
    });
    
    group.appendChild(label);
    group.appendChild(slider);
    group.appendChild(valueDisplay);
    
    return group;
}

function queueSliderUpdate(node, key, value) {
    let entry = pendingSliderUpdates.get(node);
    if (!entry) {
        entry = { node, changes: {} };
        pendingSliderUpdates.set(node, entry);
    }
    entry.changes[key] = value;
    if (!sliderFlushHandle) {
        sliderFlushHandle = requestAnimationFrame(() => {
            sliderFlushHandle = null;
            flushPendingSliderUpdates();
            requestPreviewRender();
        });
    }
}

function flushPendingSliderUpdates() {
    if (!pendingSliderUpdates.size) return;
    const updates = Array.from(pendingSliderUpdates.values());
    pendingSliderUpdates.clear();
    updates.forEach(entry => {
        const { node, changes } = entry;
        const params = getNodeParams(node);
        Object.assign(params, changes);
        setNodeParams(node, params);
        updateNodeUniformData(node);
    });
    dgLog('flushPendingSliderUpdates', { count: updates.length });
}

function hideParamPanel() {
    document.getElementById('paramPanel').classList.remove('visible');
}

function onDocumentMouseDown(event) {
    const target = event.target;
    
    if (target.closest('.detach-wrapper')) {
        return;
    }
    
    if (target.closest('#sidebar') || target.closest('#paramPanel') || 
        target.closest('#glCanvas') || target.closest('#codeOutput') ||
        target.closest('#toggleCode')) {
        return;
    }
    
    if (target.classList.contains("node") || target.parentNode.classList.contains("node")) {
        event.preventDefault();
        const node = target.classList.contains("node") ? target : target.parentNode;
        
        pos3 = event.clientX;
        pos4 = event.clientY;
        
        selectNode(node);
        startNodeDrag(node);
    } else {
        selectNode(null);
        if (isStageInteractionTarget(target)) {
            if (event.button === 0) {
                beginCameraDrag('orbit', event.clientX, event.clientY);
            } else if (event.button === 2) {
                beginCameraDrag('pan', event.clientX, event.clientY);
            }
        }
    }
}

function onDocumentMouseMove(event) {
    if (cameraDragMode) {
        event.preventDefault();
        updateCameraDrag(event.clientX, event.clientY);
        return;
    }
    if (dragging) {
        event.preventDefault();
        pos1 = pos3 - event.clientX;
        pos2 = pos4 - event.clientY;
        pos3 = event.clientX;
        pos4 = event.clientY;
        nodeDrag();
    }
}

function onDocumentMouseUp(event) {
    if (cameraDragMode) {
        event.preventDefault();
        endCameraDrag();
        return;
    }
    if (dragging) {
        event.preventDefault();
        
        if (detached) {
            const attached = finalizeDrop(event.clientX, event.clientY);
            if (!attached && dragged.parentNode.id === "rootnode") {
                positionNodeAtPoint(dragged, event.clientX, event.clientY);
                markDataGraphDirty();
            }
        }
        
        clearDropPreview();
        stopNodeDrag();
    }
}

function startNodeDrag(node) {
    dragging = true;
    dragged = node;
    detached = node.parentNode.id === "rootnode";
    const rect = node.getBoundingClientRect();
    const offsetX = pos3 - rect.left;
    const offsetY = pos4 - rect.top;
    node.dataset.dragOffsetX = offsetX;
    node.dataset.dragOffsetY = offsetY;
}

function nodeDrag() {
    const parentRect = dragged.parentNode.getBoundingClientRect();
    dragged.style.left = `${pos3 - parentRect.left - dragged.dataset.dragOffsetX}px`;
    dragged.style.top = `${pos4 - parentRect.top - dragged.dataset.dragOffsetY}px`;
    updateLine(dragged);
    if (detached) {
        updateDropPreview();
    } else {
        clearDropPreview();
    }
    updateRecyclePreview();
}

function stopNodeDrag() {
    dragging = false;
    detached = false;
    dragFromMenu = false;
    dragged = null;
    clearDropPreview();
    clearRecyclePreview();
}

function isValidDropTarget(child, target) {
    if (!target || target === child) return false;
    if (!target.classList || !target.classList.contains('node')) return false;
    if (child.contains && child.contains(target)) return false;
    return canAcceptChild(target);
}

function getDropZoneRect(node) {
    const rect = node.getBoundingClientRect();
    const padding = 10;
    const width = rect.width * 1.2;
    const height = rect.height * 2.2;
    const centerX = rect.left + rect.width / 2;
    return {
        left: centerX - width / 2,
        right: centerX + width / 2,
        top: rect.bottom + padding,
        bottom: rect.bottom + padding + height,
        anchorX: centerX,
        anchorY: rect.top + rect.height / 2
    };
}

function findDropTarget(x, y) {
    for (const node of nodesArray) {
        if (!isValidDropTarget(dragged, node)) continue;
        const zone = getDropZoneRect(node);
        if (x >= zone.left && x <= zone.right && y >= zone.top && y <= zone.bottom) {
            return { node, zone };
        }
    }
    return null;
}

function getPreviewPathData(zone, pointerX, pointerY) {
    const midY = (zone.anchorY + pointerY) / 2;
    return [
        ['M', zone.anchorX, zone.anchorY],
        ['C', zone.anchorX, midY, pointerX, midY, pointerX, pointerY]
    ];
}

function updateDropPreview() {
    if (!dragged) return;
    const pointerX = pos3;
    const pointerY = pos4;
    if (!Number.isFinite(pointerX) || !Number.isFinite(pointerY)) return;
    
    const targetInfo = findDropTarget(pointerX, pointerY);
    if (!targetInfo) {
        clearDropPreview();
        return;
    }
    
    if (currentDropTarget === targetInfo.node) {
        if (dropPreview) {
            dropPreview.plot(getPreviewPathData(targetInfo.zone, pointerX, pointerY));
        }
        return;
    }
    
    currentDropTarget = targetInfo.node;
    const pathData = getPreviewPathData(targetInfo.zone, pointerX, pointerY);
    if (!dropPreview) {
        dropPreview = draw.path(pathData)
            .fill('none')
            .stroke({ width: 2, color: '#f6ad55', dasharray: '6 4', linecap: 'round' });
    } else {
        dropPreview.plot(pathData);
    }
}

function clearDropPreview() {
    if (dropPreview) {
        dropPreview.remove();
        dropPreview = null;
    }
    currentDropTarget = null;
}

function updateRecyclePreview() {
    if (!dragged) return;
    const rect = recycleRect();
    const inBin = pos3 >= rect.left && pos3 <= rect.right && pos4 >= rect.top && pos4 <= rect.bottom;
    if (inBin && !recycleActive) {
        recycleActive = true;
        recycleBin.classList.add('active');
    } else if (!inBin && recycleActive) {
        recycleActive = false;
        recycleBin.classList.remove('active');
    }
}

function clearRecyclePreview() {
    recycleActive = false;
    recycleBin.classList.remove('active');
}

function checkRecycleBin(clientX, clientY) {
    const rect = recycleRect();
    return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
}

function deleteNodeWithChildren(node) {
    if (!node || node.id === 'scene') return;
    if (selectedNode && (selectedNode === node || node.contains(selectedNode))) {
        selectNode(null);
    }
    const descendants = Array.from(node.querySelectorAll('.node'));
    descendants.forEach(releaseNodeSlot);
    releaseNodeSlot(node);
    node.remove();
    scanNodes();
    draw.clear();
    lines = [];
    dropPreview = null;
    currentDropTarget = null;
    addLines();
    markDataGraphDirty();
}

function finalizeDrop(clientX, clientY) {
    if (checkRecycleBin(clientX, clientY)) {
        deleteNodeWithChildren(dragged);
        clearDropPreview();
        clearRecyclePreview();
        return true;
    }
    
    if (currentDropTarget && attachNodeToParent(dragged, currentDropTarget)) {
        clearDropPreview();
        clearRecyclePreview();
        return true;
    }
    
    dragged.hidden = true;
    const elemBelow = document.elementFromPoint(clientX, clientY);
    dragged.hidden = false;
    
    if (elemBelow) {
        let targetNode = null;
        if (elemBelow.classList.contains("node")) {
            targetNode = elemBelow;
        } else if (elemBelow.parentNode && elemBelow.parentNode.classList.contains("node")) {
            targetNode = elemBelow.parentNode;
        }
        
        if (isValidDropTarget(dragged, targetNode)) {
            clearDropPreview();
            clearRecyclePreview();
            return attachNodeToParent(dragged, targetNode);
        }
    }
    
    clearDropPreview();
    clearRecyclePreview();
    return false;
}

// Helper to traverse all nodes connected to scene
function traverseSceneNodes(callback) {
    const sceneNode = document.getElementById('scene');
    
    function traverse(node) {
        if (node.dataset.type !== 'Scene') {
            callback(node);
        }
        getNodeChildren(node).forEach(child => traverse(child));
    }
    
    traverse(sceneNode);
}

function getSceneStats() {
    const sceneNode = document.getElementById('scene');
    let count = 0;
    let depth = 0;
    
    function traverse(node, currentDepth) {
        if (node.dataset.type !== 'Scene') {
            count++;
            depth = Math.max(depth, currentDepth);
        }
        getNodeChildren(node).forEach(child => traverse(child, currentDepth + 1));
    }
    
    traverse(sceneNode, 0);
    return { nodeCount: count, maxDepth: depth };
}

function getNodeVarName(node) {
    return 'd_' + node.id.replace(/[^a-zA-Z0-9]/g, '_');
}

// ===========================================
// EXPORT GLSL - Hardcoded values (for output)
// ===========================================
function generateExportGLSL() {
    const t0 = perfNow();
    const sceneNode = document.getElementById('scene');
    const children = getNodeChildren(sceneNode);
    
    let code = getSDFPreamble();
    
    if (children.length === 0) {
        code += `float sceneSDF(vec3 p) {
    return 1000.0; // Empty scene
}`;
    } else if (children.length === 1) {
        code += `
float sceneSDF(vec3 p) {
${generateExportNodeCode(children[0], 'p')}
    return ${getNodeVarName(children[0])};
}`;
    } else {
        let nodeCode = '';
        children.forEach(child => {
            nodeCode += generateExportNodeCode(child, 'p');
        });
        
        let unionExpr = getNodeVarName(children[0]);
        for (let i = 1; i < children.length; i++) {
            unionExpr = `min(${unionExpr}, ${getNodeVarName(children[i])})`;
        }
        
        code += `
float sceneSDF(vec3 p) {
${nodeCode}
    return ${unionExpr};
}`;
    }
    
    const stats = getSceneStats();
    perfLogDuration('generateExportGLSL', t0, `nodes=${stats.nodeCount} depth=${stats.maxDepth}`);
    return code;
}

function generateExportNodeCode(node, pointVar) {
    const nodeType = node.dataset.type;
    const params = getNodeParams(node);
    const varName = getNodeVarName(node);
    const typeDef = NODE_TYPES[nodeType];
    
    let code = '';
    const transformedPoint = varName + '_p';
    const rad = Math.PI / 180;
    const scaleVar = `${varName}_scale`;
    
    code += `    vec3 ${transformedPoint} = ${pointVar};\n`;
    code += `    ${transformedPoint} -= vec3(${params.posX.toFixed(3)}, ${params.posY.toFixed(3)}, ${params.posZ.toFixed(3)});\n`;
    if (params.rotX !== 0) code += `    ${transformedPoint} *= rotateX(${(params.rotX * rad).toFixed(4)});\n`;
    if (params.rotY !== 0) code += `    ${transformedPoint} *= rotateY(${(params.rotY * rad).toFixed(4)});\n`;
    if (params.rotZ !== 0) code += `    ${transformedPoint} *= rotateZ(${(params.rotZ * rad).toFixed(4)});\n`;
    code += `    float ${scaleVar} = max(${params.scale.toFixed(3)}, 0.0001);\n`;
    code += `    ${transformedPoint} /= ${scaleVar};\n`;
    
    if (typeDef.category === 'primitive') {
        switch (nodeType) {
            case 'Sphere':
                code += `    float ${varName} = sdSphere(${transformedPoint}, ${params.radius.toFixed(3)});\n`;
                break;
            case 'Box':
                code += `    float ${varName} = sdBox(${transformedPoint}, vec3(${params.sizeX.toFixed(3)}, ${params.sizeY.toFixed(3)}, ${params.sizeZ.toFixed(3)}));\n`;
                break;
            case 'Torus':
                code += `    float ${varName} = sdTorus(${transformedPoint}, vec2(${params.majorRadius.toFixed(3)}, ${params.minorRadius.toFixed(3)}));\n`;
                break;
            case 'Cylinder':
                code += `    float ${varName} = sdCylinder(${transformedPoint}, ${params.radius.toFixed(3)}, ${params.height.toFixed(3)});\n`;
                break;
            case 'Octahedron':
                code += `    float ${varName} = sdOctahedron(${transformedPoint}, ${params.size.toFixed(3)});\n`;
                break;
            case 'Cone': {
                const angle = ((params.angleDeg ?? 45) * rad);
                code += `    float ${varName} = sdCone(${transformedPoint}, vec2(sin(${angle.toFixed(4)}), cos(${angle.toFixed(4)})), ${params.height.toFixed(3)});\n`;
                break;
            }
            case 'RoundCone':
                code += `    float ${varName} = sdRoundCone(${transformedPoint}, ${params.radiusTop.toFixed(3)}, ${params.radiusBottom.toFixed(3)}, ${params.height.toFixed(3)});\n`;
                break;
            case 'VerticalCapsule':
                code += `    float ${varName} = sdVerticalCapsule(${transformedPoint}, ${params.height.toFixed(3)}, ${params.radius.toFixed(3)});\n`;
                break;
            case 'CutHollowSphere':
                code += `    float ${varName} = sdCutHollowSphere(${transformedPoint}, ${params.radius.toFixed(3)}, ${params.height.toFixed(3)}, ${params.thickness.toFixed(3)});\n`;
                break;
            case 'DeathStar':
                code += `    float ${varName} = sdDeathStar(${transformedPoint}, ${params.radiusA.toFixed(3)}, ${params.radiusB.toFixed(3)}, ${params.offset.toFixed(3)});\n`;
                break;
            case 'VesicaSegment':
                code += `    float ${varName} = sdVesicaSegment(${transformedPoint}, vec3(${params.ax.toFixed(3)}, ${params.ay.toFixed(3)}, ${params.az.toFixed(3)}), vec3(${params.bx.toFixed(3)}, ${params.by.toFixed(3)}, ${params.bz.toFixed(3)}), ${params.width.toFixed(3)});\n`;
                break;
        }
    } else if (typeDef.category === 'operation') {
        const children = getNodeChildren(node);
        
        if (children.length < 2) {
            code += `    float ${varName} = 1000.0; // Incomplete operation\n`;
        } else {
            code += generateExportNodeCode(children[0], transformedPoint);
            code += generateExportNodeCode(children[1], transformedPoint);
            
            const child1Var = getNodeVarName(children[0]);
            const child2Var = getNodeVarName(children[1]);
            
            switch (nodeType) {
                case 'opUnion':
                    code += `    float ${varName} = min(${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothUnion':
                    code += `    float ${varName} = opSmoothUnion(${child1Var}, ${child2Var}, ${params.k.toFixed(3)});\n`;
                    break;
                case 'opSubtraction':
                    code += `    float ${varName} = max(-${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothSubtraction':
                    code += `    float ${varName} = opSmoothSubtraction(${child1Var}, ${child2Var}, ${params.k.toFixed(3)});\n`;
                    break;
                case 'opIntersection':
                    code += `    float ${varName} = max(${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothIntersection':
                    code += `    float ${varName} = opSmoothIntersection(${child1Var}, ${child2Var}, ${params.k.toFixed(3)});\n`;
                    break;
                case 'opXor':
                    code += `    float ${varName} = opXor(${child1Var}, ${child2Var});\n`;
                    break;
            }
        }
    } else if (typeDef.category === 'modifier') {
        const children = getNodeChildren(node);
        if (children.length < 1) {
            code += `    float ${varName} = 1000.0; // Incomplete modifier\n`;
        } else {
            const child = children[0];
            const childVar = getNodeVarName(child);
            switch (nodeType) {
                case 'opRound':
                    code += generateExportNodeCode(child, transformedPoint);
                    code += `    float ${varName} = ${childVar} - ${params.roundRadius.toFixed(3)};\n`;
                    break;
                case 'opOnion':
                    code += generateExportNodeCode(child, transformedPoint);
                    code += `    float ${varName} = abs(${childVar}) - ${params.shellThickness.toFixed(3)};\n`;
                    break;
                case 'opTwist': {
                    const warpPoint = `${varName}_warp`;
                    const angleVar = `${varName}_angle`;
                    const matVar = `${varName}_mat`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    float ${angleVar} = ${params.twistAmount.toFixed(3)} * ${warpPoint}.y;\n`;
                    code += `    mat2 ${matVar} = mat2(cos(${angleVar}), -sin(${angleVar}), sin(${angleVar}), cos(${angleVar}));\n`;
                    code += `    ${warpPoint}.xz = ${matVar} * ${warpPoint}.xz;\n`;
                    code += generateExportNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
                case 'opElongate': {
                    const qVar = `${varName}_q`;
                    const clampVar = `${varName}_clamped`;
                    code += `    vec3 ${qVar} = abs(${transformedPoint}) - vec3(${params.extentX.toFixed(3)}, ${params.extentY.toFixed(3)}, ${params.extentZ.toFixed(3)});\n`;
                    code += `    vec3 ${clampVar} = max(${qVar}, vec3(0.0));\n`;
                    code += generateExportNodeCode(child, clampVar);
                    code += `    float ${varName} = ${childVar} + min(max(${qVar}.x, max(${qVar}.y, ${qVar}.z)), 0.0);\n`;
                    break;
                }
                case 'opCheapBend': {
                    const warpPoint = `${varName}_warp`;
                    const angleVar = `${varName}_angle`;
                    const matVar = `${varName}_mat`;
                    const rotated = `${varName}_rot`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    float ${angleVar} = ${params.bendAmount.toFixed(3)} * ${warpPoint}.x;\n`;
                    code += `    mat2 ${matVar} = mat2(cos(${angleVar}), -sin(${angleVar}), sin(${angleVar}), cos(${angleVar}));\n`;
                    code += `    vec2 ${rotated} = ${matVar} * ${warpPoint}.xy;\n`;
                    code += `    ${warpPoint}.xy = ${rotated};\n`;
                    code += generateExportNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
                case 'opSymX': {
                    const warpPoint = `${varName}_warp`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    ${warpPoint}.x = abs(${warpPoint}.x);\n`;
                    code += generateExportNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
            }
        }
    }
    
    code += `    ${varName} *= ${scaleVar};\n`;
    
    return code;
}

// ===========================================
// PREVIEW GLSL - Uniform-based (for live edit)
// ===========================================
function generatePreviewGLSL() {
    const t0 = perfNow();
    const sceneNode = document.getElementById('scene');
    const children = getNodeChildren(sceneNode);
    
    let code = getSDFPreamble();
    
    // Generate uniform declarations
    code += '\n// Node uniforms\n';
    traverseSceneNodes(node => {
        const prefix = getNodeVarName(node);
        const nodeType = node.dataset.type;
        const typeDef = NODE_TYPES[nodeType];
        
        code += `uniform vec3 ${prefix}_pos;\n`;
        code += `uniform vec3 ${prefix}_rot;\n`;
        code += `uniform float ${prefix}_scale;\n`;
        
        if (typeDef.params) {
            for (const key of Object.keys(typeDef.params)) {
                code += `uniform float ${prefix}_${key};\n`;
            }
        }
    });
    
    code += '\n';
    
    if (children.length === 0) {
        code += `float sceneSDF(vec3 p) {
    return 1000.0; // Empty scene
}`;
    } else if (children.length === 1) {
        code += `
float sceneSDF(vec3 p) {
${generatePreviewNodeCode(children[0], 'p')}
    return ${getNodeVarName(children[0])};
}`;
    } else {
        let nodeCode = '';
        children.forEach(child => {
            nodeCode += generatePreviewNodeCode(child, 'p');
        });
        
        let unionExpr = getNodeVarName(children[0]);
        for (let i = 1; i < children.length; i++) {
            unionExpr = `min(${unionExpr}, ${getNodeVarName(children[i])})`;
        }
        
        code += `
float sceneSDF(vec3 p) {
${nodeCode}
    return ${unionExpr};
}`;
    }
    
    const stats = getSceneStats();
    perfLogDuration('generatePreviewGLSL', t0, `nodes=${stats.nodeCount} depth=${stats.maxDepth}`);
    return code;
}

function generatePreviewNodeCode(node, pointVar) {
    const nodeType = node.dataset.type;
    const varName = getNodeVarName(node);
    const prefix = varName;
    const typeDef = NODE_TYPES[nodeType];
    
    let code = '';
    const transformedPoint = varName + '_p';
    const scaleVar = `${varName}_scale`;
    
    code += `    vec3 ${transformedPoint} = ${pointVar};\n`;
    code += `    ${transformedPoint} -= ${prefix}_pos;\n`;
    code += `    ${transformedPoint} *= rotateX(${prefix}_rot.x);\n`;
    code += `    ${transformedPoint} *= rotateY(${prefix}_rot.y);\n`;
    code += `    ${transformedPoint} *= rotateZ(${prefix}_rot.z);\n`;
    code += `    float ${scaleVar} = max(${prefix}_scale, 0.0001);\n`;
    code += `    ${transformedPoint} /= ${scaleVar};\n`;
    
    if (typeDef.category === 'primitive') {
        switch (nodeType) {
            case 'Sphere':
                code += `    float ${varName} = sdSphere(${transformedPoint}, ${prefix}_radius);\n`;
                break;
            case 'Box':
                code += `    float ${varName} = sdBox(${transformedPoint}, vec3(${prefix}_sizeX, ${prefix}_sizeY, ${prefix}_sizeZ));\n`;
                break;
            case 'Torus':
                code += `    float ${varName} = sdTorus(${transformedPoint}, vec2(${prefix}_majorRadius, ${prefix}_minorRadius));\n`;
                break;
            case 'Cylinder':
                code += `    float ${varName} = sdCylinder(${transformedPoint}, ${prefix}_radius, ${prefix}_height);\n`;
                break;
            case 'Octahedron':
                code += `    float ${varName} = sdOctahedron(${transformedPoint}, ${prefix}_size);\n`;
                break;
            case 'Cone': {
                const angleVar = `${varName}_angle`;
                const coneVec = `${varName}_c`;
                code += `    float ${angleVar} = radians(${prefix}_angleDeg);\n`;
                code += `    vec2 ${coneVec} = vec2(sin(${angleVar}), cos(${angleVar}));\n`;
                code += `    float ${varName} = sdCone(${transformedPoint}, ${coneVec}, ${prefix}_height);\n`;
                break;
            }
            case 'RoundCone':
                code += `    float ${varName} = sdRoundCone(${transformedPoint}, ${prefix}_radiusTop, ${prefix}_radiusBottom, ${prefix}_height);\n`;
                break;
            case 'VerticalCapsule':
                code += `    float ${varName} = sdVerticalCapsule(${transformedPoint}, ${prefix}_height, ${prefix}_radius);\n`;
                break;
            case 'CutHollowSphere':
                code += `    float ${varName} = sdCutHollowSphere(${transformedPoint}, ${prefix}_radius, ${prefix}_height, ${prefix}_thickness);\n`;
                break;
            case 'DeathStar':
                code += `    float ${varName} = sdDeathStar(${transformedPoint}, ${prefix}_radiusA, ${prefix}_radiusB, ${prefix}_offset);\n`;
                break;
            case 'VesicaSegment':
                code += `    float ${varName} = sdVesicaSegment(${transformedPoint}, vec3(${prefix}_ax, ${prefix}_ay, ${prefix}_az), vec3(${prefix}_bx, ${prefix}_by, ${prefix}_bz), ${prefix}_width);\n`;
                break;
        }
    } else if (typeDef.category === 'operation') {
        const children = getNodeChildren(node);
        
        if (children.length < 2) {
            code += `    float ${varName} = 1000.0; // Incomplete operation\n`;
        } else {
            code += generatePreviewNodeCode(children[0], transformedPoint);
            code += generatePreviewNodeCode(children[1], transformedPoint);
            
            const child1Var = getNodeVarName(children[0]);
            const child2Var = getNodeVarName(children[1]);
            
            switch (nodeType) {
                case 'opUnion':
                    code += `    float ${varName} = min(${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothUnion':
                    code += `    float ${varName} = opSmoothUnion(${child1Var}, ${child2Var}, ${prefix}_k);\n`;
                    break;
                case 'opSubtraction':
                    code += `    float ${varName} = max(-${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothSubtraction':
                    code += `    float ${varName} = opSmoothSubtraction(${child1Var}, ${child2Var}, ${prefix}_k);\n`;
                    break;
                case 'opIntersection':
                    code += `    float ${varName} = max(${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothIntersection':
                    code += `    float ${varName} = opSmoothIntersection(${child1Var}, ${child2Var}, ${prefix}_k);\n`;
                    break;
                case 'opXor':
                    code += `    float ${varName} = opXor(${child1Var}, ${child2Var});\n`;
                    break;
            }
        }
    } else if (typeDef.category === 'modifier') {
        const children = getNodeChildren(node);
        if (children.length < 1) {
            code += `    float ${varName} = 1000.0; // Incomplete modifier\n`;
        } else {
            const child = children[0];
            const childVar = getNodeVarName(child);
            switch (nodeType) {
                case 'opRound':
                    code += generatePreviewNodeCode(child, transformedPoint);
                    code += `    float ${varName} = ${childVar} - ${prefix}_roundRadius;\n`;
                    break;
                case 'opOnion':
                    code += generatePreviewNodeCode(child, transformedPoint);
                    code += `    float ${varName} = abs(${childVar}) - ${prefix}_shellThickness;\n`;
                    break;
                case 'opTwist': {
                    const warpPoint = `${varName}_warp`;
                    const angleVar = `${varName}_angle`;
                    const matVar = `${varName}_mat`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    float ${angleVar} = ${prefix}_twistAmount * ${warpPoint}.y;\n`;
                    code += `    mat2 ${matVar} = mat2(cos(${angleVar}), -sin(${angleVar}), sin(${angleVar}), cos(${angleVar}));\n`;
                    code += `    ${warpPoint}.xz = ${matVar} * ${warpPoint}.xz;\n`;
                    code += generatePreviewNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
                case 'opElongate': {
                    const qVar = `${varName}_q`;
                    const clampVar = `${varName}_clamped`;
                    code += `    vec3 ${qVar} = abs(${transformedPoint}) - vec3(${prefix}_extentX, ${prefix}_extentY, ${prefix}_extentZ);\n`;
                    code += `    vec3 ${clampVar} = max(${qVar}, vec3(0.0));\n`;
                    code += generatePreviewNodeCode(child, clampVar);
                    code += `    float ${varName} = ${childVar} + min(max(${qVar}.x, max(${qVar}.y, ${qVar}.z)), 0.0);\n`;
                    break;
                }
                case 'opCheapBend': {
                    const warpPoint = `${varName}_warp`;
                    const angleVar = `${varName}_angle`;
                    const matVar = `${varName}_mat`;
                    const rotated = `${varName}_rot`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    float ${angleVar} = ${prefix}_bendAmount * ${warpPoint}.x;\n`;
                    code += `    mat2 ${matVar} = mat2(cos(${angleVar}), -sin(${angleVar}), sin(${angleVar}), cos(${angleVar}));\n`;
                    code += `    vec2 ${rotated} = ${matVar} * ${warpPoint}.xy;\n`;
                    code += `    ${warpPoint}.xy = ${rotated};\n`;
                    code += generatePreviewNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
                case 'opSymX': {
                    const warpPoint = `${varName}_warp`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    ${warpPoint}.x = abs(${warpPoint}.x);\n`;
                    code += generatePreviewNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
            }
        }
    }
    
    code += `    ${varName} *= ${scaleVar};\n`;
    
    return code;
}

function loadDataShader() {
    if (dataShaderSource) {
        return Promise.resolve();
    }
    return fetch('glsl/data-preview.glsl')
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to load data preview shader');
            }
            return response.text();
        })
        .then(text => {
            dataShaderSource = text
                .replace(/{{MAX_DATA_NODES}}/g, MAX_DATA_NODES.toString())
                .replace(/{{\s*MAX_PARAM_SLOTS\s*}}/g, MAX_PARAM_SLOTS.toString());
        });
}

function ensureNodeBuffer() {
    if (!gl || nodeBuffer) return;
    nodeBuffer = gl.createBuffer();
    const floatsPerBlock = (1 + MAX_DATA_NODES) * 4;
    nodeBufferData = new Float32Array(floatsPerBlock);
    gl.bindBuffer(gl.UNIFORM_BUFFER, nodeBuffer);
    gl.bufferData(gl.UNIFORM_BUFFER, nodeBufferData.byteLength, gl.DYNAMIC_DRAW);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, NODE_BUFFER_BINDING, nodeBuffer);
}

function refreshDataGraph() {
    if (!gl || !dataGraphDirty) return;
    const packed = buildDataGraph();
    uploadNodeBuffer(packed);
    dataGraphDirty = false;
    dgLog('refreshDataGraph', { count: packed.count, root: packed.rootIndex });
}

function buildDataGraph() {
    const sceneNode = document.getElementById('scene');
    const visited = [];

    function visit(node) {
        const children = getNodeChildren(node);
        const childIndices = [];
        for (const child of children) {
            const childIdx = visit(child);
            if (childIdx !== null && childIdx !== undefined) {
                childIndices.push(childIdx);
            }
        }
        const type = node.dataset.type;
        const mappedType = NODE_TYPE_ID_MAP[type];
        if (mappedType !== undefined) {
            const typeDef = NODE_TYPES[type];
            if (typeDef && typeDef.category === 'primitive') {
                const slot = ensureNodeSlot(node);
                const idx = visited.length;
                visited.push({
                    type: mappedType,
                    childA: -1,
                    childB: -1,
                    slot
                });
                return idx;
            } else if (typeDef && typeDef.category === 'operation') {
                if (childIndices.length === 0) {
                    return null;
                }
                let aggregator = childIndices[0];
                const slot = nodeRequiresSlot(node) ? ensureNodeSlot(node) : -1;
                for (let i = 1; i < childIndices.length; i++) {
                    const idx = visited.length;
                    visited.push({
                        type: mappedType,
                        childA: aggregator,
                        childB: childIndices[i],
                        slot
                    });
                    aggregator = idx;
                }
                return aggregator;
            }
        }
        return childIndices.length > 0 ? childIndices[childIndices.length - 1] : null;
    }

    const rootChildren = getNodeChildren(sceneNode);
    const rootIndices = [];
    rootChildren.forEach(child => {
        const idx = visit(child);
        if (idx !== null && idx !== undefined) {
            rootIndices.push(idx);
        }
    });

    if (rootIndices.length === 0) {
        const idx = visited.length;
        visited.push({
            type: NODE_TYPE_SPHERE,
            childA: -1,
            childB: -1,
            slot: STAGE_SLOT_INDEX
        });
        rootIndices.push(idx);
    }

    let rootIndex = rootIndices[0];
    for (let i = 1; i < rootIndices.length; i++) {
        const idx = visited.length;
        visited.push({
            type: NODE_TYPE_UNION,
            childA: rootIndex,
            childB: rootIndices[i],
            slot: -1
        });
        rootIndex = idx;
    }

    let nodeCount = visited.length;
    if (nodeCount > MAX_DATA_NODES) {
        console.warn(`Data graph truncated to ${MAX_DATA_NODES} nodes (had ${nodeCount})`);
        nodeCount = MAX_DATA_NODES;
        if (rootIndex >= nodeCount) {
            rootIndex = nodeCount - 1;
        }
    }

    return {
        nodes: visited.slice(0, nodeCount),
        count: nodeCount,
        rootIndex
    };
}

function uploadNodeBuffer(graph) {
    ensureNodeBuffer();
    if (!nodeBufferData) return;
    nodeBufferData.fill(0);
    nodeBufferData[0] = graph.count;
    nodeBufferData[1] = graph.rootIndex;
    const metaOffset = 4;
    for (let i = 0; i < graph.count; i++) {
        const node = graph.nodes[i];
        const metaIndex = metaOffset + 4 * i;
        nodeBufferData[metaIndex] = node.type ?? NODE_TYPE_SPHERE;
        nodeBufferData[metaIndex + 1] = node.childA ?? -1;
        nodeBufferData[metaIndex + 2] = node.childB ?? -1;
        nodeBufferData[metaIndex + 3] = node.slot ?? STAGE_SLOT_INDEX;
    }
    gl.bindBuffer(gl.UNIFORM_BUFFER, nodeBuffer);
    gl.bufferSubData(gl.UNIFORM_BUFFER, 0, nodeBufferData);
    const usedBytes = (1 + graph.count) * 16;
    updateUBOMemoryUsage(usedBytes);
    dgLog('uploadNodeBuffer', { count: graph.count, usedBytes });
}

function getSDFPreamble() {
    return `// SDF Primitives and Operations
float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float sdCylinder(vec3 p, float r, float h) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float sdOctahedron(vec3 p, float s) {
    p = abs(p);
    float m = p.x + p.y + p.z - s;
    vec3 q;
         if (3.0 * p.x < m) q = p.xyz;
    else if (3.0 * p.y < m) q = p.yzx;
    else if (3.0 * p.z < m) q = p.zxy;
    else return m * 0.57735027;
    
    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);
    return length(vec3(q.x, q.y - s + k, q.z - k));
}

float sdCone(vec3 p, vec2 c, float h) {
    float safeCos = max(c.y, 0.0001);
    vec2 q = h * vec2(c.x / safeCos, -1.0);
    vec2 w = vec2(length(p.xz), p.y);
    vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
    vec2 b = w - q * vec2(clamp(w.x / max(q.x, 0.0001), 0.0, 1.0), 1.0);
    float k = sign(q.y);
    float d = min(dot(a, a), dot(b, b));
    float sgn = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
    return sqrt(d) * sign(sgn);
}

float sdRoundCone(vec3 p, float r1, float r2, float h) {
    float b = (r1 - r2) / h;
    float a = sqrt(max(1.0 - b * b, 0.0001));
    vec2 q = vec2(length(p.xz), p.y);
    float k = dot(q, vec2(-b, a));
    if (k < 0.0) return length(q) - r1;
    if (k > a * h) return length(q - vec2(0.0, h)) - r2;
    return dot(q, vec2(a, b)) - r1;
}

float sdVerticalCapsule(vec3 p, float h, float r) {
    p.y -= clamp(p.y, 0.0, h);
    return length(p) - r;
}

float sdCutHollowSphere(vec3 p, float r, float h, float t) {
    float w = sqrt(max(r * r - h * h, 0.0));
    vec2 q = vec2(length(p.xz), p.y);
    return ((h * q.x < w * q.y) ? length(q - vec2(w, h)) : abs(length(q) - r)) - t;
}

float sdDeathStar(vec3 p2, float ra, float rb, float d) {
    float a = (ra * ra - rb * rb + d * d) / (2.0 * d);
    float b = sqrt(max(ra * ra - a * a, 0.0));
    vec2 p = vec2(p2.x, length(p2.yz));
    if (p.x * b - p.y * a > d * max(b - p.y, 0.0)) {
        return length(p - vec2(a, b));
    }
    return max(length(p) - ra, -(length(p - vec2(d, 0.0)) - rb));
}

float sdVesicaSegment(vec3 p, vec3 a, vec3 b, float w) {
    vec3 c = (a + b) * 0.5;
    vec3 ba = b - a;
    float l = length(ba);
    vec3 v = ba / max(l, 0.0001);
    vec3 rel = p - c;
    float y = dot(rel, v);
    vec2 q = vec2(length(rel - y * v), abs(y));
    float r = 0.5 * l;
    float ww = max(w, 0.0001);
    float d = 0.5 * (r * r - ww * ww) / ww;
    vec3 h = (r * q.x < d * (q.y - r)) ? vec3(0.0, r, 0.0) : vec3(-d, 0.0, d + ww);
    return length(q - h.xy) - h.z;
}

float opSmoothUnion(float d1, float d2, float k) {
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) - k * h * (1.0 - h);
}

float opSmoothSubtraction(float d1, float d2, float k) {
    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);
    return mix(d2, -d1, h) + k * h * (1.0 - h);
}

float opSmoothIntersection(float d1, float d2, float k) {
    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) + k * h * (1.0 - h);
}

float opXor(float d1, float d2) {
    return max(min(d1, d2), -max(d1, d2));
}

mat3 rotateX(float a) {
    float c = cos(a), s = sin(a);
    return mat3(1, 0, 0, 0, c, -s, 0, s, c);
}

mat3 rotateY(float a) {
    float c = cos(a), s = sin(a);
    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);
}

mat3 rotateZ(float a) {
    float c = cos(a), s = sin(a);
    return mat3(c, -s, 0, s, c, 0, 0, 0, 1);
}

`;
}

// ===========================================
// WebGL
// ===========================================
function initWebGL() {
    const canvas = document.getElementById('glCanvas');
    gl = canvas.getContext('webgl2', { antialias: false });
    
    if (!gl) {
        console.error('WebGL2 not supported - data-driven preview requires WebGL2.');
        if (uboMemoryDisplay) {
            uboMemoryDisplay.textContent = 'UBO Memory: WebGL2 required';
        }
        if (uniformArrayMemoryDisplay) {
            uniformArrayMemoryDisplay.textContent = 'Uniform Memory: WebGL2 required';
        }
        return;
    }
    
    const limits = logDataLimits(gl);
    if (limits.totalBytes > 0) {
        uboBudget.totalKB = limits.totalBytes / 1024;
    } else if (limits.uniformVec4s) {
        uboBudget.totalKB = (limits.uniformVec4s * 16) / 1024;
    } else {
        uboBudget.totalKB = 0;
    }
    updateUBOMemoryUsage(0);
    initUniformArrayBudget(limits.uniformVec4s || 0);
    
    if (pixelScaleSlider) {
        const initialValue = parseInt(pixelScaleSlider.value, 10);
        previewScaleIndex = Math.max(0, Math.min(PREVIEW_PIXEL_SCALES.length - 1, isNaN(initialValue) ? 0 : initialValue));
    } else {
        previewScaleIndex = 0;
    }
    updatePixelScaleLabel();
    applyPreviewScale();
    
    // Create vertex buffer once
    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
}

function createShaderProgram(fragmentShaderSource) {
    if (!gl) return null;
    const vertexShaderSource = `#version 300 es
layout(location = 0) in vec2 position;
void main() {
    gl_Position = vec4(position, 0.0, 1.0);
}`;
    
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);
    
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        console.error('Vertex shader error:', gl.getShaderInfoLog(vertexShader));
        return null;
    }
    
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);
    
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        console.error('Fragment shader error:', gl.getShaderInfoLog(fragmentShader));
        return null;
    }
    
    const prog = gl.createProgram();
    gl.attachShader(prog, vertexShader);
    gl.attachShader(prog, fragmentShader);
    gl.linkProgram(prog);
    
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(prog));
        return null;
    }
    
    resolutionUniform = gl.getUniformLocation(prog, 'resolution');
    cameraUniformLocations.pos = gl.getUniformLocation(prog, 'u_cameraPos');
    cameraUniformLocations.target = gl.getUniformLocation(prog, 'u_cameraTarget');
    if (gl instanceof WebGL2RenderingContext) {
        const blockIndex = gl.getUniformBlockIndex(prog, 'NodeBuffer');
        if (blockIndex !== gl.INVALID_INDEX && blockIndex !== 0xFFFFFFFF) {
            gl.uniformBlockBinding(prog, blockIndex, NODE_BUFFER_BINDING);
        }
    }
    
    return prog;
}

function cacheUniformLocations() {
    if (!gl || !program) return;
    cameraUniformLocations.pos = gl.getUniformLocation(program, 'u_cameraPos');
    cameraUniformLocations.target = gl.getUniformLocation(program, 'u_cameraTarget');
    if (!resolutionUniform) {
        resolutionUniform = gl.getUniformLocation(program, 'resolution');
    }
    uniformLocations.pos = gl.getUniformLocation(program, 'uNodePos');
    uniformLocations.rotScale = gl.getUniformLocation(program, 'uNodeRotScale');
    uniformLocations.params = gl.getUniformLocation(program, 'uNodeParams');
}

function uploadUniforms() {
    if (!gl || !program) return;
    if (!uniformLocations.pos || !uniformLocations.rotScale || !uniformLocations.params) {
        cacheUniformLocations();
    }
    if (!uniformLocations.pos || !uniformLocations.rotScale || !uniformLocations.params) {
        return;
    }
    if (!uniformsDirty) {
        dgLog('uploadUniforms skipped (already clean)');
        return;
    }
    gl.useProgram(program);
    gl.uniform4fv(uniformLocations.pos, uniformArrays.pos);
    gl.uniform4fv(uniformLocations.rotScale, uniformArrays.rotScale);
    gl.uniform4fv(uniformLocations.params, uniformArrays.params);
    uniformsDirty = false;
    dgLog('uploadUniforms applied', {
        vec4Count: {
            pos: uniformArrays.pos.length / 4,
            rotScale: uniformArrays.rotScale.length / 4,
            params: uniformArrays.params.length / 4
        }
    });
}

function updatePreviewUniforms() {
    markUniformsDirty();
}

function recompilePreview() {
    if (!gl || !dataShaderSource) return;
    if (!program) {
        program = createShaderProgram(dataShaderSource);
        if (!program) return;
        gl.useProgram(program);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        const positionAttrib = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionAttrib);
        gl.vertexAttribPointer(positionAttrib, 2, gl.FLOAT, false, 0, 0);
    } else {
        gl.useProgram(program);
    }
    if (resolutionUniform) {
        gl.uniform2f(resolutionUniform, gl.canvas.width, gl.canvas.height);
    }
    cacheUniformLocations();
    markDataGraphDirty();
    markUniformsDirty();
}

function renderPreview() {
    requestPreviewRender();
}

loadDataShader().then(() => init());
</script>
</body>
</html>