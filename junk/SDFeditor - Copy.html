<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="author" content="John Cotterell">
    <title>SDF Builder</title>
    <link href="https://fonts.googleapis.com/css?family=Abel|Quicksand:500|Source+Code+Pro" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        #rootnode {
            font-size: 20px;
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        .node {
            font-family: 'Quicksand', sans-serif;
            font-size: .9em;
            padding: 8px 12px;
            border: 2px solid #cccccc;
            border-radius: 5px;
            background: #eeeeee;
            position: absolute;
            z-index: 9;
            cursor: default;
            min-width: 80px;
            text-align: center;
        }

.node .detach-wrapper {
    position: absolute;
    top: -32px;
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 30px;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.35);
    border: 1px dashed rgba(197, 48, 48, 0.6);
    opacity: 0;
    pointer-events: auto;
}

.detach-wrapper .detach-handle {
    position: absolute;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    width: 22px;
    height: 22px;
    border-radius: 50%;
    border: 2px solid rgba(0, 0, 0, 0.25);
    background: #fff;
    color: #c53030;
    font-size: 13px;
    line-height: 22px;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    opacity: 0;
    pointer-events: auto;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
}

.detach-wrapper .detach-handle::selection {
    background: transparent;
}

.node .detach-wrapper:hover,
.detach-wrapper.force-visible,
.detach-wrapper:focus-within {
    opacity: 1;
    pointer-events: auto;
}

        .node.scene {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #5a67d8;
            color: white;
        }

        .node.operation {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-color: #ed64a6;
            color: white;
        }

        .node.modifier {
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
            border-color: #f6ad55;
            color: #2d3748;
        }

        .node.primitive {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border-color: #38b2ac;
            color: white;
        }

        .node.selected {
            box-shadow: 0 0 0 3px #ffcc00;
            background: rgba(255, 204, 0, 0.15);
        }

        .node.invalid {
            opacity: 0.5;
        }

        .nodetitle {
            font-weight: 500;
            pointer-events: none;
        }

        #sidebar {
            font-family: 'Abel', sans-serif;
            font-size: 16px;
            position: fixed;
            left: 0;
            top: 0;
            width: 200px;
            height: 100%;
            background: #2d3748;
            color: white;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 100;
        }

        #sidebar h3 {
            margin: 15px 0 10px 0;
            font-size: 14px;
            text-transform: uppercase;
            color: #a0aec0;
            border-bottom: 1px solid #4a5568;
            padding-bottom: 5px;
        }

        .menu-item {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            cursor: grab;
            transition: background 0.2s;
        }

        .menu-item:hover {
            background: #4a5568;
        }

        .menu-item.primitive {
            border-left: 3px solid #4facfe;
        }

        .menu-item.operation {
            border-left: 3px solid #f5576c;
        }

        .menu-item.modifier {
            border-left: 3px solid #f6ad55;
        }

        #paramPanel {
            font-family: 'Abel', sans-serif;
            position: fixed;
            right: 0;
            top: 0;
            width: 280px;
            height: 100%;
            background: #2d3748;
            color: white;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        #paramPanel.visible {
            display: block;
        }

        #paramPanel h3 {
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #4a5568;
        }

#paramPanel.disabled {
    opacity: 0.45;
    pointer-events: none;
}

#paramPanelNotice {
    display: none;
    font-size: 12px;
    color: #f6ad55;
    margin-bottom: 10px;
}

#paramPanel.disabled #paramPanelNotice {
    display: block;
}

.panel-placeholder {
    color: #a0aec0;
    font-style: italic;
    font-size: 12px;
}

        .param-group {
            margin-bottom: 15px;
        }

        .param-group label {
            display: block;
            font-size: 12px;
            color: #a0aec0;
            margin-bottom: 5px;
        }

        .param-group input[type="range"] {
            width: 100%;
            margin-bottom: 3px;
        }

        .param-group .value-display {
            font-size: 11px;
            color: #718096;
            text-align: right;
        }

        .param-section {
            margin-bottom: 20px;
        }

        .param-section-title {
            font-size: 13px;
            color: #ed64a6;
            margin-bottom: 10px;
            text-transform: uppercase;
}
#glCanvas {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#previewControls {
    position: fixed;
    right: 320px;
    bottom: 20px;
    background: rgba(250, 250, 250, 0.45);
    color: #f5f5f5;
    font-family: 'Abel', sans-serif;
    font-size: 13px;
    padding: 6px 12px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
    z-index: 120;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

#previewControls label {
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-size: 11px;
    color: #cbd5f5;
}

#previewControls input[type="range"] {
    width: 140px;
}

#previewControls .auto-toggle {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 12px;
    color: #cbd5f5;
}

#previewControls .mode-select {
    display: flex;
    flex-direction: column;
    gap: 2px;
    font-size: 11px;
}

#previewControls .mode-select span {
    text-transform: uppercase;
    color: #a0aec0;
    letter-spacing: 0.4px;
}

#previewControls select {
    background: rgba(255, 255, 255, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #111010;
    padding: 2px 8px;
    border-radius: 6px;
    font-size: 13px;
    outline: none;
}

#previewControls select:focus {
    background: rgba(254, 255, 255, 0.08);
    border-color: #9f7aea;
    box-shadow: 0 0 0 2px rgba(159, 122, 234, 0.25);
}

#previewControls .palette-control {
    min-width: 120px;
}

#previewControls .palette-select-wrapper {
    display: flex;
    align-items: center;
    gap: 6px;
}

.palette-swatch {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 1px solid rgba(255, 255, 255, 0.6);
    box-shadow: 0 0 4px rgba(0, 0, 0, 0.4);
}

.palette-swatch.disabled {
    opacity: 0.35;
}

.preview-fps {
    font-weight: 600;
    font-size: 13px;
    min-width: 70px;
    text-align: right;
}

        #recompileButton {
            position: fixed;
            top: 20px;
            right: 320px;
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 50%;
            background: #5a67d8;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
            transition: transform 0.1s ease, background 0.2s ease;
            z-index: 140;
        }

        #recompileButton:hover {
            background: #7f9cf5;
            transform: translateY(-2px);
        }

        #recompileButton:active {
            transform: translateY(0);
        }

#recompileButton:disabled {
    opacity: 0.4;
    cursor: default;
}
        #sidebarControls {
            margin-bottom: 20px;
        }

        #sidebarControls button {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-family: 'Abel', sans-serif;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }

        #sidebarControls #exportShader {
            background: #68d391;
            color: #1a202c;
        }

        #sidebarControls #exportShader:hover {
            background: #9ae6b4;
        }

        #recycleBin {
            position: absolute;
            left: calc(220px + 20px);
            bottom: 20px;
            width: 160px;
            height: 90px;
            border: 2px dashed rgba(255, 99, 71, 0.6);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: rgba(255, 99, 71, 0.6);
            background: rgba(255, 99, 71, 0.08);
            font-family: 'Abel', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 36px;
            transition: background 0.2s, transform 0.2s, border-color 0.2s;
            z-index: 80;
        }

        #recycleBin.active {
            background: rgba(255, 99, 71, 0.25);
            border-color: rgba(255, 255, 255, 0.9);
            transform: scale(1.05);
        }

        svg {
            position: absolute;
            pointer-events: none;
        }

        #drawing {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 5;
        }
    </style>
</head>
<body>

<div id="sidebar">
    <div id="sidebarControls">
        <button id="exportShader">Export Shadertoy</button>
    </div>
    <h3>Primitives</h3>
    <div class="menu-item primitive" data-type="Sphere">Sphere</div>
    <div class="menu-item primitive" data-type="Box">Box</div>
    <div class="menu-item primitive" data-type="Torus">Torus</div>
    <div class="menu-item primitive" data-type="Cylinder">Cylinder</div>
    <div class="menu-item primitive" data-type="Octahedron">Octahedron</div>
    <div class="menu-item primitive" data-type="Cone">Cone</div>
    <div class="menu-item primitive" data-type="RoundCone">Round Cone</div>
    <div class="menu-item primitive" data-type="VerticalCapsule">Vertical Capsule</div>
    <div class="menu-item primitive" data-type="CutHollowSphere">Cut Hollow Sphere</div>
    <div class="menu-item primitive" data-type="DeathStar">Death Star</div>
    <div class="menu-item primitive" data-type="VesicaSegment">Vesica Segment</div>
    
    <h3>Operations</h3>
    <div class="menu-item operation" data-type="opUnion">Union</div>
    <div class="menu-item operation" data-type="opSmoothUnion">Smooth Union</div>
    <div class="menu-item operation" data-type="opSubtraction">Subtraction</div>
    <div class="menu-item operation" data-type="opSmoothSubtraction">Smooth Subtract</div>
    <div class="menu-item operation" data-type="opIntersection">Intersection</div>
    <div class="menu-item operation" data-type="opSmoothIntersection">Smooth Intersect</div>
    <div class="menu-item operation" data-type="opXor">XOR</div>

    <h3>Modifiers</h3>
    <div class="menu-item modifier" data-type="opRound">Round (Bevel)</div>
    <div class="menu-item modifier" data-type="opOnion">Onion (Shell)</div>
    <div class="menu-item modifier" data-type="opTwist">Twist</div>
    <div class="menu-item modifier" data-type="opElongate">Elongate</div>
    <div class="menu-item modifier" data-type="opCheapBend">Cheap Bend</div>
    <div class="menu-item modifier" data-type="opSymX">Mirror X</div>
</div>

<div id="paramPanel">
    <h3 id="paramNodeName">Parameters</h3>
    <div id="paramPanelNotice">Recompile to edit parameters</div>
    <div id="paramContent"></div>
</div>

<div id="drawing"></div>
<div id="rootnode">
    <div class="node scene" id="scene" data-type="Scene" style="left: 50%; top: 5%;">
        <div class="nodetitle">Scene</div>
    </div>
</div>

<canvas id="glCanvas"></canvas>
<div id="recycleBin">
    <div>♻</div>
    <small>Recycle</small>
</div>
<div id="previewControls">
    <label for="pixelScaleSlider">Pixel size</label>
    <input type="range" id="pixelScaleSlider" min="0" max="4" step="1" value="0">
    <span id="pixelScaleLabel">1x</span>
    <label class="auto-toggle">
        <input type="checkbox" id="autoCompileToggle">
        Auto
    </label>
    <label class="auto-toggle">
        <input type="checkbox" id="orthoToggle">
        Ortho
    </label>
    <label class="auto-toggle">
        <input type="checkbox" id="outlineToggle">
        Outline
    </label>
    <div class="mode-select">
        <span>Outline Mode</span>
        <select id="outlineModeSelect">
            <option value="single">Single Pass</option>
            <option value="dual">Dual Pass</option>
        </select>
    </div>
    <div class="mode-select">
        <span>Main Steps</span>
        <input type="number" id="mainStepsInput" min="10" max="200" value="100" style="width: 60px;">
    </div>
    <div class="mode-select">
        <span>Outline Steps</span>
        <input type="number" id="outlineStepsInput" min="10" max="200" value="60" style="width: 60px;">
    </div>
    <div class="mode-select">
        <span>Color</span>
        <select id="colorModeSelect">
            <option value="color">Color</option>
            <option value="single">Single</option>
        </select>
    </div>
    <div class="mode-select palette-control">
        <span>Palette</span>
        <div class="palette-select-wrapper">
            <select id="paletteSelect"></select>
            <span class="palette-swatch" id="paletteSwatch"></span>
        </div>
    </div>
    <div class="mode-select">
        <span>Lighting</span>
        <select id="lightingModeSelect">
            <option value="normal">Normals</option>
            <option value="depth">Depth</option>
        </select>
    </div>
    <span class="preview-fps" id="previewFps">FPS: --</span>
</div>
<button id="recompileButton" title="Recompile Preview">⟳</button>

<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/2.7.1/svg.min.js"></script>
<script>
// Node type definitions
const NODE_TYPES = {
    Scene: {
        category: 'scene',
        maxChildren: 99,
        params: {}
    },
    Sphere: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            radius: { default: 0.5, min: 0.05, max: 3, step: 0.05 }
        }
    },
    Box: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            sizeX: { default: 0.5, min: 0.05, max: 3, step: 0.05 },
            sizeY: { default: 0.5, min: 0.05, max: 3, step: 0.05 },
            sizeZ: { default: 0.5, min: 0.05, max: 3, step: 0.05 }
        }
    },
    Torus: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            majorRadius: { default: 0.5, min: 0.1, max: 2, step: 0.05 },
            minorRadius: { default: 0.2, min: 0.05, max: 1, step: 0.05 }
        }
    },
    Cylinder: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            radius: { default: 0.3, min: 0.05, max: 2, step: 0.05 },
            height: { default: 1.0, min: 0.1, max: 5, step: 0.1 }
        }
    },
    Octahedron: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            size: { default: 0.75, min: 0.1, max: 3.0, step: 0.05 }
        }
    },
    Cone: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            height: { default: 1.5, min: 0.1, max: 5.0, step: 0.05 },
            angleDeg: { default: 45, min: 1, max: 89, step: 1 }
        }
    },
    RoundCone: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            radiusTop: { default: 0.4, min: 0.01, max: 3.0, step: 0.01 },
            radiusBottom: { default: 0.1, min: 0.01, max: 3.0, step: 0.01 },
            height: { default: 1.25, min: 0.1, max: 5.0, step: 0.05 }
        }
    },
    VerticalCapsule: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            height: { default: 1.0, min: 0.1, max: 5.0, step: 0.05 },
            radius: { default: 0.25, min: 0.01, max: 2.5, step: 0.01 }
        }
    },
    CutHollowSphere: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            radius: { default: 1.0, min: 0.1, max: 4.0, step: 0.05 },
            height: { default: 0.35, min: 0.0, max: 3.5, step: 0.05 },
            thickness: { default: 0.1, min: 0.001, max: 2.0, step: 0.01 }
        }
    },
    DeathStar: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            radiusA: { default: 1.0, min: 0.1, max: 5.0, step: 0.05 },
            radiusB: { default: 0.4, min: 0.05, max: 4.0, step: 0.05 },
            offset: { default: 0.6, min: 0.0, max: 5.0, step: 0.05 }
        }
    },
    VesicaSegment: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            ax: { default: -0.5, min: -3, max: 3, step: 0.1 },
            ay: { default: 0.0, min: -3, max: 3, step: 0.1 },
            az: { default: 0.0, min: -3, max: 3, step: 0.1 },
            bx: { default: 0.5, min: -3, max: 3, step: 0.1 },
            by: { default: 0.0, min: -3, max: 3, step: 0.1 },
            bz: { default: 0.0, min: -3, max: 3, step: 0.1 },
            width: { default: 0.25, min: 0.01, max: 3.0, step: 0.01 }
        }
    },
    opUnion: {
        category: 'operation',
        maxChildren: 2,
        params: {}
    },
    opSmoothUnion: {
        category: 'operation',
        maxChildren: 2,
        params: {
            k: { default: 0.3, min: 0.01, max: 1, step: 0.01 }
        }
    },
    opSubtraction: {
        category: 'operation',
        maxChildren: 2,
        params: {}
    },
    opSmoothSubtraction: {
        category: 'operation',
        maxChildren: 2,
        params: {
            k: { default: 0.3, min: 0.01, max: 1, step: 0.01 }
        }
    },
    opIntersection: {
        category: 'operation',
        maxChildren: 2,
        params: {}
    },
    opSmoothIntersection: {
        category: 'operation',
        maxChildren: 2,
        params: {
            k: { default: 0.3, min: 0.01, max: 1, step: 0.01 }
        }
    },
    opXor: {
        category: 'operation',
        maxChildren: 2,
        params: {}
    },
    opRound: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            roundRadius: { default: 0.1, min: 0.0, max: 1.0, step: 0.01 }
        }
    },
    opOnion: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            shellThickness: { default: 0.05, min: 0.0, max: 1.0, step: 0.01 }
        }
    },
    opTwist: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            twistAmount: { default: 2.0, min: -20.0, max: 20.0, step: 0.1 }
        }
    },
    opElongate: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            extentX: { default: 0.3, min: 0.0, max: 2.0, step: 0.05 },
            extentY: { default: 0.3, min: 0.0, max: 2.0, step: 0.05 },
            extentZ: { default: 0.3, min: 0.0, max: 2.0, step: 0.05 }
        }
    },
    opCheapBend: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            bendAmount: { default: 2.0, min: -20.0, max: 20.0, step: 0.1 }
        }
    },
    opSymX: {
        category: 'modifier',
        maxChildren: 1,
        params: {}
    }
};

const TRANSFORM_PARAMS = {
    posX: { default: 0, min: -5, max: 5, step: 0.1 },
    posY: { default: 0, min: -5, max: 5, step: 0.1 },
    posZ: { default: 0, min: -5, max: 5, step: 0.1 },
    rotX: { default: 0, min: -180, max: 180, step: 1 },
    rotY: { default: 0, min: -180, max: 180, step: 1 },
    rotZ: { default: 0, min: -180, max: 180, step: 1 },
    scale: { default: 1.0, min: 0.1, max: 5.0, step: 0.05 }
};

function hslToRgb(h, s, l) {
    const a = s * Math.min(l, 1 - l);
    const f = (n) => {
        const k = (n + h * 12) % 12;
        return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    };
    return {
        r: Math.round(f(0) * 255),
        g: Math.round(f(8) * 255),
        b: Math.round(f(4) * 255)
    };
}

function intToColorRGB(index) {
    const goldenRatio = 0.618033988749895;
    const hue = (index * goldenRatio) % 1;
    const saturation = 0.7 + (index % 3) * 0.1;
    const lightness = 0.45 + (index % 4) * 0.05;
    return hslToRgb(hue, Math.min(saturation, 1), Math.min(lightness, 1));
}

function rgbToCss({ r, g, b }, alpha = 1) {
    if (alpha === 1) {
        return `rgb(${r}, ${g}, ${b})`;
    }
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function mixColor(color, target, amount) {
    return {
        r: Math.round(color.r + (target.r - color.r) * amount),
        g: Math.round(color.g + (target.g - color.g) * amount),
        b: Math.round(color.b + (target.b - color.b) * amount)
    };
}

function lightenColor(color, amount) {
    return mixColor(color, { r: 255, g: 255, b: 255 }, amount);
}

function darkenColor(color, amount) {
    return mixColor(color, { r: 0, g: 0, b: 0 }, amount);
}

function getNodeColorIndex(node) {
    if (!node) return 0;
    if (node.dataset.colorIndex) {
        return Number(node.dataset.colorIndex);
    }
    const match = /(\d+)$/.exec(node.id || '');
    const index = match ? Number(match[1]) : nodesArray.indexOf(node);
    node.dataset.colorIndex = String(Math.max(0, index));
    return Number(node.dataset.colorIndex);
}

function getReadableTextColor(color) {
    const luminance = (0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b) / 255;
    return luminance > 0.6 ? '#1a202c' : '#f7fafc';
}

function applyNodeColor(node) {
    if (!node || node.dataset.type === 'Scene') return;
    const index = getNodeColorIndex(node);
    const base = intToColorRGB(index);
    const gradientStart = lightenColor(base, node.classList.contains('operation') ? 0.05 : 0.2);
    const gradientEnd = darkenColor(base, 0.15);
    node.style.background = `linear-gradient(135deg, ${rgbToCss(gradientStart)} 0%, ${rgbToCss(gradientEnd)} 100%)`;
    node.style.borderColor = rgbToCss(darkenColor(base, 0.35));
    node.style.color = getReadableTextColor(base);
}

function getNodeParams(node) {
    if (node._sdfParams) return node._sdfParams;
    const parsed = node.dataset.params ? JSON.parse(node.dataset.params) : {};
    node._sdfParams = parsed;
    return parsed;
}

function setNodeParams(node, params) {
    node._sdfParams = params;
    node.dataset.params = JSON.stringify(params);
}

function ensureDetachHandle(node) {
    if (node.dataset.type === 'Scene') return;
    if (!node.querySelector('.detach-wrapper')) {
        const wrapper = document.createElement('div');
        wrapper.className = 'detach-wrapper';
        wrapper.textContent = '×';
        const handle = document.createElement('div');
        handle.className = 'detach-handle';
        handle.textContent = '×';
        wrapper.appendChild(handle);
        node.appendChild(wrapper);
    }
    attachNodeHoverHandlers(node);
    attachDetachWrapperHandlers(node);
}

// State
let dragging = false;
let dragged = null;
let detached = false;
let dragFromMenu = false;
let pos1, pos2, pos3, pos4;
let selectedNode = null;
let nodeCounter = 0;

let dropPreview = null;
let currentDropTarget = null;

const draw = SVG('drawing').size('100%', '100%');
let nodesArray = [];
let lines = [];
const recycleBin = document.getElementById('recycleBin');
const recycleRect = () => recycleBin.getBoundingClientRect();
let recycleActive = false;
const pixelScaleSlider = document.getElementById('pixelScaleSlider');
const pixelScaleLabel = document.getElementById('pixelScaleLabel');
const recompileButton = document.getElementById('recompileButton');
const autoCompileToggle = document.getElementById('autoCompileToggle');
const orthoToggle = document.getElementById('orthoToggle');
const outlineToggle = document.getElementById('outlineToggle');
const outlineModeSelect = document.getElementById('outlineModeSelect');
const mainStepsInput = document.getElementById('mainStepsInput');
const outlineStepsInput = document.getElementById('outlineStepsInput');
const colorModeSelect = document.getElementById('colorModeSelect');
const paletteSelect = document.getElementById('paletteSelect');
const paletteSwatch = document.getElementById('paletteSwatch');
const lightingModeSelect = document.getElementById('lightingModeSelect');
const previewFpsDisplay = document.getElementById('previewFps');
const paramPanel = document.getElementById('paramPanel');
const paramPanelNotice = document.getElementById('paramPanelNotice');
const paramNodeName = document.getElementById('paramNodeName');
const paramContent = document.getElementById('paramContent');

// Outline state
let outlineEnabled = false;
let outlineMode = 'single'; // 'single' or 'dual'
let mainRaymarchSteps = 100;
let outlineRaymarchSteps = 60;

// Camera state for preview orbit controls
const CAMERA_STATE = {
    yaw: 0,
    pitch: 0,
    distance: 4,
    target: { x: 0, y: 0, z: 0 }
};
let cameraUniformLocations = { pos: null, target: null };
let cameraDragMode = null;
let cameraLastX = 0;
let cameraLastY = 0;

// Simple performance logger (toggle via window.SDF_PERF.enabled)
const SDF_PERF = {
    enabled: false
};

function perfNow() {
    return performance.now();
}

function perfLogDuration(label, startTime, extra = '') {
    return startTime;
}

function perfLogInfo(label, info) {
}

window.SDF_PERF = SDF_PERF;

// WebGL state
let gl, program;
let uniformLocations = {};
let vertexBuffer = null;
const pendingSliderUpdates = new Map();
let sliderFlushHandle = null;

const PREVIEW_PIXEL_SCALES = [1, 2, 4, 8, 16];
const COLOR_MODES = { COLOR: 'color', SINGLE: 'single' };
const LIGHTING_MODES = { NORMAL: 'normal', DEPTH: 'depth' };
const PALETTE_OPTIONS = Array.from({ length: 10 }, (_, idx) => idx);
let previewScaleIndex = 0;
let graphDirty = false;
let autoCompile = false;
let autoCompilePending = false;
let currentParamNode = null;
let paramControlsEnabled = true;
let orthographicMode = false;
const renderModeState = {
    colorMode: COLOR_MODES.COLOR,
    lightingMode: LIGHTING_MODES.NORMAL,
    paletteIndex: 0
};
let previewAnimationHandle = null;
let lastFrameTimestamp = 0;
let smoothedFps = 0;
let lastFpsUpdate = 0;

function updateRecompileButtonState() {
    if (!recompileButton) return;
    recompileButton.disabled = !graphDirty;
}

function initRenderModeControls() {
    if (colorModeSelect) {
        colorModeSelect.value = renderModeState.colorMode;
        colorModeSelect.addEventListener('change', (event) => {
            renderModeState.colorMode = event.target.value === COLOR_MODES.SINGLE ? COLOR_MODES.SINGLE : COLOR_MODES.COLOR;
            updateRenderModeControlState();
            applyRenderModeUniforms();
        });
    }
    if (paletteSelect) {
        PALETTE_OPTIONS.forEach(index => {
            const option = document.createElement('option');
            option.value = String(index);
            option.textContent = `Color ${index + 1}`;
            paletteSelect.appendChild(option);
        });
        paletteSelect.value = String(renderModeState.paletteIndex);
        paletteSelect.addEventListener('change', (event) => {
            const next = parseInt(event.target.value, 10);
            renderModeState.paletteIndex = Number.isFinite(next) ? Math.max(0, next) : 0;
            updatePaletteSwatch();
            applyRenderModeUniforms();
        });
        updatePaletteSwatch();
    }
    if (lightingModeSelect) {
        lightingModeSelect.value = renderModeState.lightingMode;
        lightingModeSelect.addEventListener('change', (event) => {
            renderModeState.lightingMode = event.target.value === LIGHTING_MODES.DEPTH ? LIGHTING_MODES.DEPTH : LIGHTING_MODES.NORMAL;
            applyRenderModeUniforms();
        });
    }
    updateRenderModeControlState();
}

function updateRenderModeControlState() {
    if (paletteSelect) {
        paletteSelect.disabled = renderModeState.colorMode === COLOR_MODES.COLOR;
    }
    if (paletteSwatch) {
        paletteSwatch.classList.toggle('disabled', renderModeState.colorMode === COLOR_MODES.COLOR);
    }
}

function updatePaletteSwatch() {
    if (!paletteSwatch) return;
    const rgb = intToColorRGB(renderModeState.paletteIndex);
    paletteSwatch.style.backgroundColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
}

function setParamControlsEnabled(enabled) {
    paramControlsEnabled = enabled;
    if (paramPanel) {
        paramPanel.classList.toggle('disabled', !enabled);
    }
    const sliders = paramPanel ? paramPanel.querySelectorAll('input[type="range"]') : [];
    sliders.forEach(slider => {
        slider.disabled = !enabled;
    });
}

function ensureValidParamNode(node) {
    if (node && document.body.contains(node) && node.dataset.type !== 'Scene') {
        return node;
    }
    return null;
}

function getFirstEditableNode() {
    if (nodesArray.length) {
        for (const node of nodesArray) {
            if (node && node.dataset && node.dataset.type && node.dataset.type !== 'Scene') {
                return node;
            }
        }
    }
    const root = document.getElementById('rootnode');
    if (!root) return null;
    return root.querySelector('.node:not(#scene)');
}

function scheduleAutoCompile() {
    if (autoCompilePending) return;
    autoCompilePending = true;
    requestAnimationFrame(() => {
        autoCompilePending = false;
        if (autoCompile && graphDirty) {
            recompilePreview();
        }
    });
}

function handleGraphChanged() {
    graphDirty = true;
    updateRecompileButtonState();
    pendingSliderUpdates.clear();
    currentParamNode = ensureValidParamNode(currentParamNode);
    setParamControlsEnabled(false);
    if (autoCompile) {
        scheduleAutoCompile();
    }
}

function renderCurrentParamPanel() {
    if (!paramPanel || !paramContent || !paramNodeName) return;
    paramPanel.classList.add('visible');
    let node = ensureValidParamNode(currentParamNode);
    if (!node) {
        currentParamNode = null;
        paramNodeName.textContent = 'Parameters';
        paramContent.innerHTML = `<div class="panel-placeholder">Select a node to edit parameters.</div>`;
        return;
    }
    currentParamNode = node;
    const nodeType = node.dataset.type;
    const typeDef = NODE_TYPES[nodeType];
    const params = getNodeParams(node);
    paramNodeName.textContent = nodeType;
    paramContent.innerHTML = '';
    if (typeDef && typeDef.params && Object.keys(typeDef.params).length > 0) {
        const section = document.createElement('div');
        section.className = 'param-section';
        section.innerHTML = '<div class="param-section-title">Shape Parameters</div>';
        for (const [key, def] of Object.entries(typeDef.params)) {
            section.appendChild(createParamSlider(node, key, def, params[key]));
        }
        paramContent.appendChild(section);
    }
    const transformSection = document.createElement('div');
    transformSection.className = 'param-section';
    transformSection.innerHTML = '<div class="param-section-title">Transform</div>';
    for (const [key, def] of Object.entries(TRANSFORM_PARAMS)) {
        transformSection.appendChild(createParamSlider(node, key, def, params[key]));
    }
    paramContent.appendChild(transformSection);
}

// Initialize
function init() {
    scanNodes();
    addLines();
    initializeNodeParams();
    setupEventListeners();
    if (paramPanel) {
        paramPanel.classList.add('visible');
    }
    currentParamNode = getFirstEditableNode();
    renderCurrentParamPanel();
    setParamControlsEnabled(true);
    updateRecompileButtonState();
    if (pixelScaleSlider) {
        const initial = parseInt(pixelScaleSlider.value, 10);
        previewScaleIndex = Math.max(0, Math.min(PREVIEW_PIXEL_SCALES.length - 1, isNaN(initial) ? 0 : initial));
    } else {
        previewScaleIndex = 0;
    }
    updatePixelScaleLabel();
    initRenderModeControls();
    initWebGL();
    applyPreviewScale();
    recompilePreview();
}

function scanNodes() {
    const nodesObject = document.getElementsByClassName("node");
    nodesArray = [];
    for (let i = 0; i < nodesObject.length; i++) {
        nodesArray.push(nodesObject[i]);
        if (!nodesObject[i].id || nodesObject[i].id === '') {
            nodesObject[i].id = 'node_' + nodeCounter++;
        }
        ensureDetachHandle(nodesObject[i]);
        applyNodeColor(nodesObject[i]);
    }
}

function initializeNodeParams() {
    nodesArray.forEach(node => {
        if (!node.dataset.params) {
            const nodeType = node.dataset.type;
            const typeDef = NODE_TYPES[nodeType];
            const params = {};
            
            if (typeDef && typeDef.params) {
                for (const [key, val] of Object.entries(typeDef.params)) {
                    params[key] = val.default;
                }
            }
            
            if (nodeType !== 'Scene') {
                for (const [key, val] of Object.entries(TRANSFORM_PARAMS)) {
                    params[key] = val.default;
                }
            }
            
            setNodeParams(node, params);
        } else {
            node._sdfParams = JSON.parse(node.dataset.params);
        }
    });
}

function addLines() {
    for (let i = 0; i < nodesArray.length; i++) {
        addLine(i);
    }
}

function addLine(num) {
    const node = nodesArray[num];
    const box1 = node.getBoundingClientRect();
    const box2 = node.parentNode.getBoundingClientRect();
    const x1 = box1.left + (box1.width / 2);
    const y1 = box1.top + (box1.height / 2);
    const x2 = box2.left + (box2.width / 2);
    const y2 = box2.top + (box2.height / 2);
    
    if (lines[num]) {
        lines[num].plot([['M', x1, y1], ['C', x1, y2, x2, y1, x2, y2]]);
    } else {
        lines[num] = draw.path([['M', x1, y1], ['C', x1, y2, x2, y1, x2, y2]])
            .fill('none')
            .stroke({ width: 2, color: "#888888" });
    }
    
    if (!node.parentNode.classList.contains("node")) {
        lines[num].hide();
    } else {
        lines[num].show();
    }
}
function generateShadertoyShader() {
    const sdfCode = generateExportGLSL();
    
    return `// Generated with SDF Builder
// Paste into Shadertoy

${sdfCode}

vec3 calcNormal(vec3 p) {
    vec2 e = vec2(0.001, 0.0);
    return normalize(vec3(
        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),
        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),
        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)
    ));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    
    vec3 ro = vec3(0.0, 0.0, 3.0);
    vec3 rd = normalize(vec3(uv, -1.0));
    
    float t = 0.0;
    vec3 col = vec3(1.0);
    
    for (int i = 0; i < 100; i++) {
        vec3 p = ro + rd * t;
        float d = sceneSDF(p);
        
        if (d < 0.001) {
            vec3 n = calcNormal(p);
            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
            float diff = max(dot(n, lightDir), 0.0);
            float amb = 0.3;
            col = vec3(0.85, 0.75, 0.7) * (diff + amb);
            break;
        }
        
        if (t > 20.0) break;
        t += d;
    }
    
    fragColor = vec4(col, 1.0);
}
`;
}

function downloadShadertoyShader() {
    const shaderCode = generateShadertoyShader();
    const blob = new Blob([shaderCode], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'sdf_shader.glsl';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
function updateLine(node) {
    const nodeIndex = nodesArray.indexOf(node);
    if (nodeIndex >= 0) {
        addLine(nodeIndex);
    }
    
    const children = node.querySelectorAll('.node');
    children.forEach(child => {
        const childIndex = nodesArray.indexOf(child);
        if (childIndex >= 0) {
            addLine(childIndex);
        }
    });
}

function setupEventListeners() {
    document.addEventListener('mousedown', onDocumentMouseDown, false);
    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('mouseup', onDocumentMouseUp, false);
    document.addEventListener('contextmenu', e => e.preventDefault(), false);
    
    window.addEventListener('resize', () => {
        updateLine(document.getElementById("rootnode"));
        applyPreviewScale();
    }, false);
    
    document.querySelectorAll('.menu-item').forEach(item => {
        item.addEventListener('mousedown', onMenuItemMouseDown, false);
    });
    
    document.getElementById('exportShader').addEventListener('click', () => {
    // Try to copy to clipboard first
    const shaderCode = generateShadertoyShader();
    
    if (navigator.clipboard) {
        navigator.clipboard.writeText(shaderCode).then(() => {
            alert('Shadertoy shader copied to clipboard!');
        }).catch(() => {
            // Fallback to download
            downloadShadertoyShader();
        });
    } else {
        // Fallback to download
        downloadShadertoyShader();
    }
});

    document.addEventListener('mousedown', onDetachHandleMouseDown);
    document.addEventListener('wheel', handleCameraWheel, { passive: false });
    if (pixelScaleSlider) {
        pixelScaleSlider.addEventListener('input', handlePixelScaleInput);
    }
    if (recompileButton) {
        recompileButton.addEventListener('click', () => {
            if (graphDirty) {
                recompilePreview();
            }
        });
    }
    if (autoCompileToggle) {
        autoCompileToggle.addEventListener('change', (event) => {
            autoCompile = !!event.target.checked;
            if (autoCompile && graphDirty) {
                scheduleAutoCompile();
            }
        });
        autoCompile = !!autoCompileToggle.checked;
    }
    if (orthoToggle) {
        orthoToggle.addEventListener('change', (event) => {
            orthographicMode = !!event.target.checked;
            updatePreviewUniforms();
        });
        orthographicMode = !!orthoToggle.checked;
    }
    if (outlineToggle) {
        outlineToggle.addEventListener('change', (event) => {
            outlineEnabled = !!event.target.checked;
            updatePreviewUniforms();
        });
        outlineEnabled = !!outlineToggle.checked;
    }
    if (outlineModeSelect) {
        outlineModeSelect.addEventListener('change', (event) => {
            outlineMode = event.target.value;
            updatePreviewUniforms();
        });
        outlineMode = outlineModeSelect.value;
    }
    if (mainStepsInput) {
        mainStepsInput.addEventListener('change', (event) => {
            mainRaymarchSteps = parseInt(event.target.value);
            updatePreviewUniforms(); // Update via uniform, no recompile needed
        });
        mainRaymarchSteps = parseInt(mainStepsInput.value);
    }
    if (outlineStepsInput) {
        outlineStepsInput.addEventListener('change', (event) => {
            outlineRaymarchSteps = parseInt(event.target.value);
            updatePreviewUniforms(); // Update via uniform, no recompile needed
        });
        outlineRaymarchSteps = parseInt(outlineStepsInput.value);
    }
}

function onMenuItemMouseDown(event) {
    event.preventDefault();
    const nodeType = event.target.dataset.type;
    
    const newNode = createNode(nodeType);
    document.getElementById("rootnode").appendChild(newNode);
    nodesArray.push(newNode);
    
    newNode.style.left = event.clientX - 50 + "px";
    newNode.style.top = event.clientY - 15 + "px";
    
    addLine(nodesArray.length - 1);
    handleGraphChanged();
    
    pos3 = event.clientX;
    pos4 = event.clientY;
    newNode.dataset.dragOffsetX = 50;
    newNode.dataset.dragOffsetY = 15;
    dragging = true;
    dragged = newNode;
    detached = true;
    dragFromMenu = true;
}

function createNode(nodeType) {
    const typeDef = NODE_TYPES[nodeType];
    const newNode = document.createElement("DIV");
    const newText = document.createElement("DIV");
    const detachWrapper = document.createElement('div');
    const detachHandle = document.createElement('div');
    
    newText.className = "nodetitle";
    newText.textContent = nodeType;
    
    newNode.className = "node " + typeDef.category;
    newNode.id = 'node_' + nodeCounter++;
    newNode.dataset.type = nodeType;
    
    const params = {};
    if (typeDef.params) {
        for (const [key, val] of Object.entries(typeDef.params)) {
            params[key] = val.default;
        }
    }
    for (const [key, val] of Object.entries(TRANSFORM_PARAMS)) {
        params[key] = val.default;
    }
    setNodeParams(newNode, params);
    
    if (nodeType !== 'Scene') {
        detachWrapper.className = 'detach-wrapper';
        detachWrapper.textContent = '×';
        detachHandle.className = 'detach-handle';
        detachHandle.textContent = '×';
        detachWrapper.appendChild(detachHandle);
        newNode.appendChild(detachWrapper);
    }
    attachNodeHoverHandlers(newNode);
    attachDetachWrapperHandlers(newNode);
    newNode.appendChild(newText);
    applyNodeColor(newNode);
    return newNode;
}

function attachNodeHoverHandlers(node) {
    if (node.dataset.type === 'Scene' || node._hoverHandlersAttached) return;
    node.addEventListener('mouseover', handleNodeMouseOver);
    node.addEventListener('mouseout', handleNodeMouseOut);
    node._hoverHandlersAttached = true;
}

function attachDetachWrapperHandlers(node) {
    if (node.dataset.type === 'Scene') return;
    const wrapper = node.querySelector('.detach-wrapper');
    if (!wrapper || wrapper._hoverHandlersAttached) return;
    wrapper.addEventListener('mouseenter', () => {
        node.classList.add('node-hover');
    });
    wrapper.addEventListener('mouseleave', (event) => {
        const related = event.relatedTarget;
        if (related && (node.contains(related) || wrapper.contains(related))) return;
        node.classList.remove('node-hover');
    });
    wrapper._hoverHandlersAttached = true;
}

function handleNodeMouseOver(event) {
    if (event.target !== event.currentTarget) return;
    event.currentTarget.classList.add('node-hover');
    const wrapper = event.currentTarget.querySelector('.detach-wrapper');
    if (wrapper) {
        wrapper.setAttribute('aria-label', 'Click to detach and drag this node');
    }
}

function handleNodeMouseOut(event) {
    if (event.target !== event.currentTarget) return;
    const related = event.relatedTarget;
    if (related && event.currentTarget.contains(related)) return;
    event.currentTarget.classList.remove('node-hover');
    const wrapper = event.currentTarget.querySelector('.detach-wrapper');
    if (wrapper) {
        wrapper.removeAttribute('aria-label');
    }
}

function getCameraPosition() {
    const dist = Math.max(0.5, CAMERA_STATE.distance);
    const cosPitch = Math.cos(CAMERA_STATE.pitch);
    const sinPitch = Math.sin(CAMERA_STATE.pitch);
    const cosYaw = Math.cos(CAMERA_STATE.yaw);
    const sinYaw = Math.sin(CAMERA_STATE.yaw);
    return {
        x: CAMERA_STATE.target.x + dist * cosPitch * sinYaw,
        y: CAMERA_STATE.target.y + dist * sinPitch,
        z: CAMERA_STATE.target.z + dist * cosPitch * cosYaw
    };
}

function getCameraBasis() {
    const pos = getCameraPosition();
    const target = CAMERA_STATE.target;
    let forward = normalizeVector({
        x: target.x - pos.x,
        y: target.y - pos.y,
        z: target.z - pos.z
    });
    let right = normalizeVector(crossVector(forward, { x: 0, y: 1, z: 0 }));
    if (lengthVector(right) < 0.001) {
        right = { x: 1, y: 0, z: 0 };
    }
    const up = normalizeVector(crossVector(right, forward));
    return { forward, right, up };
}

function updateCameraUniforms() {
    if (!gl || !program || !cameraUniformLocations.pos || !cameraUniformLocations.target) return;
    const pos = getCameraPosition();
    gl.uniform3f(cameraUniformLocations.pos, pos.x, pos.y, pos.z);
    gl.uniform3f(cameraUniformLocations.target, CAMERA_STATE.target.x, CAMERA_STATE.target.y, CAMERA_STATE.target.z);
    const distLoc = uniformLocations['u_cameraDistance'];
    if (distLoc) {
        gl.uniform1f(distLoc, CAMERA_STATE.distance);
    }
}

function beginCameraDrag(mode, x, y) {
    cameraDragMode = mode;
    cameraLastX = x;
    cameraLastY = y;
    document.body.style.cursor = mode === 'pan' ? 'move' : 'grab';
}

function updateCameraDrag(x, y) {
    if (!cameraDragMode) return;
    const dx = x - cameraLastX;
    const dy = y - cameraLastY;
    cameraLastX = x;
    cameraLastY = y;
    const { right, up } = getCameraBasis();
    if (cameraDragMode === 'orbit') {
        CAMERA_STATE.yaw -= dx * 0.005;
        CAMERA_STATE.pitch = clamp(CAMERA_STATE.pitch + dy * 0.003, -1.4, 1.4);
    } else if (cameraDragMode === 'pan') {
        const panScale = CAMERA_STATE.distance * 0.002;
        CAMERA_STATE.target.x -= (dx * panScale) * right.x;
        CAMERA_STATE.target.y -= (dx * panScale) * right.y;
        CAMERA_STATE.target.z -= (dx * panScale) * right.z;
        CAMERA_STATE.target.x += (dy * panScale) * up.x;
        CAMERA_STATE.target.y += (dy * panScale) * up.y;
        CAMERA_STATE.target.z += (dy * panScale) * up.z;
    }
        updateCameraUniforms();
        renderPreview();
}

function endCameraDrag() {
    cameraDragMode = null;
    document.body.style.cursor = '';
}

function handleCameraWheel(event) {
    if (!isStageInteractionTarget(event.target)) return;
    event.preventDefault();
    const zoomFactor = Math.exp(event.deltaY * 0.001);
    CAMERA_STATE.distance = clamp(CAMERA_STATE.distance * zoomFactor, 0.8, 50);
    updateCameraUniforms();
    renderPreview();
}

function isStageInteractionTarget(target) {
    if (!target) return false;
    return !(
        target.closest('#sidebar') ||
        target.closest('#paramPanel') ||
        target.closest('.node') ||
        target.closest('.menu-item') ||
        target.closest('#sidebarControls') ||
        target.closest('#recycleBin') ||
        target.closest('.detach-wrapper')
    );
}

function normalizeVector(v) {
    const len = lengthVector(v);
    if (len < 1e-6) return { x: 0, y: 0, z: 0 };
    return { x: v.x / len, y: v.y / len, z: v.z / len };
}

function lengthVector(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

function crossVector(a, b) {
    return {
        x: a.y * b.z - a.z * b.y,
        y: a.z * b.x - a.x * b.z,
        z: a.x * b.y - a.y * b.x
    };
}

function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

function getNodeChildren(node) {
    return Array.from(node.children).filter(child => child.classList.contains('node'));
}

function canAcceptChild(parentNode) {
    const parentType = parentNode.dataset.type;
    const typeDef = NODE_TYPES[parentType];
    if (!typeDef) return false;
    
    const currentChildren = getNodeChildren(parentNode);
    return currentChildren.length < typeDef.maxChildren;
}

function attachNodeToParent(child, parent) {
    if (!canAcceptChild(parent)) {
        document.getElementById("rootnode").appendChild(child);
        positionNodeAtPoint(child, pos3, pos4);
        return false;
    }
    
    reparentNodePreservingPosition(child, parent);
    updateLine(child);
    handleGraphChanged();
    return true;
}

function reparentNodePreservingPosition(node, newParent) {
    const nodeRect = node.getBoundingClientRect();
    const parentRect = newParent.getBoundingClientRect();
    newParent.appendChild(node);
    node.style.left = `${nodeRect.left - parentRect.left}px`;
    node.style.top = `${nodeRect.top - parentRect.top}px`;
}

function positionNodeAtPoint(node, clientX, clientY) {
    const parent = node.parentNode || document.getElementById('rootnode');
    const parentRect = parent.getBoundingClientRect();
    const offsetX = Number(node.dataset.dragOffsetX ?? node.offsetWidth / 2);
    const offsetY = Number(node.dataset.dragOffsetY ?? node.offsetHeight / 2);
    node.style.left = `${clientX - parentRect.left - offsetX}px`;
    node.style.top = `${clientY - parentRect.top - offsetY}px`;
}

function detachNodeToRoot(node) {
    const root = document.getElementById('rootnode');
    reparentNodePreservingPosition(node, root);
    updateLine(node);
    handleGraphChanged();
}

function onDetachHandleMouseDown(event) {
    const wrapper = event.target.closest('.detach-wrapper');
    if (!wrapper) return;
    event.preventDefault();
    event.stopPropagation();
    const node = wrapper.closest('.node');
    if (!node || node.dataset.type === 'Scene') return;
    detachNodeToRoot(node);
    pos3 = event.clientX;
    pos4 = event.clientY;
    selectNode(node);
    startNodeDrag(node);
}

function selectNode(node) {
    if (selectedNode) {
        selectedNode.classList.remove('selected');
    }
    
    if (node && node.dataset.type !== 'Scene') {
        selectedNode = node;
        node.classList.add('selected');
        showParamPanel(node);
    } else {
        selectedNode = null;
        renderCurrentParamPanel();
    }
    
    // Update outline selection in shader (works in refresh mode without recompile!)
    if (outlineEnabled && program) {
        applyRenderModeUniforms();
    }
}

function showParamPanel(node) {
    if (node && node.dataset.type !== 'Scene') {
        currentParamNode = node;
    }
    renderCurrentParamPanel();
}

function createParamSlider(node, key, def, value) {
    const group = document.createElement('div');
    group.className = 'param-group';
    
    const label = document.createElement('label');
    label.textContent = key;
    
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = def.min;
    slider.max = def.max;
    slider.step = def.step;
    slider.value = value;
    slider.disabled = !paramControlsEnabled;
    
    const valueDisplay = document.createElement('div');
    valueDisplay.className = 'value-display';
    valueDisplay.textContent = value.toFixed(2);
    
    slider.addEventListener('input', () => {
        const numericValue = parseFloat(slider.value);
        valueDisplay.textContent = numericValue.toFixed(2);
        queueSliderUpdate(node, key, numericValue);
    });
    
    group.appendChild(label);
    group.appendChild(slider);
    group.appendChild(valueDisplay);
    
    return group;
}

function queueSliderUpdate(node, key, value) {
    if (!paramControlsEnabled) return;
    let entry = pendingSliderUpdates.get(node);
    if (!entry) {
        entry = { node, changes: {} };
        pendingSliderUpdates.set(node, entry);
    }
    entry.changes[key] = value;
    if (!sliderFlushHandle) {
        sliderFlushHandle = requestAnimationFrame(() => {
            sliderFlushHandle = null;
            flushPendingSliderUpdates();
        });
    }
}

function flushPendingSliderUpdates() {
    if (!pendingSliderUpdates.size) return;
    pendingSliderUpdates.forEach(({ node, changes }) => {
        const params = getNodeParams(node);
        Object.assign(params, changes);
        setNodeParams(node, params);
    });
    pendingSliderUpdates.clear();
    updatePreviewUniforms();
}

function getPreviewScale() {
    return PREVIEW_PIXEL_SCALES[previewScaleIndex] || 1;
}

function updatePixelScaleLabel() {
    if (!pixelScaleLabel) return;
    pixelScaleLabel.textContent = `${getPreviewScale()}x`;
}

function applyPreviewScale() {
    const canvas = document.getElementById('glCanvas');
    if (!canvas) return;
    const scale = getPreviewScale();
    canvas.width = Math.max(64, Math.floor(window.innerWidth / scale));
    canvas.height = Math.max(64, Math.floor(window.innerHeight / scale));
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    if (gl) {
        gl.viewport(0, 0, canvas.width, canvas.height);
        if (program) {
            gl.useProgram(program);
            const resLoc = gl.getUniformLocation(program, 'resolution');
            if (resLoc) {
                gl.uniform2f(resLoc, canvas.width, canvas.height);
            }
            renderPreview();
        }
    }
}

function handlePixelScaleInput(event) {
    const raw = parseInt(event.target.value, 10);
    const clamped = Math.max(0, Math.min(PREVIEW_PIXEL_SCALES.length - 1, isNaN(raw) ? 0 : raw));
    if (clamped === previewScaleIndex) return;
    previewScaleIndex = clamped;
    updatePixelScaleLabel();
    applyPreviewScale();
}

function onDocumentMouseDown(event) {
    const target = event.target;
    
    if (target.closest('.detach-wrapper')) {
        return;
    }
    
    if (target.closest('#sidebar') || target.closest('#paramPanel') || 
        target.closest('#glCanvas') ||
        target.closest('#previewControls') ||
        target.closest('#recompileButton')) {
        return;
    }
    
    if (target.classList.contains("node") || target.parentNode.classList.contains("node")) {
        event.preventDefault();
        const node = target.classList.contains("node") ? target : target.parentNode;
        
        pos3 = event.clientX;
        pos4 = event.clientY;
        
        selectNode(node);
        startNodeDrag(node);
    } else {
        // Don't deselect when clicking on stage for camera controls
        // selectNode(null);
        if (isStageInteractionTarget(target)) {
            if (event.button === 0) {
                beginCameraDrag('orbit', event.clientX, event.clientY);
            } else if (event.button === 2) {
                beginCameraDrag('pan', event.clientX, event.clientY);
            }
        } else {
            // Only deselect if clicking outside stage/canvas area
            selectNode(null);
        }
    }
}

function onDocumentMouseMove(event) {
    if (cameraDragMode) {
        event.preventDefault();
        updateCameraDrag(event.clientX, event.clientY);
        return;
    }
    if (dragging) {
        event.preventDefault();
        pos1 = pos3 - event.clientX;
        pos2 = pos4 - event.clientY;
        pos3 = event.clientX;
        pos4 = event.clientY;
        nodeDrag();
    }
}

function onDocumentMouseUp(event) {
    if (cameraDragMode) {
        event.preventDefault();
        endCameraDrag();
        return;
    }
    if (dragging) {
        event.preventDefault();
        
        if (detached) {
            const attached = finalizeDrop(event.clientX, event.clientY);
            if (!attached && dragged.parentNode.id === "rootnode") {
                positionNodeAtPoint(dragged, event.clientX, event.clientY);
                handleGraphChanged();
            }
        }
        
        clearDropPreview();
        stopNodeDrag();
    }
}

function startNodeDrag(node) {
    dragging = true;
    dragged = node;
    detached = node.parentNode.id === "rootnode";
    const rect = node.getBoundingClientRect();
    const offsetX = pos3 - rect.left;
    const offsetY = pos4 - rect.top;
    node.dataset.dragOffsetX = offsetX;
    node.dataset.dragOffsetY = offsetY;
}

function nodeDrag() {
    const parentRect = dragged.parentNode.getBoundingClientRect();
    dragged.style.left = `${pos3 - parentRect.left - dragged.dataset.dragOffsetX}px`;
    dragged.style.top = `${pos4 - parentRect.top - dragged.dataset.dragOffsetY}px`;
    updateLine(dragged);
    if (detached) {
        updateDropPreview();
    } else {
        clearDropPreview();
    }
    updateRecyclePreview();
}

function stopNodeDrag() {
    dragging = false;
    detached = false;
    dragFromMenu = false;
    dragged = null;
    clearDropPreview();
    clearRecyclePreview();
}

function isValidDropTarget(child, target) {
    if (!target || target === child) return false;
    if (!target.classList || !target.classList.contains('node')) return false;
    if (child.contains && child.contains(target)) return false;
    return canAcceptChild(target);
}

function getDropZoneRect(node) {
    const rect = node.getBoundingClientRect();
    const padding = 10;
    const width = rect.width * 1.2;
    const height = rect.height * 2.2;
    const centerX = rect.left + rect.width / 2;
    return {
        left: centerX - width / 2,
        right: centerX + width / 2,
        top: rect.bottom + padding,
        bottom: rect.bottom + padding + height,
        anchorX: centerX,
        anchorY: rect.top + rect.height / 2
    };
}

function findDropTarget(x, y) {
    for (const node of nodesArray) {
        if (!isValidDropTarget(dragged, node)) continue;
        const zone = getDropZoneRect(node);
        if (x >= zone.left && x <= zone.right && y >= zone.top && y <= zone.bottom) {
            return { node, zone };
        }
    }
    return null;
}

function getPreviewPathData(zone, pointerX, pointerY) {
    const midY = (zone.anchorY + pointerY) / 2;
    return [
        ['M', zone.anchorX, zone.anchorY],
        ['C', zone.anchorX, midY, pointerX, midY, pointerX, pointerY]
    ];
}

function updateDropPreview() {
    if (!dragged) return;
    const pointerX = pos3;
    const pointerY = pos4;
    if (!Number.isFinite(pointerX) || !Number.isFinite(pointerY)) return;
    
    const targetInfo = findDropTarget(pointerX, pointerY);
    if (!targetInfo) {
        clearDropPreview();
        return;
    }
    
    if (currentDropTarget === targetInfo.node) {
        if (dropPreview) {
            dropPreview.plot(getPreviewPathData(targetInfo.zone, pointerX, pointerY));
        }
        return;
    }
    
    currentDropTarget = targetInfo.node;
    const pathData = getPreviewPathData(targetInfo.zone, pointerX, pointerY);
    if (!dropPreview) {
        dropPreview = draw.path(pathData)
            .fill('none')
            .stroke({ width: 2, color: '#f6ad55', dasharray: '6 4', linecap: 'round' });
    } else {
        dropPreview.plot(pathData);
    }
}

function clearDropPreview() {
    if (dropPreview) {
        dropPreview.remove();
        dropPreview = null;
    }
    currentDropTarget = null;
}

function updateRecyclePreview() {
    if (!dragged) return;
    const rect = recycleRect();
    const inBin = pos3 >= rect.left && pos3 <= rect.right && pos4 >= rect.top && pos4 <= rect.bottom;
    if (inBin && !recycleActive) {
        recycleActive = true;
        recycleBin.classList.add('active');
    } else if (!inBin && recycleActive) {
        recycleActive = false;
        recycleBin.classList.remove('active');
    }
}

function clearRecyclePreview() {
    recycleActive = false;
    recycleBin.classList.remove('active');
}

function checkRecycleBin(clientX, clientY) {
    const rect = recycleRect();
    return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
}

function deleteNodeWithChildren(node) {
    if (!node || node.id === 'scene') return;
    if (selectedNode && (selectedNode === node || node.contains(selectedNode))) {
        selectNode(null);
    }
    node.remove();
    scanNodes();
    draw.clear();
    lines = [];
    dropPreview = null;
    currentDropTarget = null;
    addLines();
    handleGraphChanged();
}

function finalizeDrop(clientX, clientY) {
    if (checkRecycleBin(clientX, clientY)) {
        deleteNodeWithChildren(dragged);
        clearDropPreview();
        clearRecyclePreview();
        return true;
    }
    
    if (currentDropTarget && attachNodeToParent(dragged, currentDropTarget)) {
        clearDropPreview();
        clearRecyclePreview();
        return true;
    }
    
    dragged.hidden = true;
    const elemBelow = document.elementFromPoint(clientX, clientY);
    dragged.hidden = false;
    
    if (elemBelow) {
        let targetNode = null;
        if (elemBelow.classList.contains("node")) {
            targetNode = elemBelow;
        } else if (elemBelow.parentNode && elemBelow.parentNode.classList.contains("node")) {
            targetNode = elemBelow.parentNode;
        }
        
        if (isValidDropTarget(dragged, targetNode)) {
            clearDropPreview();
            clearRecyclePreview();
            return attachNodeToParent(dragged, targetNode);
        }
    }
    
    clearDropPreview();
    clearRecyclePreview();
    return false;
}

// Helper to traverse all nodes connected to scene
function traverseSceneNodes(callback) {
    const sceneNode = document.getElementById('scene');
    
    function traverse(node) {
        if (node.dataset.type !== 'Scene') {
            callback(node);
        }
        getNodeChildren(node).forEach(child => traverse(child));
    }
    
    traverse(sceneNode);
}

function getSceneStats() {
    const sceneNode = document.getElementById('scene');
    let count = 0;
    let depth = 0;
    
    function traverse(node, currentDepth) {
        if (node.dataset.type !== 'Scene') {
            count++;
            depth = Math.max(depth, currentDepth);
        }
        getNodeChildren(node).forEach(child => traverse(child, currentDepth + 1));
    }
    
    traverse(sceneNode, 0);
    return { nodeCount: count, maxDepth: depth };
}

function getNodeVarName(node) {
    return 'd_' + node.id.replace(/[^a-zA-Z0-9]/g, '_');
}

// ===========================================
// EXPORT GLSL - Hardcoded values (for output)
// ===========================================
function generateExportGLSL() {
    const t0 = perfNow();
    const sceneNode = document.getElementById('scene');
    const children = getNodeChildren(sceneNode);
    
    let code = getSDFPreamble();
    
    if (children.length === 0) {
        code += `float sceneSDF(vec3 p) {
    return 1000.0; // Empty scene
}`;
    } else if (children.length === 1) {
        code += `
float sceneSDF(vec3 p) {
${generateExportNodeCode(children[0], 'p')}
    return ${getNodeVarName(children[0])};
}`;
    } else {
        let nodeCode = '';
        children.forEach(child => {
            nodeCode += generateExportNodeCode(child, 'p');
        });
        
        let unionExpr = getNodeVarName(children[0]);
        for (let i = 1; i < children.length; i++) {
            unionExpr = `min(${unionExpr}, ${getNodeVarName(children[i])})`;
        }
        
        code += `
float sceneSDF(vec3 p) {
${nodeCode}
    return ${unionExpr};
}`;
    }
    
    const stats = getSceneStats();
    perfLogDuration('generateExportGLSL', t0, `nodes=${stats.nodeCount} depth=${stats.maxDepth}`);
    return code;
}

function generateExportNodeCode(node, pointVar) {
    const nodeType = node.dataset.type;
    const params = getNodeParams(node);
    const varName = getNodeVarName(node);
    const typeDef = NODE_TYPES[nodeType];
    
    let code = '';
    const transformedPoint = varName + '_p';
    const rad = Math.PI / 180;
    const scaleVar = `${varName}_scale`;
    
    code += `    vec3 ${transformedPoint} = ${pointVar};\n`;
    code += `    ${transformedPoint} -= vec3(${params.posX.toFixed(3)}, ${params.posY.toFixed(3)}, ${params.posZ.toFixed(3)});\n`;
    if (params.rotX !== 0) code += `    ${transformedPoint} *= rotateX(${(params.rotX * rad).toFixed(4)});\n`;
    if (params.rotY !== 0) code += `    ${transformedPoint} *= rotateY(${(params.rotY * rad).toFixed(4)});\n`;
    if (params.rotZ !== 0) code += `    ${transformedPoint} *= rotateZ(${(params.rotZ * rad).toFixed(4)});\n`;
    code += `    float ${scaleVar} = max(${params.scale.toFixed(3)}, 0.0001);\n`;
    code += `    ${transformedPoint} /= ${scaleVar};\n`;
    
    if (typeDef.category === 'primitive') {
        const distVar = `${varName}_dist`;
        const boundExpr = getPrimitiveBoundExpr(nodeType, params);
        const distExpr = getPrimitiveDistanceExpr(nodeType, transformedPoint, params);
        code += `    float ${distVar};\n`;
        if (boundExpr) {
            const skipVar = `${varName}_skip`;
            code += `    float ${skipVar} = length(${transformedPoint}) - (${boundExpr});\n`;
            code += `    if (${skipVar} > 2.0) {\n`;
            code += `        ${distVar} = ${skipVar};\n`;
            code += `    } else {\n`;
            code += `        ${distVar} = ${distExpr};\n`;
            code += `    }\n`;
        } else {
            code += `    ${distVar} = ${distExpr};\n`;
        }
        code += `    float ${varName} = ${distVar};\n`;
    } else if (typeDef.category === 'operation') {
        const children = getNodeChildren(node);
        
        if (children.length < 2) {
            code += `    float ${varName} = 1000.0; // Incomplete operation\n`;
        } else {
            code += generateExportNodeCode(children[0], transformedPoint);
            code += generateExportNodeCode(children[1], transformedPoint);
            
            const child1Var = getNodeVarName(children[0]);
            const child2Var = getNodeVarName(children[1]);
            
            switch (nodeType) {
                case 'opUnion':
                    code += `    float ${varName} = min(${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothUnion':
                    code += `    float ${varName} = opSmoothUnion(${child1Var}, ${child2Var}, ${params.k.toFixed(3)});\n`;
                    break;
                case 'opSubtraction':
                    code += `    float ${varName} = max(-${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothSubtraction':
                    code += `    float ${varName} = opSmoothSubtraction(${child1Var}, ${child2Var}, ${params.k.toFixed(3)});\n`;
                    break;
                case 'opIntersection':
                    code += `    float ${varName} = max(${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothIntersection':
                    code += `    float ${varName} = opSmoothIntersection(${child1Var}, ${child2Var}, ${params.k.toFixed(3)});\n`;
                    break;
                case 'opXor':
                    code += `    float ${varName} = opXor(${child1Var}, ${child2Var});\n`;
                    break;
        }
    }
    } else if (typeDef.category === 'modifier') {
        const children = getNodeChildren(node);
        if (children.length < 1) {
            code += `    float ${varName} = 1000.0; // Incomplete modifier\n`;
        } else {
            const child = children[0];
            const childVar = getNodeVarName(child);
            switch (nodeType) {
                case 'opRound':
                    code += generateExportNodeCode(child, transformedPoint);
                    code += `    float ${varName} = ${childVar} - ${params.roundRadius.toFixed(3)};\n`;
                    break;
                case 'opOnion':
                    code += generateExportNodeCode(child, transformedPoint);
                    code += `    float ${varName} = abs(${childVar}) - ${params.shellThickness.toFixed(3)};\n`;
                    break;
                case 'opTwist': {
                    const warpPoint = `${varName}_warp`;
                    const angleVar = `${varName}_angle`;
                    const matVar = `${varName}_mat`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    float ${angleVar} = ${params.twistAmount.toFixed(3)} * ${warpPoint}.y;\n`;
                    code += `    mat2 ${matVar} = mat2(cos(${angleVar}), -sin(${angleVar}), sin(${angleVar}), cos(${angleVar}));\n`;
                    code += `    ${warpPoint}.xz = ${matVar} * ${warpPoint}.xz;\n`;
                    code += generateExportNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
                case 'opElongate': {
                    const qVar = `${varName}_q`;
                    const clampVar = `${varName}_clamped`;
                    code += `    vec3 ${qVar} = abs(${transformedPoint}) - vec3(${params.extentX.toFixed(3)}, ${params.extentY.toFixed(3)}, ${params.extentZ.toFixed(3)});\n`;
                    code += `    vec3 ${clampVar} = max(${qVar}, vec3(0.0));\n`;
                    code += generateExportNodeCode(child, clampVar);
                    code += `    float ${varName} = ${childVar} + min(max(${qVar}.x, max(${qVar}.y, ${qVar}.z)), 0.0);\n`;
                    break;
                }
                case 'opCheapBend': {
                    const warpPoint = `${varName}_warp`;
                    const angleVar = `${varName}_angle`;
                    const matVar = `${varName}_mat`;
                    const rotated = `${varName}_rot`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    float ${angleVar} = ${params.bendAmount.toFixed(3)} * ${warpPoint}.x;\n`;
                    code += `    mat2 ${matVar} = mat2(cos(${angleVar}), -sin(${angleVar}), sin(${angleVar}), cos(${angleVar}));\n`;
                    code += `    vec2 ${rotated} = ${matVar} * ${warpPoint}.xy;\n`;
                    code += `    ${warpPoint}.xy = ${rotated};\n`;
                    code += generateExportNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
                case 'opSymX': {
                    const warpPoint = `${varName}_warp`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    ${warpPoint}.x = abs(${warpPoint}.x);\n`;
                    code += generateExportNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
            }
        }
    }
    
    code += `    ${varName} *= ${scaleVar};\n`;
    
    return code;
}

// ===========================================
// PREVIEW GLSL - Uniform-based (for live edit)
// ===========================================
// Global node-to-ID mapping
let nodeIdMap = new Map();
let nextNodeId = 1;

function generatePreviewGLSL() {
    const t0 = perfNow();
    const sceneNode = document.getElementById('scene');
    const children = getNodeChildren(sceneNode);
    
    let code = getSDFPreamble();
    code += '\nvec3 g_lastColor = vec3(0.25, 0.25, 0.3);\n';
    
    // Assign IDs to nodes and create ID constants
    nodeIdMap.clear();
    nextNodeId = 1;
    code += '\n// Node IDs\n';
    traverseSceneNodes(node => {
        const varName = getNodeVarName(node);
        const id = nextNodeId++;
        nodeIdMap.set(node, id);
        code += `const int ID_${varName} = ${id};\n`;
    });
    
    // Selection and outline tracking
    code += '\n// Selection tracking\n';
    code += 'uniform int u_selectedID;\n';
    code += 'uniform bool u_outlineEnabled;\n';
    code += 'int g_lastID = 0;\n';
    code += 'float distToSelected = 1e20;\n';
    code += 'float g_lastDepth = 0.0;\n'; // Track depth from object center for current surface
    
    // Generate uniform declarations
    code += '\n// Node uniforms\n';
    traverseSceneNodes(node => {
        const prefix = getNodeVarName(node);
        const nodeType = node.dataset.type;
        const typeDef = NODE_TYPES[nodeType];
        
        code += `uniform vec3 ${prefix}_pos;\n`;
        code += `uniform vec3 ${prefix}_rot;\n`;
        code += `uniform float ${prefix}_scale;\n`;
        
        if (typeDef.params) {
            for (const key of Object.keys(typeDef.params)) {
                code += `uniform float ${prefix}_${key};\n`;
            }
        }
    });
    
    code += '\n';
    
    if (children.length === 0) {
        code += `float sceneSDF(vec3 p) {
    g_lastColor = vec3(0.2, 0.2, 0.25);
    g_lastDepth = 0.0;
    return 1000.0; // Empty scene
}`;
    } else if (children.length === 1) {
        const childVar = getNodeVarName(children[0]);
        code += `
float sceneSDF(vec3 p) {
${generatePreviewNodeCode(children[0], 'p')}
    g_lastColor = ${childVar}_color;
    g_lastDepth = ${childVar}_depth;
    return ${getNodeVarName(children[0])};
}`;
    } else {
        let nodeCode = '';
        children.forEach(child => {
            nodeCode += generatePreviewNodeCode(child, 'p');
        });
        let unionExpr = getNodeVarName(children[0]);
        let unionColor = `${unionExpr}_color`;
        let unionDepth = `${unionExpr}_depth`;
        let unionCode = '';
        for (let i = 1; i < children.length; i++) {
            const nextVar = getNodeVarName(children[i]);
            const nextColor = `${nextVar}_color`;
            const nextDepth = `${nextVar}_depth`;
            const blendVar = `sceneBlend_${i}`;
            unionCode += `    float ${blendVar} = min(${unionExpr}, ${nextVar});\n`;
            unionCode += `    vec3 ${blendVar}_color = (${unionExpr} <= ${nextVar}) ? ${unionColor} : ${nextColor};\n`;
            unionCode += `    float ${blendVar}_depth = (${unionExpr} <= ${nextVar}) ? ${unionDepth} : ${nextDepth};\n`;
            unionExpr = blendVar;
            unionColor = `${blendVar}_color`;
            unionDepth = `${blendVar}_depth`;
        }
        code += `
float sceneSDF(vec3 p) {
${nodeCode}
${unionCode}
    g_lastColor = ${unionColor};
    g_lastDepth = ${unionDepth};
    return ${unionExpr};
}`;
    }
    
    const stats = getSceneStats();
    perfLogDuration('generatePreviewGLSL', t0, `nodes=${stats.nodeCount} depth=${stats.maxDepth}`);
    return code;
}

function getPrimitiveDistanceExpr(nodeType, pointVar, params) {
    switch (nodeType) {
        case 'Sphere':
            return `sdSphere(${pointVar}, ${Number(params.radius ?? 0.5).toFixed(3)})`;
        case 'Box':
            return `sdBox(${pointVar}, vec3(${Number(params.sizeX ?? 0.5).toFixed(3)}, ${Number(params.sizeY ?? 0.5).toFixed(3)}, ${Number(params.sizeZ ?? 0.5).toFixed(3)}))`;
        case 'Torus':
            return `sdTorus(${pointVar}, vec2(${Number(params.majorRadius ?? 0.5).toFixed(3)}, ${Number(params.minorRadius ?? 0.2).toFixed(3)}))`;
        case 'Cylinder':
            return `sdCylinder(${pointVar}, ${Number(params.radius ?? 0.3).toFixed(3)}, ${Number(params.height ?? 1.0).toFixed(3)})`;
        case 'Octahedron':
            return `sdOctahedron(${pointVar}, ${Number(params.size ?? 0.75).toFixed(3)})`;
        case 'Cone': {
            const height = Number(params.height ?? 1.5);
            const angleDeg = Number(params.angleDeg ?? 45);
            const angleRad = angleDeg * Math.PI / 180;
            const sinVal = Math.sin(angleRad);
            const cosVal = Math.cos(angleRad);
            return `sdCone(${pointVar}, vec2(${sinVal.toFixed(3)}, ${cosVal.toFixed(3)}), ${height.toFixed(3)})`;
        }
        case 'RoundCone': {
            const rTop = Number(params.radiusTop ?? 0.4);
            const rBottom = Number(params.radiusBottom ?? 0.1);
            const height = Number(params.height ?? 1.25);
            return `sdRoundCone(${pointVar}, ${rTop.toFixed(3)}, ${rBottom.toFixed(3)}, ${height.toFixed(3)})`;
        }
        case 'VerticalCapsule':
            return `sdVerticalCapsule(${pointVar}, ${Number(params.height ?? 1.0).toFixed(3)}, ${Number(params.radius ?? 0.25).toFixed(3)})`;
        case 'CutHollowSphere':
            return `sdCutHollowSphere(${pointVar}, ${Number(params.radius ?? 1.0).toFixed(3)}, ${Number(params.height ?? 0.35).toFixed(3)}, ${Number(params.thickness ?? 0.1).toFixed(3)})`;
        case 'DeathStar':
            return `sdDeathStar(${pointVar}, ${Number(params.radiusA ?? 1.0).toFixed(3)}, ${Number(params.radiusB ?? 0.4).toFixed(3)}, ${Number(params.offset ?? 0.6).toFixed(3)})`;
        case 'VesicaSegment': {
            const ax = Number(params.ax ?? -0.5).toFixed(3);
            const ay = Number(params.ay ?? 0.0).toFixed(3);
            const az = Number(params.az ?? 0.0).toFixed(3);
            const bx = Number(params.bx ?? 0.5).toFixed(3);
            const by = Number(params.by ?? 0.0).toFixed(3);
            const bz = Number(params.bz ?? 0.0).toFixed(3);
            const width = Number(params.width ?? 0.25).toFixed(3);
            return `sdVesicaSegment(${pointVar}, vec3(${ax}, ${ay}, ${az}), vec3(${bx}, ${by}, ${bz}), ${width})`;
        }
        default:
            return '1000.0';
    }
}

function getPrimitiveBoundExpr(nodeType, params) {
    switch (nodeType) {
        case 'Sphere':
            return `${Number(params.radius ?? 0.5).toFixed(3)}`;
        case 'Box': {
            const sx = Number(params.sizeX ?? 0.5);
            const sy = Number(params.sizeY ?? 0.5);
            const sz = Number(params.sizeZ ?? 0.5);
            const diag = Math.sqrt(sx * sx + sy * sy + sz * sz);
            return `${diag.toFixed(3)}`;
        }
        case 'Torus': {
            const major = Number(params.majorRadius ?? 0.5);
            const minor = Number(params.minorRadius ?? 0.2);
            return `${(major + minor).toFixed(3)}`;
        }
        case 'Cylinder': {
            const r = Number(params.radius ?? 0.3);
            const h = Number(params.height ?? 1.0);
            return `${Math.sqrt(r * r + h * h).toFixed(3)}`;
        }
        case 'Octahedron':
            return `${(Number(params.size ?? 0.75) * 1.5).toFixed(3)}`;
        case 'Cone': {
            const height = Number(params.height ?? 1.5);
            const angleDeg = Number(params.angleDeg ?? 45);
            const angleRad = angleDeg * Math.PI / 180;
            const baseRadius = Math.tan(angleRad) * height;
            return `${Math.sqrt(baseRadius * baseRadius + height * height).toFixed(3)}`;
        }
        case 'RoundCone': {
            const rTop = Number(params.radiusTop ?? 0.4);
            const rBottom = Number(params.radiusBottom ?? 0.1);
            const height = Number(params.height ?? 1.25);
            return `${(height + Math.max(rTop, rBottom)).toFixed(3)}`;
        }
        case 'VerticalCapsule': {
            const r = Number(params.radius ?? 0.25);
            const h = Number(params.height ?? 1.0);
            const half = 0.5 * h + r;
            return `${Math.sqrt(r * r + half * half).toFixed(3)}`;
        }
        case 'CutHollowSphere':
            return `${(Number(params.radius ?? 1.0) + Number(params.thickness ?? 0.1)).toFixed(3)}`;
        case 'DeathStar':
            return `${Math.max(Number(params.radiusA ?? 1.0), Number(params.offset ?? 0.6) + Number(params.radiusB ?? 0.4)).toFixed(3)}`;
        case 'VesicaSegment': {
            const ax = Number(params.ax ?? -0.5);
            const ay = Number(params.ay ?? 0.0);
            const az = Number(params.az ?? 0.0);
            const bx = Number(params.bx ?? 0.5);
            const by = Number(params.by ?? 0.0);
            const bz = Number(params.bz ?? 0.0);
            const width = Number(params.width ?? 0.25);
            const length = Math.sqrt(
                Math.pow(bx - ax, 2) + Math.pow(by - ay, 2) + Math.pow(bz - az, 2)
            );
            return `${(0.5 * length + width).toFixed(3)}`;
        }
        default:
            return null;
    }
}

function generatePreviewNodeCode(node, pointVar) {
    const nodeType = node.dataset.type;
    const varName = getNodeVarName(node);
    const prefix = varName;
    const typeDef = NODE_TYPES[nodeType];
    const colorVar = `${varName}_color`;
    const depthVar = `${varName}_depth`;
    const nodeColorLiteral = `intToColor(${getNodeColorIndex(node)})`;
    
    let code = '';
    const transformedPoint = varName + '_p';
    const scaleVar = `${varName}_scale`;
    
    code += `    vec3 ${transformedPoint} = ${pointVar};\n`;
    code += `    ${transformedPoint} -= ${prefix}_pos;\n`;
    code += `    ${transformedPoint} *= rotateX(${prefix}_rot.x);\n`;
    code += `    ${transformedPoint} *= rotateY(${prefix}_rot.y);\n`;
    code += `    ${transformedPoint} *= rotateZ(${prefix}_rot.z);\n`;
    code += `    float ${scaleVar} = max(${prefix}_scale, 0.0001);\n`;
    code += `    ${transformedPoint} /= ${scaleVar};\n`;
    code += `    vec3 ${colorVar};\n`;
    code += `    float ${depthVar};\n`;
    
    if (typeDef.category === 'primitive') {
        switch (nodeType) {
            case 'Sphere':
                code += `    float ${varName} = sdSphere(${transformedPoint}, ${prefix}_radius);\n`;
                break;
            case 'Box':
                code += `    float ${varName} = sdBox(${transformedPoint}, vec3(${prefix}_sizeX, ${prefix}_sizeY, ${prefix}_sizeZ));\n`;
                break;
            case 'Torus':
                code += `    float ${varName} = sdTorus(${transformedPoint}, vec2(${prefix}_majorRadius, ${prefix}_minorRadius));\n`;
                break;
            case 'Cylinder':
                code += `    float ${varName} = sdCylinder(${transformedPoint}, ${prefix}_radius, ${prefix}_height);\n`;
                break;
            case 'Octahedron':
                code += `    float ${varName} = sdOctahedron(${transformedPoint}, ${prefix}_size);\n`;
                break;
            case 'Cone': {
                const angleVar = `${varName}_angle`;
                const coneVec = `${varName}_c`;
                code += `    float ${angleVar} = radians(${prefix}_angleDeg);\n`;
                code += `    vec2 ${coneVec} = vec2(sin(${angleVar}), cos(${angleVar}));\n`;
                code += `    float ${varName} = sdCone(${transformedPoint}, ${coneVec}, ${prefix}_height);\n`;
                break;
            }
            case 'RoundCone':
                code += `    float ${varName} = sdRoundCone(${transformedPoint}, ${prefix}_radiusTop, ${prefix}_radiusBottom, ${prefix}_height);\n`;
                break;
            case 'VerticalCapsule':
                code += `    float ${varName} = sdVerticalCapsule(${transformedPoint}, ${prefix}_height, ${prefix}_radius);\n`;
                break;
            case 'CutHollowSphere':
                code += `    float ${varName} = sdCutHollowSphere(${transformedPoint}, ${prefix}_radius, ${prefix}_height, ${prefix}_thickness);\n`;
                break;
            case 'DeathStar':
                code += `    float ${varName} = sdDeathStar(${transformedPoint}, ${prefix}_radiusA, ${prefix}_radiusB, ${prefix}_offset);\n`;
                break;
            case 'VesicaSegment':
                code += `    float ${varName} = sdVesicaSegment(${transformedPoint}, vec3(${prefix}_ax, ${prefix}_ay, ${prefix}_az), vec3(${prefix}_bx, ${prefix}_by, ${prefix}_bz), ${prefix}_width);\n`;
                break;
        }
        code += `    ${varName} *= ${scaleVar};\n`;
        code += `    ${colorVar} = ${nodeColorLiteral};\n`;
        code += `    ${depthVar} = length(${transformedPoint});\n`;
        // Track ID and distance to selected for primitives
        code += `    g_lastID = ID_${varName};\n`;
        code += `    if (u_outlineEnabled && g_lastID == u_selectedID) {\n`;
        code += `        distToSelected = min(distToSelected, ${varName});\n`;
        code += `    }\n`;
    } else if (typeDef.category === 'operation') {
        const children = getNodeChildren(node);
        
        if (children.length < 2) {
            code += `    float ${varName} = 1000.0; // Incomplete operation\n`;
            code += `    ${colorVar} = ${nodeColorLiteral};\n`;
        } else {
            code += generatePreviewNodeCode(children[0], transformedPoint);
            code += generatePreviewNodeCode(children[1], transformedPoint);
            
            const child1Var = getNodeVarName(children[0]);
            const child2Var = getNodeVarName(children[1]);
            const child1Color = `${child1Var}_color`;
            const child2Color = `${child2Var}_color`;
            const child1Depth = `${child1Var}_depth`;
            const child2Depth = `${child2Var}_depth`;
            const depthVar = `${varName}_depth`;
            
            switch (nodeType) {
                case 'opUnion':
                    code += `    float ${varName} = min(${child1Var}, ${child2Var});\n`;
                    code += `    ${colorVar} = (${child1Var} <= ${child2Var}) ? ${child1Color} : ${child2Color};\n`;
                    code += `    ${depthVar} = (${child1Var} <= ${child2Var}) ? ${child1Depth} : ${child2Depth};\n`;
                    break;
                case 'opSmoothUnion':
                    code += `    float ${varName}_blend = clamp(0.5 + 0.5 * (${child2Var} - ${child1Var}) / ${prefix}_k, 0.0, 1.0);\n`;
                    code += `    float ${varName} = opSmoothUnion(${child1Var}, ${child2Var}, ${prefix}_k);\n`;
                    code += `    vec3 ${varName}_mixColor = mix(${child2Color}, ${child1Color}, ${varName}_blend);\n`;
                    code += `    float ${varName}_edge = smoothstep(0.0, 1.0, ${varName}_blend * (1.0 - ${varName}_blend) * 4.0);\n`;
                    code += `    ${colorVar} = mix(${varName}_mixColor, ${nodeColorLiteral}, ${varName}_edge);\n`;
                    code += `    ${depthVar} = mix(${child2Depth}, ${child1Depth}, ${varName}_blend);\n`;
                    break;
                case 'opSubtraction':
                    code += `    float ${varName} = max(-${child1Var}, ${child2Var});\n`;
                    code += `    ${colorVar} = (-${child1Var} > ${child2Var}) ? ${child1Color} : ${child2Color};\n`;
                    code += `    ${depthVar} = (-${child1Var} > ${child2Var}) ? ${child1Depth} : ${child2Depth};\n`;
                    break;
                case 'opSmoothSubtraction':
                    code += `    float ${varName}_blend = clamp(0.5 - 0.5 * (${child2Var} + ${child1Var}) / ${prefix}_k, 0.0, 1.0);\n`;
                    code += `    float ${varName} = opSmoothSubtraction(${child1Var}, ${child2Var}, ${prefix}_k);\n`;
                    code += `    vec3 ${varName}_mixColor = mix(${child2Color}, ${child1Color}, ${varName}_blend);\n`;
                    code += `    float ${varName}_edge = smoothstep(0.0, 1.0, ${varName}_blend * (1.0 - ${varName}_blend) * 4.0);\n`;
                    code += `    ${colorVar} = mix(${varName}_mixColor, ${nodeColorLiteral}, ${varName}_edge);\n`;
                    code += `    ${depthVar} = mix(${child2Depth}, ${child1Depth}, ${varName}_blend);\n`;
                    break;
                case 'opIntersection':
                    code += `    float ${varName} = max(${child1Var}, ${child2Var});\n`;
                    code += `    ${colorVar} = (${child1Var} >= ${child2Var}) ? ${child1Color} : ${child2Color};\n`;
                    code += `    ${depthVar} = (${child1Var} >= ${child2Var}) ? ${child1Depth} : ${child2Depth};\n`;
                    break;
                case 'opSmoothIntersection':
                    code += `    float ${varName}_blend = clamp(0.5 - 0.5 * (${child2Var} - ${child1Var}) / ${prefix}_k, 0.0, 1.0);\n`;
                    code += `    float ${varName} = opSmoothIntersection(${child1Var}, ${child2Var}, ${prefix}_k);\n`;
                    code += `    vec3 ${varName}_mixColor = mix(${child2Color}, ${child1Color}, ${varName}_blend);\n`;
                    code += `    float ${varName}_edge = smoothstep(0.0, 1.0, ${varName}_blend * (1.0 - ${varName}_blend) * 4.0);\n`;
                    code += `    ${colorVar} = mix(${varName}_mixColor, ${nodeColorLiteral}, ${varName}_edge);\n`;
                    code += `    ${depthVar} = mix(${child2Depth}, ${child1Depth}, ${varName}_blend);\n`;
                    break;
                case 'opXor':
                    code += `    float ${varName} = opXor(${child1Var}, ${child2Var});\n`;
                    code += `    float ${varName}_choice = step(abs(${child2Var}), abs(${child1Var}));\n`;
                    code += `    ${colorVar} = mix(${child1Color}, ${child2Color}, ${varName}_choice);\n`;
                    code += `    ${depthVar} = mix(${child1Depth}, ${child2Depth}, ${varName}_choice);\n`;
                    break;
            }
        }
    } else if (typeDef.category === 'modifier') {
        const children = getNodeChildren(node);
        if (children.length < 1) {
            code += `    float ${varName} = 1000.0; // Incomplete modifier\n`;
            code += `    ${colorVar} = ${nodeColorLiteral};\n`;
            code += `    float ${varName}_depth = 0.0;\n`;
        } else {
            const child = children[0];
            const childVar = getNodeVarName(child);
            const childColor = `${childVar}_color`;
            const childDepth = `${childVar}_depth`;
            const depthVar = `${varName}_depth`;
            switch (nodeType) {
                case 'opRound':
                    code += generatePreviewNodeCode(child, transformedPoint);
                    code += `    float ${varName} = ${childVar} - ${prefix}_roundRadius;\n`;
                    code += `    ${colorVar} = ${childColor};\n`;
                    code += `    ${depthVar} = ${childDepth};\n`;
                    break;
                case 'opOnion':
                    code += generatePreviewNodeCode(child, transformedPoint);
                    code += `    float ${varName} = abs(${childVar}) - ${prefix}_shellThickness;\n`;
                    code += `    ${colorVar} = ${childColor};\n`;
                    code += `    ${depthVar} = ${childDepth};\n`;
                    break;
                case 'opTwist': {
                    const warpPoint = `${varName}_warp`;
                    const angleVar = `${varName}_angle`;
                    const matVar = `${varName}_mat`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    float ${angleVar} = ${prefix}_twistAmount * ${warpPoint}.y;\n`;
                    code += `    mat2 ${matVar} = mat2(cos(${angleVar}), -sin(${angleVar}), sin(${angleVar}), cos(${angleVar}));\n`;
                    code += `    ${warpPoint}.xz = ${matVar} * ${warpPoint}.xz;\n`;
                    code += generatePreviewNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    code += `    ${colorVar} = ${childColor};\n`;
                    code += `    ${depthVar} = ${childDepth};\n`;
                    break;
                }
                case 'opElongate': {
                    const qVar = `${varName}_q`;
                    const clampVar = `${varName}_clamped`;
                    code += `    vec3 ${qVar} = abs(${transformedPoint}) - vec3(${prefix}_extentX, ${prefix}_extentY, ${prefix}_extentZ);\n`;
                    code += `    vec3 ${clampVar} = max(${qVar}, vec3(0.0));\n`;
                    code += generatePreviewNodeCode(child, clampVar);
                    code += `    float ${varName} = ${childVar} + min(max(${qVar}.x, max(${qVar}.y, ${qVar}.z)), 0.0);\n`;
                    code += `    ${colorVar} = ${childColor};\n`;
                    code += `    ${depthVar} = ${childDepth};\n`;
                    break;
                }
                case 'opCheapBend': {
                    const warpPoint = `${varName}_warp`;
                    const angleVar = `${varName}_angle`;
                    const matVar = `${varName}_mat`;
                    const rotated = `${varName}_rot`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    float ${angleVar} = ${prefix}_bendAmount * ${warpPoint}.x;\n`;
                    code += `    mat2 ${matVar} = mat2(cos(${angleVar}), -sin(${angleVar}), sin(${angleVar}), cos(${angleVar}));\n`;
                    code += `    vec2 ${rotated} = ${matVar} * ${warpPoint}.xy;\n`;
                    code += `    ${warpPoint}.xy = ${rotated};\n`;
                    code += generatePreviewNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    code += `    ${colorVar} = ${childColor};\n`;
                    code += `    ${depthVar} = ${childDepth};\n`;
                    break;
                }
                case 'opSymX': {
                    const warpPoint = `${varName}_warp`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    ${warpPoint}.x = abs(${warpPoint}.x);\n`;
                    code += generatePreviewNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    code += `    ${colorVar} = ${childColor};\n`;
                    code += `    ${depthVar} = ${childDepth};\n`;
                    break;
                }
            }
        }
    }
    
    code += `    ${varName} *= ${scaleVar};\n`;
    
    return code;
}

function getSDFPreamble() {
    return `// SDF Primitives and Operations
float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float sdCylinder(vec3 p, float r, float h) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float sdOctahedron(vec3 p, float s) {
    p = abs(p);
    float m = p.x + p.y + p.z - s;
    vec3 q;
         if (3.0 * p.x < m) q = p.xyz;
    else if (3.0 * p.y < m) q = p.yzx;
    else if (3.0 * p.z < m) q = p.zxy;
    else return m * 0.57735027;
    
    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);
    return length(vec3(q.x, q.y - s + k, q.z - k));
}

float sdCone(vec3 p, vec2 c, float h) {
    float safeCos = max(c.y, 0.0001);
    vec2 q = h * vec2(c.x / safeCos, -1.0);
    vec2 w = vec2(length(p.xz), p.y);
    vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
    vec2 b = w - q * vec2(clamp(w.x / max(q.x, 0.0001), 0.0, 1.0), 1.0);
    float k = sign(q.y);
    float d = min(dot(a, a), dot(b, b));
    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
    return sqrt(d) * sign(s);
}

float sdRoundCone(vec3 p, float r1, float r2, float h) {
    float b = (r1 - r2) / h;
    float a = sqrt(max(1.0 - b * b, 0.0001));
    vec2 q = vec2(length(p.xz), p.y);
    float k = dot(q, vec2(-b, a));
    if (k < 0.0) return length(q) - r1;
    if (k > a * h) return length(q - vec2(0.0, h)) - r2;
    return dot(q, vec2(a, b)) - r1;
}

float sdVerticalCapsule(vec3 p, float h, float r) {
    p.y -= clamp(p.y, 0.0, h);
    return length(p) - r;
}

float sdCutHollowSphere(vec3 p, float r, float h, float t) {
    float w = sqrt(max(r * r - h * h, 0.0));
    vec2 q = vec2(length(p.xz), p.y);
    return ((h * q.x < w * q.y) ? length(q - vec2(w, h)) : abs(length(q) - r)) - t;
}

float sdDeathStar(vec3 p2, float ra, float rb, float d) {
    float a = (ra * ra - rb * rb + d * d) / (2.0 * d);
    float b = sqrt(max(ra * ra - a * a, 0.0));
    vec2 p = vec2(p2.x, length(p2.yz));
    if (p.x * b - p.y * a > d * max(b - p.y, 0.0)) {
        return length(p - vec2(a, b));
    }
    return max(length(p) - ra, -(length(p - vec2(d, 0.0)) - rb));
}

float sdVesicaSegment(vec3 p, vec3 a, vec3 b, float w) {
    vec3 c = (a + b) * 0.5;
    vec3 ba = b - a;
    float l = length(ba);
    vec3 v = ba / max(l, 0.0001);
    vec3 rel = p - c;
    float y = dot(rel, v);
    vec2 q = vec2(length(rel - y * v), abs(y));
    float r = 0.5 * l;
    float ww = max(w, 0.0001);
    float d = 0.5 * (r * r - ww * ww) / ww;
    vec3 h = (r * q.x < d * (q.y - r)) ? vec3(0.0, r, 0.0) : vec3(-d, 0.0, d + ww);
    return length(q - h.xy) - h.z;
}

float opSmoothUnion(float d1, float d2, float k) {
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) - k * h * (1.0 - h);
}

float opSmoothSubtraction(float d1, float d2, float k) {
    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);
    return mix(d2, -d1, h) + k * h * (1.0 - h);
}

float opSmoothIntersection(float d1, float d2, float k) {
    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) + k * h * (1.0 - h);
}

float opXor(float d1, float d2) {
    return max(min(d1, d2), -max(d1, d2));
}

vec3 hsvToRgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 intToColor(int i) {
    float goldenRatio = 0.618033988749895;
    float hue = fract(float(i) * goldenRatio);
    float satBucket = floor(mod(float(i), 3.0));
    float valBucket = floor(mod(float(i), 4.0));
    float sat = clamp(0.7 + satBucket * 0.1, 0.0, 1.0);
    float val = clamp(0.7 + valBucket * 0.075, 0.0, 1.0);
    return hsvToRgb(vec3(hue, sat, val));
}

mat3 rotateX(float a) {
    float c = cos(a), s = sin(a);
    return mat3(1, 0, 0, 0, c, -s, 0, s, c);
}

mat3 rotateY(float a) {
    float c = cos(a), s = sin(a);
    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);
}

mat3 rotateZ(float a) {
    float c = cos(a), s = sin(a);
    return mat3(c, -s, 0, s, c, 0, 0, 0, 1);
}

`;
}

// ===========================================
// WebGL
// ===========================================
function initWebGL() {
    const canvas = document.getElementById('glCanvas');
    gl = canvas.getContext('webgl');
    
    if (!gl) {
        console.error('WebGL not supported');
        return;
    }
    
    // Create vertex buffer once
    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
}

function createShaderProgram(sdfCode) {
    const t0 = perfNow();
    const vertexShaderSource = `
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    `;
    
    const fragmentShaderSource = `
        precision highp float;
        uniform vec2 resolution;
        uniform vec3 u_cameraPos;
        uniform vec3 u_cameraTarget;
        uniform bool u_orthographicMode;
        uniform float u_cameraDistance;
        uniform int u_colorMode;
        uniform int u_lightingMode;
        uniform float u_paletteIndex;
        uniform bool u_outlineMode; // true = dual-pass, false = single-pass
        uniform int u_mainSteps;
        uniform int u_outlineSteps;
        
        ${sdfCode}
        
        vec3 computeRayDirection(vec2 uv) {
            vec3 forward = normalize(u_cameraTarget - u_cameraPos);
            vec3 worldUp = vec3(0.0, 1.0, 0.0);
            vec3 right = normalize(cross(forward, worldUp));
            if (length(right) < 0.001) {
                right = vec3(1.0, 0.0, 0.0);
            }
            vec3 up = normalize(cross(right, forward));
            return normalize(forward + uv.x * right + uv.y * up);
        }

        vec3 resolveSurfaceColor() {
            if (u_colorMode == 0) {
                return g_lastColor;
            }
            int paletteIndex = int(floor(u_paletteIndex + 0.5));
            return intToColor(paletteIndex);
        }
        
        vec3 calcNormal(vec3 p) {
            vec2 e = vec2(0.001, 0.0);
            vec3 backup = g_lastColor;
            float dx1 = sceneSDF(p + e.xyy);
            g_lastColor = backup;
            float dx2 = sceneSDF(p - e.xyy);
            g_lastColor = backup;
            float dy1 = sceneSDF(p + e.yxy);
            g_lastColor = backup;
            float dy2 = sceneSDF(p - e.yxy);
            g_lastColor = backup;
            float dz1 = sceneSDF(p + e.yyx);
            g_lastColor = backup;
            float dz2 = sceneSDF(p - e.yyx);
            g_lastColor = backup;
            return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));
        }
        
        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * resolution) / resolution.y;
            vec3 forward = normalize(u_cameraTarget - u_cameraPos);
            vec3 worldUp = vec3(0.0, 1.0, 0.0);
            vec3 right = normalize(cross(forward, worldUp));
            if (length(right) < 0.001) {
                right = vec3(1.0, 0.0, 0.0);
            }
            vec3 up = normalize(cross(right, forward));
            vec3 ro = u_cameraPos;
            vec3 rd = computeRayDirection(uv);
            if (u_orthographicMode) {
                float orthoScale = max(u_cameraDistance, 0.1);
                ro = u_cameraPos + uv.x * right * orthoScale + uv.y * up * orthoScale;
                rd = forward;
            }
            
            float t = 0.0;
            vec3 background = vec3(0.05, 0.05, 0.06);
            vec3 col = background;
            bool nearSelection = false;
            float minDistToSelected = 1e20;
            
            // Main raymarch pass - use dynamic step count
            for (int i = 0; i < 200; i++) {
                if (i >= u_mainSteps) break;
                
                vec3 p = ro + rd * t;
                distToSelected = 1e20;
                float d = sceneSDF(p);
                
                // Single-pass mode: track if we get close to selected during main pass
                if (!u_outlineMode && u_outlineEnabled && distToSelected < 0.02) {
                    nearSelection = true;
                    minDistToSelected = min(minDistToSelected, distToSelected);
                }
                
                if (d < 0.001) {
                    vec3 surfaceColor = resolveSurfaceColor();
                    if (u_lightingMode == 0) {
                        vec3 n = calcNormal(p);
                        vec3 lightDir = normalize(vec3(0.2, 0.9, 0.6));
                        float diff = max(dot(n, lightDir), 0.0);
                        float amb = 0.3;
                        float spec = pow(max(dot(reflect(-lightDir, n), -rd), 0.0), 24.0);
                        vec3 rim = pow(max(dot(n, rd), 0.0), 2.0) * vec3(0.2, 0.3, 0.45);
                        col = surfaceColor * (diff + amb) + spec * vec3(1.0) * 0.2 + rim;
                    } else {
                        // Per-object depth based on distance from object origin
                        float depthFactor = clamp(exp(-0.5 * g_lastDepth), 0.0, 1.0);
                        float lightAmount = mix(0.2, 1.0, depthFactor);
                        col = surfaceColor * lightAmount;
                    }
                    break;
                }
                
                if (t > 20.0) {
                    break;
                }
                t += d;
            }

            // Dual-pass mode: separate outline raymarch with dynamic step count
            if (u_outlineMode && u_outlineEnabled) {
                distToSelected = 1e20;
                t = 0.0;
                for (int i = 0; i < 200; i++) {
                    if (i >= u_outlineSteps) break;
                    
                    vec3 p = ro + rd * t;
                    float _ = sceneSDF(p);
                    if (distToSelected < 0.001) {
                        break;
                    }
                    if (t > 20.0) {
                        break;
                    }
                    t += distToSelected;
                }
                minDistToSelected = distToSelected;
            }

            // Draw outline if within range
            if (u_outlineEnabled && minDistToSelected > 0.001 && minDistToSelected < 0.02) {
                col = vec3(1.0, 0.8, 0.0); // Gold/yellow to match node selection
            }
            
            // Single-pass mode: also draw outline if we got near during main pass but didn't hit anything
            if (!u_outlineMode && nearSelection && col == background) {
                col = vec3(1.0, 0.8, 0.0);
            }
            
            gl_FragColor = vec4(col, 1.0);
        }
    `;
    
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);
    
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        console.error('Vertex shader error:', gl.getShaderInfoLog(vertexShader));
        return null;
    }
    
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);
    
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        console.error('Fragment shader error:', gl.getShaderInfoLog(fragmentShader));
        return null;
    }
    
    const prog = gl.createProgram();
    gl.attachShader(prog, vertexShader);
    gl.attachShader(prog, fragmentShader);
    gl.linkProgram(prog);
    
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(prog));
        return null;
    }
    
    cameraUniformLocations.pos = gl.getUniformLocation(prog, 'u_cameraPos');
    cameraUniformLocations.target = gl.getUniformLocation(prog, 'u_cameraTarget');
    
    perfLogDuration('createShaderProgram', t0);
    return prog;
}

function cacheUniformLocations() {
    const t0 = perfNow();
    let uniformCount = 0;
    uniformLocations = {};
    
    traverseSceneNodes(node => {
        const prefix = getNodeVarName(node);
        const nodeType = node.dataset.type;
        const typeDef = NODE_TYPES[nodeType];
        
        uniformLocations[`${prefix}_pos`] = gl.getUniformLocation(program, `${prefix}_pos`);
        uniformLocations[`${prefix}_rot`] = gl.getUniformLocation(program, `${prefix}_rot`);
        uniformLocations[`${prefix}_scale`] = gl.getUniformLocation(program, `${prefix}_scale`);
        uniformCount += 3;
        
        if (typeDef.params) {
            for (const key of Object.keys(typeDef.params)) {
                uniformLocations[`${prefix}_${key}`] = gl.getUniformLocation(program, `${prefix}_${key}`);
                uniformCount++;
            }
        }
    });
    uniformLocations['u_orthographicMode'] = gl.getUniformLocation(program, 'u_orthographicMode');
    uniformLocations['u_cameraDistance'] = gl.getUniformLocation(program, 'u_cameraDistance');
    uniformLocations['u_colorMode'] = gl.getUniformLocation(program, 'u_colorMode');
    uniformLocations['u_lightingMode'] = gl.getUniformLocation(program, 'u_lightingMode');
    uniformLocations['u_paletteIndex'] = gl.getUniformLocation(program, 'u_paletteIndex');
    uniformLocations['u_selectedID'] = gl.getUniformLocation(program, 'u_selectedID');
    uniformLocations['u_outlineEnabled'] = gl.getUniformLocation(program, 'u_outlineEnabled');
    uniformLocations['u_outlineMode'] = gl.getUniformLocation(program, 'u_outlineMode');
    uniformLocations['u_mainSteps'] = gl.getUniformLocation(program, 'u_mainSteps');
    uniformLocations['u_outlineSteps'] = gl.getUniformLocation(program, 'u_outlineSteps');
    
    perfLogDuration('cacheUniformLocations', t0, `uniforms=${uniformCount}`);
}

function updatePreviewUniforms() {
    if (!gl || !program) return;
    const t0 = perfNow();
    let uniformUpdates = 0;
    
    updateCameraUniforms();

    // Update export code display if visible
    gl.useProgram(program);
    
    traverseSceneNodes(node => {
        const prefix = getNodeVarName(node);
        const params = getNodeParams(node);
        const nodeType = node.dataset.type;
        const typeDef = NODE_TYPES[nodeType];
        
        // Set transform uniforms
        const posLoc = uniformLocations[`${prefix}_pos`];
        if (posLoc) {
            gl.uniform3f(posLoc, params.posX, params.posY, params.posZ);
            uniformUpdates++;
        }
        
        const rotLoc = uniformLocations[`${prefix}_rot`];
        if (rotLoc) {
            const rad = Math.PI / 180;
            gl.uniform3f(rotLoc, params.rotX * rad, params.rotY * rad, params.rotZ * rad);
            uniformUpdates++;
        }
        
        const scaleLoc = uniformLocations[`${prefix}_scale`];
        if (scaleLoc) {
            gl.uniform1f(scaleLoc, params.scale);
            uniformUpdates++;
        }
        
        // Set type-specific uniforms
        if (typeDef.params) {
            for (const key of Object.keys(typeDef.params)) {
                const loc = uniformLocations[`${prefix}_${key}`];
                if (loc) {
                    gl.uniform1f(loc, params[key]);
                    uniformUpdates++;
                }
            }
        }
    });
    const orthoLoc = uniformLocations['u_orthographicMode'];
    if (orthoLoc) {
        gl.uniform1i(orthoLoc, orthographicMode ? 1 : 0);
        uniformUpdates++;
    }
    const camDistLoc = uniformLocations['u_cameraDistance'];
    if (camDistLoc) {
        gl.uniform1f(camDistLoc, CAMERA_STATE.distance);
        uniformUpdates++;
    }
    applyRenderModeUniforms();
    const uniformsEnd = perfLogDuration('updatePreviewUniforms', t0, `updates=${uniformUpdates}`);
    renderPreview(uniformsEnd);
}

function applyRenderModeUniforms() {
    if (!gl || !program) return;
    const colorLoc = uniformLocations['u_colorMode'];
    if (colorLoc) {
        gl.uniform1i(colorLoc, renderModeState.colorMode === COLOR_MODES.SINGLE ? 1 : 0);
    }
    const paletteLoc = uniformLocations['u_paletteIndex'];
    if (paletteLoc) {
        gl.uniform1f(paletteLoc, renderModeState.paletteIndex);
    }
    const lightingLoc = uniformLocations['u_lightingMode'];
    if (lightingLoc) {
        gl.uniform1i(lightingLoc, renderModeState.lightingMode === LIGHTING_MODES.DEPTH ? 1 : 0);
    }
    
    // Update outline uniforms
    const outlineEnabledLoc = uniformLocations['u_outlineEnabled'];
    if (outlineEnabledLoc) {
        gl.uniform1i(outlineEnabledLoc, outlineEnabled ? 1 : 0);
    }
    const outlineModeLoc = uniformLocations['u_outlineMode'];
    if (outlineModeLoc) {
        gl.uniform1i(outlineModeLoc, outlineMode === 'dual' ? 1 : 0);
    }
    
    // Update raymarch step counts
    const mainStepsLoc = uniformLocations['u_mainSteps'];
    if (mainStepsLoc) {
        gl.uniform1i(mainStepsLoc, mainRaymarchSteps);
    }
    const outlineStepsLoc = uniformLocations['u_outlineSteps'];
    if (outlineStepsLoc) {
        gl.uniform1i(outlineStepsLoc, outlineRaymarchSteps);
    }
    
    // Update selected node ID
    const selectedIDLoc = uniformLocations['u_selectedID'];
    if (selectedIDLoc) {
        const selectedNode = document.querySelector('.node.selected');
        const selectedID = selectedNode && nodeIdMap.has(selectedNode) ? nodeIdMap.get(selectedNode) : 0;
        gl.uniform1i(selectedIDLoc, selectedID);
    }
}

function renderPreview(prevTimestamp, rafTimestamp) {
    if (!gl || !program) return;
    const perfStart = perfNow();
    const frameTimestamp = typeof rafTimestamp === 'number' ? rafTimestamp : performance.now();
    applyRenderModeUniforms();
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    
    // Only update FPS for RAF frames (not event-triggered renders)
    if (typeof rafTimestamp === 'number') {
        updateFps(frameTimestamp);
    }
    
    const renderEnd = perfLogDuration('renderPreview', perfStart);
    if (typeof prevTimestamp === 'number') {
        const total = renderEnd - prevTimestamp + (prevTimestamp - perfStart);
        console.log(`[SDFperf] uniforms+render total: ${total.toFixed(2)}ms`);
    }
}

function recompilePreview() {
    if (!gl) return;
    const t0 = perfNow();
    
    const previewGLSL = generatePreviewGLSL();
    
    // Update export code display if visible
    if (program) {
        gl.deleteProgram(program);
    }
    
    program = createShaderProgram(previewGLSL);
    if (!program) return;
    
    gl.useProgram(program);
    
    // Setup vertex attributes
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    const positionAttrib = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(positionAttrib);
    gl.vertexAttribPointer(positionAttrib, 2, gl.FLOAT, false, 0, 0);
    
    // Set resolution uniform
    const resolutionUniform = gl.getUniformLocation(program, 'resolution');
    gl.uniform2f(resolutionUniform, gl.canvas.width, gl.canvas.height);
    
    // Cache uniform locations and update values
    cacheUniformLocations();
    updatePreviewUniforms();
    graphDirty = false;
    autoCompilePending = false;
    updateRecompileButtonState();
    setParamControlsEnabled(true);
    currentParamNode = ensureValidParamNode(currentParamNode) || getFirstEditableNode();
    renderCurrentParamPanel();
    startPreviewLoop();
    
    const stats = getSceneStats();
    perfLogDuration('recompilePreview', t0, `nodes=${stats.nodeCount} depth=${stats.maxDepth}`);
}

function startPreviewLoop() {
    if (previewAnimationHandle) return;
    const tick = (timestamp) => {
        if (!gl || !program) {
            previewAnimationHandle = null;
            return;
        }
        renderPreview(undefined, timestamp);
        previewAnimationHandle = requestAnimationFrame(tick);
    };
    previewAnimationHandle = requestAnimationFrame(tick);
}

function stopPreviewLoop() {
    if (previewAnimationHandle) {
        cancelAnimationFrame(previewAnimationHandle);
        previewAnimationHandle = null;
    }
}

function updateFps(frameTimestamp) {
    if (!previewFpsDisplay) return;
    if (lastFrameTimestamp) {
        const delta = frameTimestamp - lastFrameTimestamp;
        if (delta > 0) {
            const instant = 1000 / delta;
            // Use stronger smoothing for more stable FPS display
            smoothedFps = smoothedFps ? (smoothedFps * 0.9 + instant * 0.1) : instant;
            // Update display every 250ms
            if (!lastFpsUpdate || frameTimestamp - lastFpsUpdate > 250) {
                previewFpsDisplay.textContent = `FPS: ${Math.round(smoothedFps)}`;
                lastFpsUpdate = frameTimestamp;
            }
        }
    }
    lastFrameTimestamp = frameTimestamp;
}

init();
</script>
</body>
</html>