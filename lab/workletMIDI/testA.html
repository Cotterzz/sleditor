<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Latency Test</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #0d1117;
            color: #c9d1d9;
            line-height: 1.6;
        }
        h1 { color: #58a6ff; margin-bottom: 10px; }
        .subtitle { color: #8b949e; margin-bottom: 30px; }
        
        .card {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .card h3 { margin-top: 0; color: #58a6ff; }
        
        .status-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #484f58;
        }
        .status-dot.success { background: #3fb950; }
        .status-dot.warning { background: #d29922; }
        .status-dot.error { background: #f85149; }
        
        button {
            background: #238636;
            color: #fff;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: background 0.2s;
        }
        button:hover { background: #2ea043; }
        button:disabled { 
            background: #21262d; 
            color: #484f58;
            cursor: not-allowed; 
        }
        
        .active-notes {
            min-height: 60px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        .note-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: #238636;
            color: #fff;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
            animation: noteIn 0.1s ease-out;
        }
        @keyframes noteIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .note-badge .freq {
            font-weight: 400;
            opacity: 0.8;
            font-size: 12px;
        }
        .placeholder-text {
            color: #484f58;
            font-style: italic;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .stat-item {
            background: #0d1117;
            padding: 15px;
            border-radius: 6px;
        }
        .stat-label { 
            font-size: 12px; 
            color: #8b949e; 
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .stat-value { 
            font-size: 24px; 
            font-weight: 600; 
            color: #f0f6fc;
            font-family: 'SF Mono', Monaco, monospace;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 15px;
        }
        .control-group { flex: 1; min-width: 200px; }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #8b949e;
            font-size: 14px;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #30363d;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #58a6ff;
            cursor: pointer;
        }
        select {
            width: 100%;
            padding: 10px;
            background: #0d1117;
            color: #c9d1d9;
            border: 1px solid #30363d;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .event-log {
            max-height: 150px;
            overflow-y: auto;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
            background: #0d1117;
            padding: 10px;
            border-radius: 6px;
        }
        .event-log div {
            padding: 2px 0;
            border-bottom: 1px solid #21262d;
        }
        .event-log .time { color: #8b949e; }
        .event-log .note-on { color: #3fb950; }
        .event-log .note-off { color: #f85149; }
    </style>
</head>
<body>
    <h1>ðŸŽ¹ MIDI â†’ AudioWorklet Latency Test</h1>
    <p class="subtitle">Test real-time MIDI input latency with Web Audio API's AudioWorklet</p>
    
    <div class="card">
        <h3>Status</h3>
        <div class="status-row">
            <div class="status-dot" id="midiDot"></div>
            <span id="midiStatus">Checking MIDI access...</span>
        </div>
        <div class="status-row">
            <div class="status-dot" id="audioDot"></div>
            <span id="audioStatus">Audio not started</span>
        </div>
        <br>
        <button id="startBtn">â–¶ Start Audio Context</button>
    </div>
    
    <div class="card">
        <h3>Active Notes</h3>
        <div class="active-notes" id="activeNotes">
            <span class="placeholder-text">Play your MIDI controller to see active notes...</span>
        </div>
    </div>
    
    <div class="card">
        <h3>Latency Statistics</h3>
        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-label">Sample Rate</div>
                <div class="stat-value" id="sampleRate">â€”</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Buffer Size</div>
                <div class="stat-value" id="bufferSize">128</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Base Latency</div>
                <div class="stat-value" id="baseLatency">â€”</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Output Latency</div>
                <div class="stat-value" id="outputLatency">â€”</div>
            </div>
        </div>
    </div>
    
    <div class="card">
        <h3>Synth Controls</h3>
        <div class="controls">
            <div class="control-group">
                <label>Waveform</label>
                <select id="waveform">
                    <option value="sine">Sine</option>
                    <option value="triangle">Triangle</option>
                    <option value="sawtooth">Sawtooth</option>
                    <option value="square">Square</option>
                </select>
            </div>
            <div class="control-group">
                <label>Master Volume: <span id="volumeVal">50</span>%</label>
                <input type="range" id="volume" min="0" max="100" value="50">
            </div>
            <div class="control-group">
                <label>Attack: <span id="attackVal">5</span>ms</label>
                <input type="range" id="attack" min="1" max="100" value="5">
            </div>
            <div class="control-group">
                <label>Release: <span id="releaseVal">80</span>ms</label>
                <input type="range" id="release" min="10" max="500" value="80">
            </div>
        </div>
    </div>
    
    <div class="card">
        <h3>Event Log</h3>
        <div class="event-log" id="eventLog">
            <div><span class="time">[--:--:--.---]</span> Waiting for MIDI events...</div>
        </div>
    </div>

<script>
// ============================================
// AudioWorklet Processor (embedded as string)
// ============================================
const workletCode = `
class PolySynthProcessor extends AudioWorkletProcessor {
    constructor() {
        super();
        
        // Map of active voices: noteNumber -> voice data
        this.voices = new Map();
        
        // Synth parameters
        this.params = {
            waveform: 'sine',
            volume: 0.5,
            attackTime: 0.005,
            releaseTime: 0.08
        };
        
        // Handle messages from main thread
        this.port.onmessage = (e) => {
            const { type, note, velocity, param, value } = e.data;
            
            if (type === 'noteOn') {
                this.startVoice(note, velocity);
            } else if (type === 'noteOff') {
                this.releaseVoice(note);
            } else if (type === 'param') {
                this.params[param] = value;
            }
        };
    }
    
    startVoice(note, velocity) {
        const freq = 440 * Math.pow(2, (note - 69) / 12);
        
        // Check if voice already exists (retriggering)
        const existing = this.voices.get(note);
        
        this.voices.set(note, {
            frequency: freq,
            phase: existing ? existing.phase : 0, // Continue phase if retriggering
            envelope: existing ? existing.envelope : 0,
            velocity: velocity / 127,
            state: 'attack',
            releaseLevel: 0
        });
    }
    
    releaseVoice(note) {
        const voice = this.voices.get(note);
        if (voice && voice.state !== 'release') {
            voice.state = 'release';
            voice.releaseLevel = voice.envelope;
            voice.releaseProgress = 0;
        }
    }
    
    generateSample(phase, waveform) {
        const p = phase / (2 * Math.PI); // Normalize to 0-1
        
        switch (waveform) {
            case 'sine':
                return Math.sin(phase);
            case 'triangle':
                return 4 * Math.abs(p - Math.floor(p + 0.5)) - 1;
            case 'sawtooth':
                return 2 * (p - Math.floor(p + 0.5));
            case 'square':
                return p % 1 < 0.5 ? 1 : -1;
            default:
                return Math.sin(phase);
        }
    }
    
    process(inputs, outputs) {
        const output = outputs[0];
        const channel = output[0];
        
        if (!channel) return true;
        
        const { waveform, volume, attackTime, releaseTime } = this.params;
        const attackInc = 1 / (attackTime * sampleRate);
        const releaseInc = 1 / (releaseTime * sampleRate);
        
        // Clear buffer
        channel.fill(0);
        
        // Process each sample
        for (let i = 0; i < channel.length; i++) {
            let mixedSample = 0;
            let voiceCount = 0;
            
            // Process each voice
            for (const [noteNum, voice] of this.voices) {
                // Update envelope based on state
                if (voice.state === 'attack') {
                    voice.envelope += attackInc;
                    if (voice.envelope >= 1) {
                        voice.envelope = 1;
                        voice.state = 'sustain';
                    }
                } else if (voice.state === 'release') {
                    voice.releaseProgress += releaseInc;
                    // Exponential release curve for smoother fade
                    voice.envelope = voice.releaseLevel * (1 - voice.releaseProgress);
                    
                    if (voice.releaseProgress >= 1) {
                        this.voices.delete(noteNum);
                        continue;
                    }
                }
                // sustain state: envelope stays at current level
                
                // Update phase
                const phaseInc = (voice.frequency * 2 * Math.PI) / sampleRate;
                voice.phase += phaseInc;
                
                // Wrap phase to prevent floating point issues
                if (voice.phase > 2 * Math.PI) {
                    voice.phase -= 2 * Math.PI;
                }
                
                // Generate sample
                const sample = this.generateSample(voice.phase, waveform);
                
                // Apply envelope and velocity
                mixedSample += sample * voice.envelope * voice.velocity;
                voiceCount++;
            }
            
            // Apply polyphonic gain compensation and master volume
            if (voiceCount > 0) {
                // Square root scaling for natural polyphonic balance
                const polyGain = 1 / Math.sqrt(Math.max(voiceCount, 1));
                channel[i] = mixedSample * polyGain * volume;
            }
        }
        
        // Copy to all output channels
        for (let ch = 1; ch < output.length; ch++) {
            output[ch].set(channel);
        }
        
        return true;
    }
}

registerProcessor('poly-synth-processor', PolySynthProcessor);
`;

// ============================================
// Main Application
// ============================================

let audioContext = null;
let synthNode = null;
let midiAccess = null;
const activeNotes = new Map(); // note -> { velocity, timestamp }

const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

function noteToName(note) {
    return NOTE_NAMES[note % 12] + (Math.floor(note / 12) - 1);
}

function noteToFreq(note) {
    return (440 * Math.pow(2, (note - 69) / 12)).toFixed(1);
}

function formatTime(date) {
    return date.toTimeString().split(' ')[0] + '.' + 
           String(date.getMilliseconds()).padStart(3, '0');
}

function logEvent(message, type = '') {
    const log = document.getElementById('eventLog');
    const div = document.createElement('div');
    div.innerHTML = `<span class="time">[${formatTime(new Date())}]</span> <span class="${type}">${message}</span>`;
    log.insertBefore(div, log.firstChild);
    
    // Keep only last 50 entries
    while (log.children.length > 50) {
        log.removeChild(log.lastChild);
    }
}

function updateNotesDisplay() {
    const container = document.getElementById('activeNotes');
    
    if (activeNotes.size === 0) {
        container.innerHTML = '<span class="placeholder-text">Play your MIDI controller to see active notes...</span>';
        return;
    }
    
    container.innerHTML = Array.from(activeNotes.entries())
        .sort((a, b) => a[0] - b[0])
        .map(([note, data]) => `
            <div class="note-badge">
                ${noteToName(note)}
                <span class="freq">${noteToFreq(note)} Hz</span>
            </div>
        `).join('');
}

function updateStatus(element, dotElement, message, status) {
    document.getElementById(element).textContent = message;
    const dot = document.getElementById(dotElement);
    dot.className = 'status-dot ' + status;
}

// ============================================
// MIDI Handling
// ============================================

function handleMIDIMessage(event) {
    const [status, note, velocity] = event.data;
    const command = status & 0xF0;
    const channel = status & 0x0F;
    
    // Note On
    if (command === 0x90 && velocity > 0) {
        activeNotes.set(note, { velocity, timestamp: performance.now() });
        
        if (synthNode) {
            synthNode.port.postMessage({ type: 'noteOn', note, velocity });
        }
        
        logEvent(`Note ON: ${noteToName(note)} (${note}) vel=${velocity} ch=${channel + 1}`, 'note-on');
        updateNotesDisplay();
    }
    // Note Off (or Note On with velocity 0)
    else if (command === 0x80 || (command === 0x90 && velocity === 0)) {
        const noteData = activeNotes.get(note);
        activeNotes.delete(note);
        
        if (synthNode) {
            synthNode.port.postMessage({ type: 'noteOff', note });
        }
        
        const duration = noteData ? (performance.now() - noteData.timestamp).toFixed(1) : '?';
        logEvent(`Note OFF: ${noteToName(note)} (${note}) duration=${duration}ms ch=${channel + 1}`, 'note-off');
        updateNotesDisplay();
    }
}

async function initMIDI() {
    if (!navigator.requestMIDIAccess) {
        updateStatus('midiStatus', 'midiDot', 'Web MIDI not supported in this browser', 'error');
        return;
    }
    
    try {
        midiAccess = await navigator.requestMIDIAccess({ sysex: false });
        
        function connectInputs() {
            const inputs = Array.from(midiAccess.inputs.values());
            
            if (inputs.length === 0) {
                updateStatus('midiStatus', 'midiDot', 'No MIDI devices found. Connect a device and refresh.', 'warning');
                return;
            }
            
            inputs.forEach(input => {
                input.onmidimessage = handleMIDIMessage;
            });
            
            const names = inputs.map(i => i.name).join(', ');
            updateStatus('midiStatus', 'midiDot', `Connected: ${names}`, 'success');
            logEvent(`MIDI connected: ${names}`);
        }
        
        connectInputs();
        
        // Handle hot-plugging
        midiAccess.onstatechange = (e) => {
            if (e.port.type === 'input') {
                logEvent(`MIDI device ${e.port.state}: ${e.port.name}`);
                connectInputs();
            }
        };
        
    } catch (err) {
        updateStatus('midiStatus', 'midiDot', `MIDI Error: ${err.message}`, 'error');
        console.error('MIDI init error:', err);
    }
}

// ============================================
// Audio Initialization
// ============================================

async function initAudio() {
    try {
        // Create context with low latency hint
        audioContext = new AudioContext({
            latencyHint: 'interactive',
            sampleRate: 48000 // Request specific sample rate
        });
        
        // Resume if suspended (autoplay policy)
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        
        // Create worklet from blob
        const blob = new Blob([workletCode], { type: 'application/javascript' });
        const url = URL.createObjectURL(blob);
        
        await audioContext.audioWorklet.addModule(url);
        URL.revokeObjectURL(url);
        
        // Create synth node
        synthNode = new AudioWorkletNode(audioContext, 'poly-synth-processor', {
            numberOfInputs: 0,
            numberOfOutputs: 1,
            outputChannelCount: [2]
        });
        
        synthNode.connect(audioContext.destination);
        
        // Update UI
        updateStatus('audioStatus', 'audioDot', `Running (${audioContext.sampleRate} Hz)`, 'success');
        
        document.getElementById('sampleRate').textContent = audioContext.sampleRate;
        document.getElementById('baseLatency').textContent = 
            (audioContext.baseLatency * 1000).toFixed(2) + 'ms';
        document.getElementById('outputLatency').textContent = 
            (audioContext.outputLatency * 1000).toFixed(2) + 'ms';
        
        document.getElementById('startBtn').disabled = true;
        document.getElementById('startBtn').textContent = 'âœ“ Audio Running';
        
        logEvent(`Audio started: ${audioContext.sampleRate}Hz, base latency: ${(audioContext.baseLatency * 1000).toFixed(2)}ms`);
        
        // Send initial parameters
        sendParams();
        
    } catch (err) {
        updateStatus('audioStatus', 'audioDot', `Error: ${err.message}`, 'error');
        console.error('Audio init error:', err);
    }
}

// ============================================
// Parameter Controls
// ============================================

function sendParams() {
    if (!synthNode) return;
    
    const waveform = document.getElementById('waveform').value;
    const volume = document.getElementById('volume').value / 100;
    const attack = document.getElementById('attack').value / 1000;
    const release = document.getElementById('release').value / 1000;
    
    synthNode.port.postMessage({ type: 'param', param: 'waveform', value: waveform });
    synthNode.port.postMessage({ type: 'param', param: 'volume', value: volume });
    synthNode.port.postMessage({ type: 'param', param: 'attackTime', value: attack });
    synthNode.port.postMessage({ type: 'param', param: 'releaseTime', value: release });
}

function setupControls() {
    // Waveform
    document.getElementById('waveform').addEventListener('change', sendParams);
    
    // Volume
    const volumeSlider = document.getElementById('volume');
    volumeSlider.addEventListener('input', () => {
        document.getElementById('volumeVal').textContent = volumeSlider.value;
        sendParams();
    });
    
    // Attack
    const attackSlider = document.getElementById('attack');
    attackSlider.addEventListener('input', () => {
        document.getElementById('attackVal').textContent = attackSlider.value;
        sendParams();
    });
    
    // Release
    const releaseSlider = document.getElementById('release');
    releaseSlider.addEventListener('input', () => {
        document.getElementById('releaseVal').textContent = releaseSlider.value;
        sendParams();
    });
}

// ============================================
// Initialize
// ============================================

document.getElementById('startBtn').addEventListener('click', initAudio);

setupControls();
initMIDI();

// Keyboard fallback for testing without MIDI
document.addEventListener('keydown', (e) => {
    if (e.repeat || !synthNode) return;
    
    // Map keyboard to MIDI notes (Z = C3, etc.)
    const keyMap = {
        'z': 48, 's': 49, 'x': 50, 'd': 51, 'c': 52, 'v': 53, 'g': 54,
        'b': 55, 'h': 56, 'n': 57, 'j': 58, 'm': 59, ',': 60,
        'q': 60, '2': 61, 'w': 62, '3': 63, 'e': 64, 'r': 65, '5': 66,
        't': 67, '6': 68, 'y': 69, '7': 70, 'u': 71, 'i': 72
    };
    
    const note = keyMap[e.key.toLowerCase()];
    if (note && !activeNotes.has(note)) {
        handleMIDIMessage({ data: [0x90, note, 100] });
    }
});

document.addEventListener('keyup', (e) => {
    if (!synthNode) return;
    
    const keyMap = {
        'z': 48, 's': 49, 'x': 50, 'd': 51, 'c': 52, 'v': 53, 'g': 54,
        'b': 55, 'h': 56, 'n': 57, 'j': 58, 'm': 59, ',': 60,
        'q': 60, '2': 61, 'w': 62, '3': 63, 'e': 64, 'r': 65, '5': 66,
        't': 67, '6': 68, 'y': 69, '7': 70, 'u': 71, 'i': 72
    };
    
    const note = keyMap[e.key.toLowerCase()];
    if (note) {
        handleMIDIMessage({ data: [0x80, note, 0] });
    }
});
</script>
</body>
</html>