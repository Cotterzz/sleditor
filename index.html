<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>EDITOR</title>
    <link rel="stylesheet" href="css/app.css">
    <link rel="icon" type="image/png" href="/favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="/favicon/favicon.svg" />
    <link rel="shortcut icon" href="/favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png" />
    <link rel="manifest" href="/favicon/site.webmanifest" />
</head>
<body>
    <div id="container">
        <div id="devPanel">
<div id="editorTabs" style="display: flex; margin-bottom: 0px; gap: 5px; align-items: center;">
    <!-- Tabs will be dynamically added here -->
    <button id="addPassBtn" style="padding: 6px 12px; font-size: 13px; margin-left: auto;">+ Add Pass</button>
    <button id="optionsBtn" style="padding: 6px 12px; font-size: 13px;">‚öô Options</button>
</div>
<div id="boilerplateContainer" class="editor-panel" style="display: none;">
</div>
<div id="graphicsContainer" class="editor-panel">
    <div id="loadingMessage">Loading Monaco Editor...</div>
</div>
<div id="audioContainer" class="editor-panel" style="display: none;">
</div>
<div id="jsEditorContainer" class="editor-panel" style="display: none;">
</div>
<div id="helpContainer" class="editor-panel" style="display: none;">
</div>
            <div style="display: flex; align-items: center; gap: 1px;">
                <div style="flex: 1;">
                    <div id="errorDisplay" class="info"></div>
                </div>
                <button id="reloadBtn" class="uiBtn" title="Reload shaders (F5 / Ctrl+S)">‚å¨</button>
                <button id="saveShaderBtn" class="uiBtn" title="Save current shader">üíæ</button>
            </div>
            
            <!-- Vim status bar (inside dev panel) -->
            <div id="vim-status"></div>
        </div>
        
        <!-- Divider between Dev and Display -->
        <div class="panel-divider" id="divider1" data-divider="dev-display">
            <div class="divider-handle">‚ãÆ</div>
        </div>
        
        <div id="displayPanel">
            <div id="canvasContainer">
            <canvas id="canvasWebGPU" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block;"></canvas>
            <canvas id="canvasWebGL" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none;"></canvas>
            </div>
            
            <!-- Horizontal divider for vertical canvas resizing -->
            <div class="horizontal-divider" id="canvasResizeDivider">
                <div class="divider-handle horizontal">‚ãØ</div>
            </div>
            
            <div id="controls">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                <button id="playPauseBtn" class="playing">‚è∏</button>
                <button id="restartBtn" title="Restart from beginning">‚ü≥</button>
            </div>
                <div class="sliderContainer">
                    <input type="range" id="volumeSlider" class="verticalSlider" min="0" max="100" value="50" orient="vertical">
                    <div style="font-size: 16px;">üîä</div>
            </div>
                <div class="sliderContainer">
                    <input type="range" id="pixelScaleSlider" class="verticalSlider" min="0" max="5" value="0" step="1" orient="vertical">
                    <div id="renderModeIcon" style="font-size: 16px; cursor: pointer; user-select: none;" title="Click to cycle render modes">‚ñ¶</div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 3px; color: var(--text-secondary); font-size: 12px;">
                    <div id="resolutionDisplay">512 √ó 512 √ó 1</div>
                    <div>FPS: <span id="fpsCounter">0</span></div>
                    <div>Frame: <span id="frameCounter">0</span></div>
                    <div>Time: <span id="timeCounter">0.00s</span></div>
                </div>
            </div>
            
            <!-- Shader Info -->
            <div id="shaderInfo" style="padding: 10px; border-top: 1px solid var(--border-color);">
                <div id="shaderTitle" style="font-size: 14px; font-weight: 500; color: var(--text-primary); margin-bottom: 4px;">GLSL Hello World</div>
                <div id="shaderDescription" style="font-size: 12px; color: var(--text-secondary); line-height: 1.4;">Your first GLSL fragment shader - a simple colorful gradient</div>
            </div>
        </div>
        
        <!-- Divider between Display and Gallery -->
        <div class="panel-divider" id="divider2" data-divider="display-gallery">
            <div class="divider-handle">‚ãÆ</div>
        </div>
        
        <div id="galleryPanel">
            <div class="gallery-header">
                <h2 style="margin: 0; font-size: 16px; color: var(--text-primary);">Gallery</h2>
            </div>
            <div id="galleryContent">
                <!-- Gallery items will be populated here -->
            </div>
        </div>
    </div>

    <!-- Save Shader Modal -->
    <div id="saveModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2>Save Shader</h2>
            <div class="modal-field">
                <label for="saveModalTitle">Title (required):</label>
                <input type="text" id="saveModalTitle" placeholder="My Amazing Shader" maxlength="50" />
            </div>
            <div class="modal-field">
                <label for="saveModalDescription">Description (optional):</label>
                <textarea id="saveModalDescription" placeholder="What does this shader do?" maxlength="200" rows="3"></textarea>
            </div>
            <div class="modal-field">
                <label for="saveModalTags">Tags (optional, comma-separated):</label>
                <input type="text" id="saveModalTags" placeholder="graphics, fractal, audio" maxlength="50" />
            </div>
            <div class="modal-buttons">
                <button id="saveCancelBtn">Cancel</button>
                <button id="saveConfirmBtn" class="primary">Save</button>
            </div>
        </div>
    </div>

    <!-- Load Monaco from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
    
    <!-- Configure Monaco loader -->
    <script>
    require.config({ 
        paths: { 
            'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' 
        }
    });
    </script>
    
    <!-- Main Application (ES6 Modules) -->
    <script type="module">
    'use strict';

    // Import all modules
    import { state, CONFIG, DERIVED, AUDIO_MODES, loadSettings, saveSettings, logStatus, updateDerived } from './js/core.js';
    import * as webgpu from './js/backends/webgpu.js';
    import * as webgl from './js/backends/webgl.js';
    import * as audioWorklet from './js/backends/audio-worklet.js';
    import * as render from './js/render.js';
    import * as editor from './js/editor.js';
    import * as jsRuntime from './js/js-runtime.js';
    import * as tabs from './js/tabs.js';
    import * as save from './js/save.js';
    import * as vim from './js/vim.js';
    import { getBoilerplate, getHelpContent, MINIMAL_JS, EXAMPLES } from './js/examples.js';

    // ============================================================================
    // Audio Initialization
    // ============================================================================

    function initWebAudio() {
        state.audioContext = new AudioContext();
        state.gainNode = state.audioContext.createGain();
        state.gainNode.gain.value = CONFIG.volume;
        state.gainNode.connect(state.audioContext.destination);
        
        // Update DERIVED values
        updateDerived(state.audioContext);
        
        console.log(`Audio initialized: ${DERIVED.sampleRate}Hz, ${DERIVED.samplesPerBlock} samples/block`);
    }

    // ============================================================================
    // Theme Management
    // ============================================================================

    function applyTheme() {
        if (state.isDarkMode) {
            document.body.classList.remove('light-mode');
        } else {
            document.body.classList.add('light-mode');
        }
        
        // Update Monaco theme if editors exist
        if (state.graphicsEditor) {
            editor.setTheme(state.isDarkMode);
        }
    }

    function toggleTheme() {
        state.isDarkMode = !state.isDarkMode;
        saveSettings({ isDarkMode: state.isDarkMode });
        applyTheme();
    }

    // ============================================================================
    // Shader Compilation
    // ============================================================================

    async function compileGLSL(hasAudioWorklet, skipAudioWorkletReload) {
        try {
            logStatus('Compiling GLSL...', 'info');
            editor.clearAllErrors();
            
            // Initialize WebGL if needed
            if (!state.glContext) {
                console.log('Initializing WebGL for GLSL...');
                
                // Clear WebGPU state (switching from WebGPU to WebGL)
                if (state.gpuContext) {
                    console.log('Releasing WebGPU context to switch to WebGL...');
                    state.gpuContext.unconfigure();
                    state.gpuContext = null;
                    state.graphicsBackend = null;
                }
                
                const webglResult = await webgl.init(state.canvasWebGL);
                if (!webglResult.success) {
                    logStatus('‚úó WebGL2 not available', 'error');
                    return false;
                }
            }
            
            // Always ensure WebGL canvas is visible when compiling GLSL
            state.canvasWebGL.style.display = 'block';
            state.canvasWebGPU.style.display = 'none';
            
            const startTotal = performance.now();
            
            // Get fragment shader code
            const fragmentCode = state.graphicsEditor.getValue();
            
            // Compile GLSL shader
            const compileResult = await webgl.compile(fragmentCode);
            if (!compileResult.success) {
                editor.setGLSLErrors(compileResult.errors);
                
                const errorMsg = compileResult.errors.map(e => 
                    `Line ${e.lineNum}: ${e.message}`
                ).join('\n');
                
                logStatus('‚úó GLSL compilation failed:\n' + errorMsg, 'error');
                return false;
            }
            
            // Load AudioWorklet if present
            let audioSuccess = true;
            if (hasAudioWorklet && !skipAudioWorkletReload) {
                const audioCode = state.audioEditor.getValue();
                const result = await audioWorklet.load(audioCode);
                if (!result.success) {
                    editor.setAudioWorkletErrors(result.errors);
                    const errMsg = result.errors[0] ? `Line ${result.errors[0].lineNum || '?'}: ${result.errors[0].message}` : 'Unknown error';
                    logStatus(`‚úó AudioWorklet error: ${errMsg}`, 'error');
                    audioSuccess = false;
                }
            }
            
            // Compile JS
            let jsSuccess = true;
            if (state.activeTabs.includes('js')) {
                const jsCode = state.jsEditor.getValue();
                const result = jsRuntime.compile(jsCode, false);
                if (!result.success) {
                    editor.setJSErrors(result.errors);
                    const errMsg = result.errors[0] ? `Line ${result.errors[0].lineNum || '?'}: ${result.errors[0].message}` : 'Unknown error';
                    logStatus(`‚úó JS error: ${errMsg}`, 'error');
                    jsSuccess = false;
                }
            } else {
                // No JS tab active - reset to minimal JS to prevent old code from running
                jsRuntime.compile(MINIMAL_JS, false);
            }
            
            if (!audioSuccess || !jsSuccess) {
                return false;
            }
            
            const totalTime = performance.now() - startTotal;
            logStatus(`‚úì Compiled in ${totalTime.toFixed(1)}ms`, 'success');
            
            // Call user init
            jsRuntime.callInit();
            
            return true;
        } catch (err) {
            logStatus('‚úó ' + err.message, 'error');
            console.error('GLSL compilation error:', err);
            return false;
        }
    }

    async function reloadShader(isResizeOnly = false) {
        // Detect which tabs are active
        const hasGraphicsWGSL = state.activeTabs.includes('graphics');
        const hasGraphicsGLSL = state.activeTabs.includes('glsl_fragment');
        const hasAudioGpu = state.activeTabs.includes('audio_gpu');
        const hasAudioWorklet = state.activeTabs.includes('audio_worklet');
        
        // Determine backend based on active tabs
        const needsWebGPU = hasGraphicsWGSL || hasAudioGpu;
        const needsWebGL = hasGraphicsGLSL;
        
        // Stop old audio
        const isWorkletActive = state.audioMode === AUDIO_MODES.WORKLET && state.audioWorkletNode;
        const skipAudioWorkletReload = isResizeOnly && isWorkletActive && hasAudioWorklet;
        
        if (!skipAudioWorkletReload) {
            stopAudio();
        }
        
        // Handle GLSL (WebGL) compilation
        if (needsWebGL) {
            return await compileGLSL(hasAudioWorklet, skipAudioWorkletReload);
        }
        
        // Non-graphics mode (JS + AudioWorklet only)
        if (!needsWebGPU || !state.hasWebGPU) {
            try {
                logStatus('Compiling...', 'info');
                editor.clearAllErrors();
                
                const startTotal = performance.now();
                let audioSuccess = true;
                let jsSuccess = true;
                
                // Load AudioWorklet if present
                if (hasAudioWorklet && !skipAudioWorkletReload) {
                    const audioCode = state.audioEditor.getValue();
                    const result = await audioWorklet.load(audioCode);
                    if (!result.success) {
                        editor.setAudioWorkletErrors(result.errors);
                        logStatus(`‚úó AudioWorklet error: ${result.errors[0].message}`, 'error');
                        audioSuccess = false;
                    }
                }
                
                // Compile JS
                if (state.activeTabs.includes('js')) {
                    const code = state.jsEditor.getValue();
                    const result = jsRuntime.compile(code, false);
                    if (!result.success) {
                        editor.setJSErrors(result.errors);
                        logStatus(`‚úó JS error: ${result.errors[0].message}`, 'error');
                        jsSuccess = false;
                    }
                } else {
                    // No JS tab active - reset to minimal JS to prevent old code from running
                    jsRuntime.compile(MINIMAL_JS, false);
                }
                
                if (audioSuccess && jsSuccess) {
                    const totalTime = performance.now() - startTotal;
                    logStatus(`‚úì Compiled in ${totalTime.toFixed(1)}ms`, 'success');
                    return true;
                }
                return false;
            } catch (err) {
                logStatus('‚úó ' + err.message, 'error');
                return false;
            }
        }
        
        // GPU mode (WebGPU + optional audio)
        
        // If WebGL is currently active, reinitialize WebGPU
        if (state.glContext && !state.gpuContext) {
            console.log('Reinitializing WebGPU (switching from WebGL)...');
            const webgpuResult = await webgpu.init(state.canvasWebGPU);
            if (!webgpuResult.success) {
                logStatus('‚úó Failed to reinitialize WebGPU', 'error');
                return false;
            }
            // Clean up WebGL state
            state.glContext = null;
            state.glProgram = null;
            state.glUniforms = null;
        }
        
        // Always ensure WebGPU canvas is visible when compiling WGSL
        state.canvasWebGPU.style.display = 'block';
        state.canvasWebGL.style.display = 'none';
        
        const boilerplate = getBoilerplate();
        const graphics = state.graphicsEditor.getValue();
        const audio = hasAudioGpu ? state.audioEditor.getValue() : '';
        const code = boilerplate + '\n' + graphics + '\n' + audio;
        
        state.boilerplateEditor.setValue(boilerplate);
        
        try {
            logStatus('Compiling...', 'info');
            editor.clearAllErrors();
            
            const startTotal = performance.now();
            
            // Compile WGSL
            const compileResult = await webgpu.compile(code, hasGraphicsWGSL, hasAudioGpu);
            if (!compileResult.success) {
                editor.setWGSLErrors(compileResult.errors);
                
                // Convert raw line numbers to user-friendly editor-relative line numbers
                const boilerplateLines = state.boilerplateEditor.getValue().split('\n').length;
                const graphicsLines = state.graphicsEditor.getValue().split('\n').length;
                const graphicsStartLine = boilerplateLines + 1;
                const audioStartLine = boilerplateLines + 1 + graphicsLines + 1;
                
                const errorMsg = compileResult.errors.map(e => {
                    const lineNum = e.lineNum || 1;
                    let editorName, editorLine;
                    
                    if (lineNum < graphicsStartLine) {
                        editorName = 'Boilerplate';
                        editorLine = lineNum;
                    } else if (lineNum < audioStartLine) {
                        editorName = 'Graphics';
                        editorLine = lineNum - graphicsStartLine + 1;
                    } else {
                        editorName = 'Audio';
                        editorLine = lineNum - audioStartLine + 2;
                    }
                    
                    return `${editorName} line ${editorLine}: ${e.message}`;
                }).join('\n');
                
                logStatus('‚úó Shader compilation failed:\n' + errorMsg, 'error');
                return false;
            }
            
            // Load AudioWorklet if present
            if (hasAudioWorklet && !skipAudioWorkletReload) {
                const audioCode = state.audioEditor.getValue();
                const result = await audioWorklet.load(audioCode);
                if (!result.success) {
                    editor.setAudioWorkletErrors(result.errors);
                    const errMsg = result.errors[0] ? `Line ${result.errors[0].lineNum || '?'}: ${result.errors[0].message}` : 'Unknown error';
                    logStatus(`‚úó AudioWorklet error: ${errMsg}`, 'error');
                    return false;
                }
            }
            
            // Compile JS
            if (state.activeTabs.includes('js')) {
                const jsCode = state.jsEditor.getValue();
                const result = jsRuntime.compile(jsCode, false);
                if (!result.success) {
                    editor.setJSErrors(result.errors);
                    const errMsg = result.errors[0] ? `Line ${result.errors[0].lineNum || '?'}: ${result.errors[0].message}` : 'Unknown error';
                    logStatus(`‚úó JS error: ${errMsg}`, 'error');
                    return false;
                }
            } else {
                // No JS tab active - reset to minimal JS to prevent old code from running
                jsRuntime.compile(MINIMAL_JS, false);
            }
            
            const totalTime = performance.now() - startTotal;
            logStatus(`‚úì Compiled in ${totalTime.toFixed(1)}ms`, 'success');
            
            // Call user init
            jsRuntime.callInit();
            
            return true;
        } catch (err) {
            logStatus('‚úó ' + err.message, 'error');
            console.error('Compilation error:', err);
            return false;
        }
    }

    function stopAudio() {
        state.audioPipeline = null;
        state.pendingAudio = false;
        audioWorklet.cleanup();
        state.audioMode = AUDIO_MODES.NONE;
    }

    // ============================================================================
    // Play/Pause/Restart
    // ============================================================================

    function togglePlayPause() {
        state.isPlaying = !state.isPlaying;
        
        if (state.isPlaying) {
            state.audioContext.resume();
            state.lastPauseTime = performance.now();
            const pauseDuration = state.lastPauseTime - (state.lastPauseTime || 0);
            state.pausedTime += pauseDuration;
        } else {
            state.audioContext.suspend();
            state.lastPauseTime = performance.now();
        }
        
        updatePlayPauseButton();
    }

    function updatePlayPauseButton() {
        const btn = document.getElementById('playPauseBtn');
        if (state.isPlaying) {
            btn.textContent = '‚è∏';
            btn.className = 'playing';
        } else {
            btn.textContent = '‚ñ∂';
            btn.className = 'paused';
        }
    }

    function restart(userInitiated = false) {
        const now = performance.now();
        state.startTime = now;
        state.pausedTime = 0;
        state.lastPauseTime = 0;
        state.visualFrame = 0;
        state.audioFrame = 0;
        state.nextAudioTime = state.audioContext.currentTime + 0.1;
        state.fpsLastTime = now;
        state.fpsFrameCount = 0;
        
        // Call user init
        jsRuntime.callInit();
        
        if (userInitiated) {
            logStatus('‚úì Restarted from beginning');
        }
        
        // Update display immediately to show t=0
        document.getElementById('frameCounter').textContent = '0';
        document.getElementById('timeCounter').textContent = '0.00s';
        document.getElementById('fpsCounter').textContent = '0';
        
        // If paused, render one frame to show the restart visually
        if (!state.isPlaying && state.isRunning) {
            render.renderOnce();
        }
    }

    // ============================================================================
    // Load Example
    // ============================================================================

    function loadExample(exampleId) {
        const example = EXAMPLES[exampleId];
        if (!example) return;
        
        // Temporarily disable dirty tracking while loading
        const wasInitializing = state.isInitializing;
        state.isInitializing = true;
        
        state.currentExample = exampleId;
        state.currentSavedShader = null;
        state.isDirty = false;
        updateSaveButton();
        
        // Convert old 'audio' tab to new format
        const updatedTabs = example.tabs.map(tab => {
            if (tab === 'audio') {
                const isWorklet = example.audio && (example.audio.includes('AudioWorkletProcessor') || 
                                 example.audio.includes('registerProcessor'));
                return isWorklet ? 'audio_worklet' : 'audio_gpu';
            }
            return tab;
        });
        
        state.activeTabs = [...updatedTabs];
        
        // Determine audio type
        if (state.activeTabs.includes('audio_gpu')) {
            state.currentAudioType = 'gpu';
        } else if (state.activeTabs.includes('audio_worklet')) {
            state.currentAudioType = 'worklet';
        } else {
            state.currentAudioType = null;
        }
        
        // Load code into editors
        if (state.graphicsEditor) {
            state.graphicsEditor.setValue(example.graphics || '');
        }
        if (state.audioEditor && example.audio) {
            state.audioEditor.setValue(example.audio);
        }
        if (state.jsEditor) {
            state.jsEditor.setValue(example.js || MINIMAL_JS);
        }
        
        // Update UI
        tabs.renderTabs();
        tabs.switchTab(updatedTabs[0] || 'graphics');
        
        // Update shader info
        document.getElementById('shaderTitle').textContent = example.name;
        document.getElementById('shaderDescription').textContent = example.description || '';
        
        // Reload shader and restart (maintains play/pause state)
        if (state.isRunning) {
            reloadShader().then((success) => {
                restart();
                // Re-enable dirty tracking after load completes
                setTimeout(() => {
                    state.isInitializing = wasInitializing;
                }, 100);
            });
        } else {
            // Re-enable dirty tracking immediately if not running
            setTimeout(() => {
                state.isInitializing = wasInitializing;
            }, 100);
        }
    }

    // ============================================================================
    // Panel Dividers
    // ============================================================================

    function setupPanelDividers() {
        const container = document.getElementById('container');
        const devPanel = document.getElementById('devPanel');
        const displayPanel = document.getElementById('displayPanel');
        const galleryPanel = document.getElementById('galleryPanel');
        const divider1 = document.getElementById('divider1');
        const divider2 = document.getElementById('divider2');
        
        let activeDivider = null;
        let startX = 0;
        let startDevWidth = 0;
        let startDisplayWidth = 0;
        let startGalleryWidth = 0;
        let hasMoved = false;
        
        const panelState = {
            devCollapsed: false,
            galleryCollapsed: false
        };
        
        function startDrag(divider, e) {
            e.preventDefault();
            activeDivider = divider;
            startX = e.clientX;
            hasMoved = false;
            
            const containerWidth = container.offsetWidth;
            startDevWidth = (devPanel.offsetWidth / containerWidth) * 100;
            startDisplayWidth = (displayPanel.offsetWidth / containerWidth) * 100;
            startGalleryWidth = (galleryPanel.offsetWidth / containerWidth) * 100;
            
            devPanel.style.transition = 'none';
            displayPanel.style.transition = 'none';
            galleryPanel.style.transition = 'none';
            
            divider.classList.add('dragging');
            document.body.style.cursor = 'ew-resize';
            document.body.style.userSelect = 'none';
        }
        
        function onDrag(e) {
            if (!activeDivider) return;
            if (activeDivider === divider1 && panelState.devCollapsed) return;
            if (activeDivider === divider2 && panelState.galleryCollapsed) return;
            
            const containerWidth = container.offsetWidth;
            const deltaX = e.clientX - startX;
            const deltaPercent = (deltaX / containerWidth) * 100;
            
            if (Math.abs(deltaX) > 3) hasMoved = true;
            
            if (activeDivider === divider1) {
                let newDevWidth = startDevWidth + deltaPercent;
                let newDisplayWidth = startDisplayWidth - deltaPercent;
                
                const minDevPercent = (300 / containerWidth) * 100;
                const minDisplayPercent = (250 / containerWidth) * 100;
                
                if (newDevWidth < minDevPercent) {
                    newDevWidth = minDevPercent;
                    newDisplayWidth = startDisplayWidth + (startDevWidth - minDevPercent);
                } else if (newDisplayWidth < minDisplayPercent) {
                    newDisplayWidth = minDisplayPercent;
                    newDevWidth = startDevWidth + (startDisplayWidth - minDisplayPercent);
                }
                
                devPanel.style.width = newDevWidth + '%';
                displayPanel.style.width = newDisplayWidth + '%';
            } else if (activeDivider === divider2) {
                let newDisplayWidth = startDisplayWidth + deltaPercent;
                let newGalleryWidth = startGalleryWidth - deltaPercent;
                
                const minDisplayPercent = (250 / containerWidth) * 100;
                const minGalleryPercent = (200 / containerWidth) * 100;
                
                if (newDisplayWidth < minDisplayPercent) {
                    newDisplayWidth = minDisplayPercent;
                    newGalleryWidth = startGalleryWidth + (startDisplayWidth - minDisplayPercent);
                } else if (newGalleryWidth < minGalleryPercent) {
                    newGalleryWidth = minGalleryPercent;
                    newDisplayWidth = startDisplayWidth + (startGalleryWidth - minGalleryPercent);
                }
                
                displayPanel.style.width = newDisplayWidth + '%';
                galleryPanel.style.width = newGalleryWidth + '%';
            }
        }
        
        function stopDrag() {
            if (!activeDivider) return;
            
            const divider = activeDivider;
            activeDivider.classList.remove('dragging');
            activeDivider = null;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            
            devPanel.style.transition = '';
            displayPanel.style.transition = '';
            galleryPanel.style.transition = '';
            
            if (!hasMoved) {
                if (divider === divider1) togglePanelCollapse('dev');
                else if (divider === divider2) togglePanelCollapse('gallery');
            }
        }
        
        function togglePanelCollapse(panel) {
            const containerWidth = container.offsetWidth;
            const currentDevWidth = (devPanel.offsetWidth / containerWidth) * 100;
            const currentDisplayWidth = (displayPanel.offsetWidth / containerWidth) * 100;
            const currentGalleryWidth = (galleryPanel.offsetWidth / containerWidth) * 100;
            
            if (panel === 'dev') {
                panelState.devCollapsed = !panelState.devCollapsed;
                if (panelState.devCollapsed) {
                    // Fully hide dev panel
                    devPanel.style.width = '0%';
                    devPanel.style.minWidth = '0';
                    displayPanel.style.width = (currentDisplayWidth + currentDevWidth) + '%';
                } else {
                    // Restore dev panel
                    devPanel.style.width = '50%';
                    devPanel.style.minWidth = '300px';
                    displayPanel.style.width = (currentDisplayWidth + currentDevWidth - 50) + '%';
                }
            } else if (panel === 'gallery') {
                panelState.galleryCollapsed = !panelState.galleryCollapsed;
                if (panelState.galleryCollapsed) {
                    // Fully hide gallery panel
                    galleryPanel.style.width = '0%';
                    galleryPanel.style.minWidth = '0';
                    displayPanel.style.width = (currentDisplayWidth + currentGalleryWidth) + '%';
                } else {
                    // Restore gallery panel
                    galleryPanel.style.width = '20%';
                    galleryPanel.style.minWidth = '200px';
                    displayPanel.style.width = (currentDisplayWidth + currentGalleryWidth - 20) + '%';
                }
            }
        }
        
        divider1.addEventListener('mousedown', (e) => startDrag(divider1, e));
        divider2.addEventListener('mousedown', (e) => startDrag(divider2, e));
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', stopDrag);
    }

    function setupHorizontalCanvasDivider() {
        const divider = document.getElementById('canvasResizeDivider');
        const canvasContainer = document.getElementById('canvasContainer');
        
        let isDragging = false;
        let startY = 0;
        let startHeight = 0;
        
        function startDrag(e) {
            e.preventDefault();
            isDragging = true;
            startY = e.clientY;
            startHeight = canvasContainer.offsetHeight;
            
            divider.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
        }
        
        function onDrag(e) {
            if (!isDragging) return;
            
            const deltaY = e.clientY - startY;
            let newHeight = startHeight + deltaY;
            
            const maxHeight = window.innerHeight * 0.75;
            newHeight = Math.max(256, Math.min(newHeight, maxHeight));
            newHeight = Math.round(newHeight / 16) * 16;
            
            canvasContainer.classList.add('explicit-height');
            canvasContainer.style.height = newHeight + 'px';
        }
        
        function stopDrag() {
            if (!isDragging) return;
            
            isDragging = false;
            divider.classList.remove('dragging');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }
        
        divider.addEventListener('mousedown', startDrag);
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', stopDrag);
    }

    function setupCanvasResizeObserver() {
        const canvasContainer = document.getElementById('canvasContainer');
        const resizeObserver = new ResizeObserver(entries => {
            for (const entry of entries) {
                const { width, height } = entry.contentRect;
                const newWidth = Math.round(width / 16) * 16;
                const newHeight = Math.round(height / 16) * 16;
                
                if (newWidth !== state.canvasWidth || newHeight !== state.canvasHeight) {
                    updateCanvasSize(newWidth, newHeight, true);
                }
            }
        });
        resizeObserver.observe(canvasContainer);
    }

    // ============================================================================
    // Setup UI
    // ============================================================================

    function setupUI() {
        // Canvas elements (separate for WebGPU and WebGL)
        state.canvasWebGPU = document.getElementById('canvasWebGPU');
        state.canvasWebGL = document.getElementById('canvasWebGL');
        const canvasContainer = document.getElementById('canvasContainer');
        canvasContainer.classList.add('explicit-height');
        canvasContainer.style.height = state.canvasHeight + 'px';
        
        // Set initial canvas size
        updateCanvasSize(state.canvasWidth, state.canvasHeight, false);
        
        // Setup panel dividers and canvas observer
        setupPanelDividers();
        setupHorizontalCanvasDivider();
        setupCanvasResizeObserver();
        
        // Initialize render mode
        updateRenderMode();
        
        // Event listeners
        document.getElementById('playPauseBtn').addEventListener('click', togglePlayPause);
        document.getElementById('restartBtn').addEventListener('click', () => restart(true));
        document.getElementById('reloadBtn').addEventListener('click', () => reloadShader());
        document.getElementById('addPassBtn').addEventListener('click', tabs.showAddPassMenu);
        document.getElementById('optionsBtn').addEventListener('click', tabs.showOptionsMenu);
        
        // Volume control
        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            const vol = e.target.value / 100;
            CONFIG.volume = vol;
            if (state.gainNode) state.gainNode.gain.value = vol;
        });
        
        // Pixel scale control
        document.getElementById('pixelScaleSlider').addEventListener('input', (e) => {
            const scaleIndex = parseInt(e.target.value);
            const scales = [1, 2, 3, 4, 6, 8];
            state.pixelScale = scales[scaleIndex];
            updateCanvasSize(state.canvasWidth, state.canvasHeight, true);
        });
        
        // Render mode cycling
        document.getElementById('renderModeIcon').addEventListener('click', () => {
            state.renderMode = (state.renderMode + 1) % 3;
            updateRenderMode();
        });
        
        // Mouse tracking (use whichever canvas is visible)
        document.addEventListener('mousemove', (e) => {
            const activeCanvas = state.graphicsBackend === 'webgl' ? state.canvasWebGL : state.canvasWebGPU;
            const rect = activeCanvas.getBoundingClientRect();
            state.mouseX = (e.clientX - rect.left) / rect.width;
            state.mouseY = 1.0 - (e.clientY - rect.top) / rect.height; // Flip Y
        });
        
        // Handle visibility change - resync audio timing when tab becomes visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && state.audioContext && state.isPlaying) {
                const ctx = state.audioContext;
                state.nextAudioTime = Math.ceil(ctx.currentTime / CONFIG.audioBlockDuration) * CONFIG.audioBlockDuration;
                state.pendingAudio = false;
            }
        });
        
        // Custom events
        window.addEventListener('toggle-theme', toggleTheme);
        window.addEventListener('toggle-vim', vim.toggleVimMode);
        window.addEventListener('load-example', (e) => loadExample(e.detail));
        window.addEventListener('stop-audio', stopAudio);
        window.addEventListener('tab-removed-recompile', () => {
            if (state.isRunning) {
                reloadShader();
            }
        });
        
        // Warn before leaving with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (state.isDirty) {
                e.preventDefault();
                e.returnValue = ''; // Chrome requires returnValue to be set
                return ''; // Some browsers need a return value
            }
        });
    }

    function updateCanvasSize(width, height, recompile = true) {
        state.canvasWidth = width;
        state.canvasHeight = height;
        
        const renderWidth = Math.floor(width / state.pixelScale);
        const renderHeight = Math.floor(height / state.pixelScale);
        
        // Update both canvases
        state.canvasWebGPU.width = renderWidth;
        state.canvasWebGPU.height = renderHeight;
        state.canvasWebGL.width = renderWidth;
        state.canvasWebGL.height = renderHeight;
        
        // Update canvas container size
        const canvasContainer = document.getElementById('canvasContainer');
        if (canvasContainer) {
            canvasContainer.style.height = height + 'px';
        }
        
        document.getElementById('resolutionDisplay').textContent = 
            `${renderWidth} √ó ${renderHeight} √ó ${state.pixelScale}`;
        
        if (recompile && state.isRunning) {
            reloadShader(true);
        }
    }

    function updateRenderMode() {
        const modes = [
            { css: 'pixelated', icon: '‚ñ¶', name: 'Pixelated (Sharp)' },
            { css: 'auto', icon: '‚ñ©', name: 'Smooth (Bilinear)' },
            { css: 'crisp-edges', icon: '‚ñ†', name: 'Crisp Edges' }
        ];
        
        const mode = modes[state.renderMode];
        state.canvasWebGPU.style.imageRendering = mode.css;
        state.canvasWebGL.style.imageRendering = mode.css;
        
        const icon = document.getElementById('renderModeIcon');
        if (icon) {
            icon.textContent = mode.icon;
            icon.title = `Render mode: ${mode.name} (click to cycle)`;
        }
    }

    // ============================================================================
    // Setup Save System
    // ============================================================================

    function setupSaveSystem() {
        document.getElementById('saveShaderBtn').addEventListener('click', showSaveModal);
        document.getElementById('saveCancelBtn').addEventListener('click', hideSaveModal);
        document.getElementById('saveConfirmBtn').addEventListener('click', () => {
            const title = document.getElementById('saveModalTitle').value.trim();
            const description = document.getElementById('saveModalDescription').value;
            const tags = document.getElementById('saveModalTags').value;
            
            if (!title) {
                logStatus('‚ö† Title is required');
                document.getElementById('saveModalTitle').focus();
                return;
            }
            
            const result = save.saveShaderToStorage(title, description, tags);
            if (result.success) {
                hideSaveModal();
                save.populateGallery(EXAMPLES);
                logStatus('‚úì Shader saved');
            }
        });
        
        // Custom events
        window.addEventListener('shader-saved', () => {
            save.populateGallery(EXAMPLES);
            updateSaveButton();
        });
        window.addEventListener('shader-loaded', (e) => {
            const shader = e.detail;
            
            // Temporarily disable dirty tracking while loading
            const wasInitializing = state.isInitializing;
            state.isInitializing = true;
            
            // Update save button
            updateSaveButton();
            
            // Don't change canvas size or pixel scale - use current values
            
            // Update shader info
            document.getElementById('shaderTitle').textContent = shader.title;
            document.getElementById('shaderDescription').textContent = shader.description || '';
            
            // Update UI
            tabs.renderTabs();
            
            // Switch to saved tab (or first tab)
            if (shader.currentTab && state.activeTabs.includes(shader.currentTab)) {
                tabs.switchTab(shader.currentTab);
            } else if (state.activeTabs.length > 0) {
            tabs.switchTab(state.activeTabs[0]);
            }
            
            // Reload shader and restart (maintains play/pause state)
            if (state.isRunning) {
                reloadShader().then(() => {
                    restart();
                    // Re-enable dirty tracking after load completes
                    setTimeout(() => {
                        state.isInitializing = wasInitializing;
                    }, 100);
                });
            } else {
                // Re-enable dirty tracking immediately if not running
                setTimeout(() => {
                    state.isInitializing = wasInitializing;
                }, 100);
            }
        });
    }

    function markDirty() {
        // Don't mark as dirty during initial load
        if (state.isInitializing) return;
        
        if (!state.isDirty) {
            state.isDirty = true;
            updateSaveButton();
        }
    }

    function updateSaveButton() {
        const btn = document.getElementById('saveShaderBtn');
        if (!btn) return;
        
        if (state.isDirty) {
            btn.textContent = 'üíæ*';
            btn.title = 'Save current shader (unsaved changes)';
        } else {
            btn.textContent = 'üíæ';
            btn.title = 'Save current shader';
        }
    }

    function setupDirtyTracking(editor) {
        if (!editor) return;
        editor.onDidChangeModelContent(() => {
            markDirty();
        });
    }

    function showSaveModal() {
        document.getElementById('saveModal').style.display = 'flex';
        document.getElementById('saveModalTitle').focus();
    }

    function hideSaveModal() {
        document.getElementById('saveModal').style.display = 'none';
        document.getElementById('saveModalTitle').value = '';
        document.getElementById('saveModalDescription').value = '';
        document.getElementById('saveModalTags').value = '';
    }

    // ============================================================================
    // Initialization
    // ============================================================================

    async function init() {
        // Load settings
        const settings = loadSettings();
        if (settings.isDarkMode !== undefined) {
            state.isDarkMode = settings.isDarkMode;
        }
        if (settings.isVimMode !== undefined) {
            state.isVimMode = settings.isVimMode;
        }
        applyTheme();
        
        setupUI();
        setupSaveSystem();
        
        // Initialize audio FIRST
        initWebAudio();
        
        // Load help content
        const helpContent = await getHelpContent();
        
        // Initialize Monaco with initial code
        const initialCode = {
            boilerplate: getBoilerplate(),
            graphics: EXAMPLES.glsl_hello.graphics || '',
            audio: EXAMPLES.glsl_hello.audio || '',
            audioLanguage: 'wgsl',
            js: EXAMPLES.glsl_hello.js || MINIMAL_JS
        };
        
        await editor.initMonaco(null, initialCode, helpContent);
        
        // Set up dirty tracking for all editors
        // (markDirty checks isInitializing flag to prevent marking during load)
        setupDirtyTracking(state.graphicsEditor);
        setupDirtyTracking(state.audioEditor);
        setupDirtyTracking(state.jsEditor);
        setupDirtyTracking(state.boilerplateEditor);
        // Help is read-only, no need to track
        
        // Load vim library asynchronously after a short delay
        // This ensures Monaco has fully loaded all its language modules first
        setTimeout(() => {
        vim.loadVimLibrary().then((success) => {
            if (success && state.isVimMode) {
                vim.applyVimMode();
            }
        });
        }, 1000);
        
        // Try to initialize WebGPU first (hello_world is WGSL)
        const webgpuResult = await webgpu.init(state.canvasWebGPU);
        state.hasWebGPU = webgpuResult.success;
        
        // Don't initialize WebGL yet - can't share canvas context with WebGPU
        // WebGL will be initialized on-demand when a GLSL shader is loaded
        state.hasWebGL = true;  // Assume available (WebGL2 is widely supported)
        
        console.log('Graphics backends:', {
            WebGPU: state.hasWebGPU,
            WebGL: '(not initialized - will init on-demand)'
        });
        
        // Populate gallery
        save.populateGallery(EXAMPLES);
        
        // Initialize tabs
        tabs.renderTabs();
        tabs.switchTab('glsl_fragment');
        
        // Compile initial shader (works for both GLSL and WGSL)
        const compileSuccess = await reloadShader();
        console.log('Initial shader compilation:', compileSuccess ? 'success' : 'failed');
        
        // IMPORTANT: Start render loop BEFORE setting isRunning = true
        console.log('Starting render loop, canvas size:', state.canvasWebGPU.width, 'x', state.canvasWebGPU.height);
            render.start();
        
        // Now set up playback state
        state.isRunning = true;
        restart();
        state.isPlaying = true;
        state.audioContext.resume();
        updatePlayPauseButton();
        
        // Mark initialization complete - now dirty tracking can start
        // Small delay to ensure all initial setValue calls have completed
        setTimeout(() => {
            state.isInitializing = false;
        }, 200);
    }

    // Make some functions global for Monaco keyboard shortcuts
    window.reloadShader = reloadShader;
    window.togglePlayPause = togglePlayPause;

    // Start application
    window.addEventListener('load', init);
    </script>
</body>
</html>

