<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="author" content="John Cotterell">
    <title>SDF Builder</title>
    <link href="https://fonts.googleapis.com/css?family=Abel|Quicksand:500|Source+Code+Pro" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        #rootnode {
            font-size: 20px;
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        .node {
            font-family: 'Quicksand', sans-serif;
            font-size: .9em;
            padding: 8px 12px;
            border: 2px solid #cccccc;
            border-radius: 5px;
            background: #eeeeee;
            position: absolute;
            z-index: 9;
            cursor: default;
            min-width: 80px;
            text-align: center;
        }

.node .detach-wrapper {
    position: absolute;
    top: -32px;
    left: 50%;
    transform: translateX(-50%);
    width: 120px;
    height: 40px;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.35);
    border: 1px dashed rgba(197, 48, 48, 0.6);
    opacity: 0;
    pointer-events: auto;
}

.detach-wrapper .detach-handle {
    position: absolute;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    width: 22px;
    height: 22px;
    border-radius: 50%;
    border: 2px solid rgba(0, 0, 0, 0.25);
    background: #fff;
    color: #c53030;
    font-size: 13px;
    line-height: 22px;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    opacity: 0;
    pointer-events: auto;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
}

.detach-wrapper .detach-handle::selection {
    background: transparent;
}

.node .detach-wrapper:hover,
.detach-wrapper.force-visible,
.detach-wrapper:focus-within {
    opacity: 1;
    pointer-events: auto;
}

        .node.scene {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #5a67d8;
            color: white;
        }

        .node.operation {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-color: #ed64a6;
            color: white;
        }

        .node.modifier {
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
            border-color: #f6ad55;
            color: #2d3748;
        }

        .node.primitive {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border-color: #38b2ac;
            color: white;
        }

        .node.selected {
            box-shadow: 0 0 0 3px #ffd700;
        }

        .node.invalid {
            opacity: 0.5;
        }

        .nodetitle {
            font-weight: 500;
            pointer-events: none;
        }

        #sidebar {
            font-family: 'Abel', sans-serif;
            font-size: 16px;
            position: fixed;
            left: 0;
            top: 0;
            width: 200px;
            height: 100%;
            background: #2d3748;
            color: white;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 100;
        }

        #sidebar h3 {
            margin: 15px 0 10px 0;
            font-size: 14px;
            text-transform: uppercase;
            color: #a0aec0;
            border-bottom: 1px solid #4a5568;
            padding-bottom: 5px;
        }

        .menu-item {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            cursor: grab;
            transition: background 0.2s;
        }

        .menu-item:hover {
            background: #4a5568;
        }

        .menu-item.primitive {
            border-left: 3px solid #4facfe;
        }

        .menu-item.operation {
            border-left: 3px solid #f5576c;
        }

        .menu-item.modifier {
            border-left: 3px solid #f6ad55;
        }

        #paramPanel {
            font-family: 'Abel', sans-serif;
            position: fixed;
            right: 0;
            top: 0;
            width: 280px;
            height: 100%;
            background: #2d3748;
            color: white;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        #paramPanel.visible {
            display: block;
        }

        #paramPanel h3 {
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #4a5568;
        }

        .param-group {
            margin-bottom: 15px;
        }

        .param-group label {
            display: block;
            font-size: 12px;
            color: #a0aec0;
            margin-bottom: 5px;
        }

        .param-group input[type="range"] {
            width: 100%;
            margin-bottom: 3px;
        }

        .param-group .value-display {
            font-size: 11px;
            color: #718096;
            text-align: right;
        }

        .param-section {
            margin-bottom: 20px;
        }

        .param-section-title {
            font-size: 13px;
            color: #ed64a6;
            margin-bottom: 10px;
            text-transform: uppercase;
}
#glCanvas {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#previewControls {
    position: fixed;
    right: 320px;
    bottom: 20px;
    background: rgba(0, 0, 0, 0.45);
    color: #f5f5f5;
    font-family: 'Abel', sans-serif;
    font-size: 13px;
    padding: 6px 12px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
    z-index: 120;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

#previewControls label {
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-size: 11px;
    color: #cbd5f5;
}

#previewControls input[type="range"] {
    width: 140px;
}

        #codeOutput {
            position: absolute;
            left: calc(220px + 20px);
            top: 20px;
            width: 360px;
            height: 240px;
            background: #1a202c;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
            display: none;
            z-index: 90;
            padding: 0;
            resize: both;
            overflow: auto;
        }

        #codeOutput pre {
            font-family: 'Source Code Pro', monospace;
            font-size: 11px;
            margin: 0;
            padding: 12px;
            color: #68d391;
            white-space: pre;
            min-width: 100%;
            min-height: 100%;
            box-sizing: border-box;
        }

        #sidebarControls {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #sidebarControls button {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-family: 'Abel', sans-serif;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }

        #sidebarControls #toggleCode {
            background: #4a5568;
            color: #fff;
        }

        #sidebarControls #toggleCode:hover {
            background: #5a67d8;
        }

        #sidebarControls #exportShader {
            background: #68d391;
            color: #1a202c;
        }

        #sidebarControls #exportShader:hover {
            background: #9ae6b4;
        }

        #recycleBin {
            position: absolute;
            left: calc(220px + 20px);
            bottom: 20px;
            width: 160px;
            height: 90px;
            border: 2px dashed rgba(255, 99, 71, 0.6);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: rgba(63, 34, 34, 0.85);
            background: rgba(255, 99, 71, 0.08);
            font-family: 'Abel', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 36px;
            transition: background 0.2s, transform 0.2s, border-color 0.2s;
            z-index: 80;
        }

        #recycleBin.active {
            background: rgba(255, 99, 71, 0.25);
            border-color: rgba(255, 255, 255, 0.9);
            transform: scale(1.05);
        }

        svg {
            position: absolute;
            pointer-events: none;
        }

        #drawing {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 5;
        }
    </style>
</head>
<body>

<div id="sidebar">
    <div id="sidebarControls">
        <button id="toggleCode">Show GLSL</button>
        <button id="exportShader">Export Shadertoy</button>
    </div>
    <h3>Primitives</h3>
    <div class="menu-item primitive" data-type="Sphere">Sphere</div>
    <div class="menu-item primitive" data-type="Box">Box</div>
    <div class="menu-item primitive" data-type="Torus">Torus</div>
    <div class="menu-item primitive" data-type="Cylinder">Cylinder</div>
    <div class="menu-item primitive" data-type="Plane">Plane</div>
    <div class="menu-item primitive" data-type="Pyramid">Pyramid</div>
    <div class="menu-item primitive" data-type="VesicaSegment">Vesica Segment</div>
    
    <h3>Operations</h3>
    <div class="menu-item operation" data-type="opUnion">Union</div>
    <div class="menu-item operation" data-type="opSmoothUnion">Smooth Union</div>
    <div class="menu-item operation" data-type="opSubtraction">Subtraction</div>
    <div class="menu-item operation" data-type="opSmoothSubtraction">Smooth Subtract</div>
    <div class="menu-item operation" data-type="opIntersection">Intersection</div>
    <div class="menu-item operation" data-type="opSmoothIntersection">Smooth Intersect</div>
    <div class="menu-item operation" data-type="opXor">XOR</div>

    <h3>Modifiers</h3>
    <div class="menu-item modifier" data-type="opRound">Round (Bevel)</div>
    <div class="menu-item modifier" data-type="opOnion">Onion (Shell)</div>
    <div class="menu-item modifier" data-type="opTwist">Twist</div>
    <div class="menu-item modifier" data-type="opElongate">Elongate</div>
    <div class="menu-item modifier" data-type="opCheapBend">Cheap Bend</div>
    <div class="menu-item modifier" data-type="opSymX">Mirror X</div>
</div>

<div id="paramPanel">
    <h3 id="paramNodeName">Parameters</h3>
    <div id="paramContent"></div>
</div>

<div id="drawing"></div>
<div id="rootnode">
    <div class="node scene" id="scene" data-type="Scene" style="left: 50%; top: 5%;">
        <div class="nodetitle">Scene</div>
    </div>
</div>

<canvas id="glCanvas"></canvas>
<div id="codeOutput">
    <pre id="codeOutputContent"></pre>
</div>
<div id="recycleBin">
    <div>♻</div>
    <small>Recycle</small>
</div>
<div id="previewControls">
    <label for="pixelScaleSlider">Pixel size</label>
    <input type="range" id="pixelScaleSlider" min="0" max="4" step="1" value="0">
    <span id="pixelScaleLabel">1x</span>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/2.7.1/svg.min.js"></script>
<script>
// Node type definitions
const NODE_TYPES = {
    Scene: {
        category: 'scene',
        maxChildren: 99,
        params: {}
    },
    Sphere: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            radius: { default: 0.5, min: 0.05, max: 3, step: 0.05 }
        }
    },
    Box: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            sizeX: { default: 0.5, min: 0.05, max: 3, step: 0.05 },
            sizeY: { default: 0.5, min: 0.05, max: 3, step: 0.05 },
            sizeZ: { default: 0.5, min: 0.05, max: 3, step: 0.05 }
        }
    },
    Torus: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            majorRadius: { default: 0.5, min: 0.1, max: 2, step: 0.05 },
            minorRadius: { default: 0.2, min: 0.05, max: 1, step: 0.05 }
        }
    },
    Cylinder: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            radius: { default: 0.3, min: 0.05, max: 2, step: 0.05 },
            height: { default: 1.0, min: 0.1, max: 5, step: 0.1 }
        }
    },
    Plane: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            height: { default: 0, min: -5, max: 5, step: 0.1 }
        }
    },
    Pyramid: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            height: { default: 1.0, min: 0.1, max: 5.0, step: 0.1 }
        }
    },
    VesicaSegment: {
        category: 'primitive',
        maxChildren: 0,
        params: {
            ax: { default: -0.5, min: -3, max: 3, step: 0.1 },
            ay: { default: 0.0, min: -3, max: 3, step: 0.1 },
            az: { default: 0.0, min: -3, max: 3, step: 0.1 },
            bx: { default: 0.5, min: -3, max: 3, step: 0.1 },
            by: { default: 0.0, min: -3, max: 3, step: 0.1 },
            bz: { default: 0.0, min: -3, max: 3, step: 0.1 },
            width: { default: 0.25, min: 0.01, max: 3.0, step: 0.01 }
        }
    },
    opUnion: {
        category: 'operation',
        maxChildren: 2,
        params: {}
    },
    opSmoothUnion: {
        category: 'operation',
        maxChildren: 2,
        params: {
            k: { default: 0.3, min: 0.01, max: 1, step: 0.01 }
        }
    },
    opSubtraction: {
        category: 'operation',
        maxChildren: 2,
        params: {}
    },
    opSmoothSubtraction: {
        category: 'operation',
        maxChildren: 2,
        params: {
            k: { default: 0.3, min: 0.01, max: 1, step: 0.01 }
        }
    },
    opIntersection: {
        category: 'operation',
        maxChildren: 2,
        params: {}
    },
    opSmoothIntersection: {
        category: 'operation',
        maxChildren: 2,
        params: {
            k: { default: 0.3, min: 0.01, max: 1, step: 0.01 }
        }
    },
    opXor: {
        category: 'operation',
        maxChildren: 2,
        params: {}
    },
    opRound: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            roundRadius: { default: 0.1, min: 0.0, max: 1.0, step: 0.01 }
        }
    },
    opOnion: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            shellThickness: { default: 0.05, min: 0.0, max: 1.0, step: 0.01 }
        }
    },
    opTwist: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            twistAmount: { default: 2.0, min: -20.0, max: 20.0, step: 0.1 }
        }
    },
    opElongate: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            extentX: { default: 0.3, min: 0.0, max: 2.0, step: 0.05 },
            extentY: { default: 0.3, min: 0.0, max: 2.0, step: 0.05 },
            extentZ: { default: 0.3, min: 0.0, max: 2.0, step: 0.05 }
        }
    },
    opCheapBend: {
        category: 'modifier',
        maxChildren: 1,
        params: {
            bendAmount: { default: 2.0, min: -20.0, max: 20.0, step: 0.1 }
        }
    },
    opSymX: {
        category: 'modifier',
        maxChildren: 1,
        params: {}
    }
};

const TRANSFORM_PARAMS = {
    posX: { default: 0, min: -5, max: 5, step: 0.1 },
    posY: { default: 0, min: -5, max: 5, step: 0.1 },
    posZ: { default: 0, min: -5, max: 5, step: 0.1 },
    rotX: { default: 0, min: -180, max: 180, step: 1 },
    rotY: { default: 0, min: -180, max: 180, step: 1 },
    rotZ: { default: 0, min: -180, max: 180, step: 1 },
    scale: { default: 1.0, min: 0.1, max: 5.0, step: 0.05 }
};

function getNodeParams(node) {
    if (node._sdfParams) return node._sdfParams;
    const parsed = node.dataset.params ? JSON.parse(node.dataset.params) : {};
    node._sdfParams = parsed;
    return parsed;
}

function setNodeParams(node, params) {
    node._sdfParams = params;
    node.dataset.params = JSON.stringify(params);
}

function ensureDetachHandle(node) {
    if (node.dataset.type === 'Scene') return;
    if (!node.querySelector('.detach-wrapper')) {
        const wrapper = document.createElement('div');
        wrapper.className = 'detach-wrapper';
        const handle = document.createElement('div');
        handle.className = 'detach-handle';
        handle.textContent = '×';
        wrapper.appendChild(handle);
        node.appendChild(wrapper);
    }
    attachNodeHoverHandlers(node);
    attachDetachWrapperHandlers(node);
}

// State
let dragging = false;
let dragged = null;
let detached = false;
let dragFromMenu = false;
let pos1, pos2, pos3, pos4;
let selectedNode = null;
let nodeCounter = 0;

let dropPreview = null;
let currentDropTarget = null;

const draw = SVG('drawing').size('100%', '100%');
let nodesArray = [];
let lines = [];
const recycleBin = document.getElementById('recycleBin');
const recycleRect = () => recycleBin.getBoundingClientRect();
let recycleActive = false;
const codeOutput = document.getElementById('codeOutput');
const codeOutputContent = document.getElementById('codeOutputContent');
const pixelScaleSlider = document.getElementById('pixelScaleSlider');
const pixelScaleLabel = document.getElementById('pixelScaleLabel');

// Camera state for preview orbit controls
const CAMERA_STATE = {
    yaw: 0,
    pitch: 0,
    distance: 4,
    target: { x: 0, y: 0, z: 0 }
};
let cameraUniformLocations = { pos: null, target: null };
let cameraDragMode = null;
let cameraLastX = 0;
let cameraLastY = 0;

// Simple performance logger (toggle via window.SDF_PERF.enabled)
const SDF_PERF = {
    enabled: false
};

function perfNow() {
    return performance.now();
}

function perfLogDuration(label, startTime, extra = '') {
    return startTime;
}

function perfLogInfo(label, info) {
}

window.SDF_PERF = SDF_PERF;

// WebGL state
let gl, program;
let uniformLocations = {};
let vertexBuffer = null;
const pendingSliderUpdates = new Map();
let sliderFlushHandle = null;

const PREVIEW_PIXEL_SCALES = [1, 2, 4, 8, 16];
let previewScaleIndex = 0;

// Initialize
function init() {
    scanNodes();
    addLines();
    initializeNodeParams();
    setupEventListeners();
    if (pixelScaleSlider) {
        const initial = parseInt(pixelScaleSlider.value, 10);
        previewScaleIndex = Math.max(0, Math.min(PREVIEW_PIXEL_SCALES.length - 1, isNaN(initial) ? 0 : initial));
    } else {
        previewScaleIndex = 0;
    }
    updatePixelScaleLabel();
    initWebGL();
    applyPreviewScale();
    recompilePreview();
}

function scanNodes() {
    const nodesObject = document.getElementsByClassName("node");
    nodesArray = [];
    for (let i = 0; i < nodesObject.length; i++) {
        nodesArray.push(nodesObject[i]);
        if (!nodesObject[i].id || nodesObject[i].id === '') {
            nodesObject[i].id = 'node_' + nodeCounter++;
        }
        ensureDetachHandle(nodesObject[i]);
    }
}

function initializeNodeParams() {
    nodesArray.forEach(node => {
        if (!node.dataset.params) {
            const nodeType = node.dataset.type;
            const typeDef = NODE_TYPES[nodeType];
            const params = {};
            
            if (typeDef && typeDef.params) {
                for (const [key, val] of Object.entries(typeDef.params)) {
                    params[key] = val.default;
                }
            }
            
            if (nodeType !== 'Scene') {
                for (const [key, val] of Object.entries(TRANSFORM_PARAMS)) {
                    params[key] = val.default;
                }
            }
            
            setNodeParams(node, params);
        } else {
            node._sdfParams = JSON.parse(node.dataset.params);
        }
    });
}

function addLines() {
    for (let i = 0; i < nodesArray.length; i++) {
        addLine(i);
    }
}

function addLine(num) {
    const node = nodesArray[num];
    const box1 = node.getBoundingClientRect();
    const box2 = node.parentNode.getBoundingClientRect();
    const x1 = box1.left + (box1.width / 2);
    const y1 = box1.top + (box1.height / 2);
    const x2 = box2.left + (box2.width / 2);
    const y2 = box2.top + (box2.height / 2);
    
    if (lines[num]) {
        lines[num].plot([['M', x1, y1], ['C', x1, y2, x2, y1, x2, y2]]);
    } else {
        lines[num] = draw.path([['M', x1, y1], ['C', x1, y2, x2, y1, x2, y2]])
            .fill('none')
            .stroke({ width: 2, color: "#888888" });
    }
    
    if (!node.parentNode.classList.contains("node")) {
        lines[num].hide();
    } else {
        lines[num].show();
    }
}
function generateShadertoyShader() {
    const sdfCode = generateExportGLSL();
    
    return `// Generated with SDF Builder
// Paste into Shadertoy

${sdfCode}

vec3 calcNormal(vec3 p) {
    vec2 e = vec2(0.001, 0.0);
    return normalize(vec3(
        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),
        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),
        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)
    ));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    
    vec3 ro = vec3(0.0, 0.0, 3.0);
    vec3 rd = normalize(vec3(uv, -1.0));
    
    float t = 0.0;
    vec3 col = vec3(1.0);
    
    for (int i = 0; i < 100; i++) {
        vec3 p = ro + rd * t;
        float d = sceneSDF(p);
        
        if (d < 0.001) {
            vec3 n = calcNormal(p);
            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
            float diff = max(dot(n, lightDir), 0.0);
            float amb = 0.3;
            col = vec3(0.85, 0.75, 0.7) * (diff + amb);
            break;
        }
        
        if (t > 20.0) break;
        t += d;
    }
    
    fragColor = vec4(col, 1.0);
}
`;
}

function downloadShadertoyShader() {
    const shaderCode = generateShadertoyShader();
    const blob = new Blob([shaderCode], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'sdf_shader.glsl';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
function updateLine(node) {
    const nodeIndex = nodesArray.indexOf(node);
    if (nodeIndex >= 0) {
        addLine(nodeIndex);
    }
    
    const children = node.querySelectorAll('.node');
    children.forEach(child => {
        const childIndex = nodesArray.indexOf(child);
        if (childIndex >= 0) {
            addLine(childIndex);
        }
    });
}

function setupEventListeners() {
    document.addEventListener('mousedown', onDocumentMouseDown, false);
    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('mouseup', onDocumentMouseUp, false);
    document.addEventListener('contextmenu', e => e.preventDefault(), false);
    
    window.addEventListener('resize', () => {
        updateLine(document.getElementById("rootnode"));
        applyPreviewScale();
    }, false);
    
    document.querySelectorAll('.menu-item').forEach(item => {
        item.addEventListener('mousedown', onMenuItemMouseDown, false);
    });
    
    const toggleBtn = document.getElementById('toggleCode');
    toggleBtn.addEventListener('click', () => {
        if (codeOutput.style.display === 'none' || codeOutput.style.display === '') {
            codeOutput.style.display = 'block';
            toggleBtn.textContent = 'Hide GLSL';
            codeOutputContent.textContent = generateExportGLSL();
        } else {
            codeOutput.style.display = 'none';
            toggleBtn.textContent = 'Show GLSL';
        }
    });

    document.getElementById('exportShader').addEventListener('click', () => {
    // Try to copy to clipboard first
    const shaderCode = generateShadertoyShader();
    
    if (navigator.clipboard) {
        navigator.clipboard.writeText(shaderCode).then(() => {
            alert('Shadertoy shader copied to clipboard!');
        }).catch(() => {
            // Fallback to download
            downloadShadertoyShader();
        });
    } else {
        // Fallback to download
        downloadShadertoyShader();
    }
});

    document.addEventListener('mousedown', onDetachHandleMouseDown);
    document.addEventListener('wheel', handleCameraWheel, { passive: false });
    if (pixelScaleSlider) {
        pixelScaleSlider.addEventListener('input', handlePixelScaleInput);
    }
}

function onMenuItemMouseDown(event) {
    event.preventDefault();
    const nodeType = event.target.dataset.type;
    
    const newNode = createNode(nodeType);
    document.getElementById("rootnode").appendChild(newNode);
    nodesArray.push(newNode);
    
    newNode.style.left = event.clientX - 50 + "px";
    newNode.style.top = event.clientY - 15 + "px";
    
    addLine(nodesArray.length - 1);
    
    pos3 = event.clientX;
    pos4 = event.clientY;
    newNode.dataset.dragOffsetX = 50;
    newNode.dataset.dragOffsetY = 15;
    dragging = true;
    dragged = newNode;
    detached = true;
    dragFromMenu = true;
}

function createNode(nodeType) {
    const typeDef = NODE_TYPES[nodeType];
    const newNode = document.createElement("DIV");
    const newText = document.createElement("DIV");
    const detachWrapper = document.createElement('div');
    const detachHandle = document.createElement('div');
    
    newText.className = "nodetitle";
    newText.textContent = nodeType;
    
    newNode.className = "node " + typeDef.category;
    newNode.id = 'node_' + nodeCounter++;
    newNode.dataset.type = nodeType;
    
    const params = {};
    if (typeDef.params) {
        for (const [key, val] of Object.entries(typeDef.params)) {
            params[key] = val.default;
        }
    }
    for (const [key, val] of Object.entries(TRANSFORM_PARAMS)) {
        params[key] = val.default;
    }
    setNodeParams(newNode, params);
    
    if (nodeType !== 'Scene') {
        detachWrapper.className = 'detach-wrapper';
        detachHandle.className = 'detach-handle';
        detachHandle.textContent = '×';
        detachWrapper.appendChild(detachHandle);
        newNode.appendChild(detachWrapper);
    }
    attachNodeHoverHandlers(newNode);
    attachDetachWrapperHandlers(newNode);
    newNode.appendChild(newText);
    return newNode;
}

function attachNodeHoverHandlers(node) {
    if (node.dataset.type === 'Scene' || node._hoverHandlersAttached) return;
    node.addEventListener('mouseover', handleNodeMouseOver);
    node.addEventListener('mouseout', handleNodeMouseOut);
    node._hoverHandlersAttached = true;
}

function attachDetachWrapperHandlers(node) {
    if (node.dataset.type === 'Scene') return;
    const wrapper = node.querySelector('.detach-wrapper');
    if (!wrapper || wrapper._hoverHandlersAttached) return;
    wrapper.addEventListener('mouseenter', () => {
        node.classList.add('node-hover');
    });
    wrapper.addEventListener('mouseleave', (event) => {
        const related = event.relatedTarget;
        if (related && (node.contains(related) || wrapper.contains(related))) return;
        node.classList.remove('node-hover');
    });
    wrapper._hoverHandlersAttached = true;
}

function handleNodeMouseOver(event) {
    if (event.target !== event.currentTarget) return;
    event.currentTarget.classList.add('node-hover');
    const wrapper = event.currentTarget.querySelector('.detach-wrapper');
    if (wrapper) {
        wrapper.setAttribute('aria-label', 'Click to detach and drag this node');
    }
}

function handleNodeMouseOut(event) {
    if (event.target !== event.currentTarget) return;
    const related = event.relatedTarget;
    if (related && event.currentTarget.contains(related)) return;
    event.currentTarget.classList.remove('node-hover');
    const wrapper = event.currentTarget.querySelector('.detach-wrapper');
    if (wrapper) {
        wrapper.removeAttribute('aria-label');
    }
}

function getCameraPosition() {
    const dist = Math.max(0.5, CAMERA_STATE.distance);
    const cosPitch = Math.cos(CAMERA_STATE.pitch);
    const sinPitch = Math.sin(CAMERA_STATE.pitch);
    const cosYaw = Math.cos(CAMERA_STATE.yaw);
    const sinYaw = Math.sin(CAMERA_STATE.yaw);
    return {
        x: CAMERA_STATE.target.x + dist * cosPitch * sinYaw,
        y: CAMERA_STATE.target.y + dist * sinPitch,
        z: CAMERA_STATE.target.z + dist * cosPitch * cosYaw
    };
}

function getCameraBasis() {
    const pos = getCameraPosition();
    const target = CAMERA_STATE.target;
    let forward = normalizeVector({
        x: target.x - pos.x,
        y: target.y - pos.y,
        z: target.z - pos.z
    });
    let right = normalizeVector(crossVector(forward, { x: 0, y: 1, z: 0 }));
    if (lengthVector(right) < 0.001) {
        right = { x: 1, y: 0, z: 0 };
    }
    const up = normalizeVector(crossVector(right, forward));
    return { forward, right, up };
}

function updateCameraUniforms() {
    if (!gl || !program || !cameraUniformLocations.pos || !cameraUniformLocations.target) return;
    const pos = getCameraPosition();
    gl.uniform3f(cameraUniformLocations.pos, pos.x, pos.y, pos.z);
    gl.uniform3f(cameraUniformLocations.target, CAMERA_STATE.target.x, CAMERA_STATE.target.y, CAMERA_STATE.target.z);
}

function beginCameraDrag(mode, x, y) {
    cameraDragMode = mode;
    cameraLastX = x;
    cameraLastY = y;
    document.body.style.cursor = mode === 'pan' ? 'move' : 'grab';
}

function updateCameraDrag(x, y) {
    if (!cameraDragMode) return;
    const dx = x - cameraLastX;
    const dy = y - cameraLastY;
    cameraLastX = x;
    cameraLastY = y;
    const { right, up } = getCameraBasis();
    if (cameraDragMode === 'orbit') {
        CAMERA_STATE.yaw -= dx * 0.005;
        CAMERA_STATE.pitch = clamp(CAMERA_STATE.pitch + dy * 0.003, -1.4, 1.4);
    } else if (cameraDragMode === 'pan') {
        const panScale = CAMERA_STATE.distance * 0.002;
        CAMERA_STATE.target.x -= (dx * panScale) * right.x;
        CAMERA_STATE.target.y -= (dx * panScale) * right.y;
        CAMERA_STATE.target.z -= (dx * panScale) * right.z;
        CAMERA_STATE.target.x += (dy * panScale) * up.x;
        CAMERA_STATE.target.y += (dy * panScale) * up.y;
        CAMERA_STATE.target.z += (dy * panScale) * up.z;
    }
    updateCameraUniforms();
    renderPreview();
}

function endCameraDrag() {
    cameraDragMode = null;
    document.body.style.cursor = '';
}

function handleCameraWheel(event) {
    if (!isStageInteractionTarget(event.target)) return;
    event.preventDefault();
    const zoomFactor = Math.exp(event.deltaY * 0.001);
    CAMERA_STATE.distance = clamp(CAMERA_STATE.distance * zoomFactor, 0.8, 50);
    updateCameraUniforms();
    renderPreview();
}

function isStageInteractionTarget(target) {
    if (!target) return false;
    return !(
        target.closest('#sidebar') ||
        target.closest('#paramPanel') ||
        target.closest('.node') ||
        target.closest('.menu-item') ||
        target.closest('#sidebarControls') ||
        target.closest('#recycleBin') ||
        target.closest('.detach-wrapper')
    );
}

function normalizeVector(v) {
    const len = lengthVector(v);
    if (len < 1e-6) return { x: 0, y: 0, z: 0 };
    return { x: v.x / len, y: v.y / len, z: v.z / len };
}

function lengthVector(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

function crossVector(a, b) {
    return {
        x: a.y * b.z - a.z * b.y,
        y: a.z * b.x - a.x * b.z,
        z: a.x * b.y - a.y * b.x
    };
}

function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

function getNodeChildren(node) {
    return Array.from(node.children).filter(child => child.classList.contains('node'));
}

function canAcceptChild(parentNode) {
    const parentType = parentNode.dataset.type;
    const typeDef = NODE_TYPES[parentType];
    if (!typeDef) return false;
    
    const currentChildren = getNodeChildren(parentNode);
    return currentChildren.length < typeDef.maxChildren;
}

function attachNodeToParent(child, parent) {
    if (!canAcceptChild(parent)) {
        document.getElementById("rootnode").appendChild(child);
        positionNodeAtPoint(child, pos3, pos4);
        return false;
    }
    
    reparentNodePreservingPosition(child, parent);
    updateLine(child);
    recompilePreview(); // Structure changed - recompile
    return true;
}

function reparentNodePreservingPosition(node, newParent) {
    const nodeRect = node.getBoundingClientRect();
    const parentRect = newParent.getBoundingClientRect();
    newParent.appendChild(node);
    node.style.left = `${nodeRect.left - parentRect.left}px`;
    node.style.top = `${nodeRect.top - parentRect.top}px`;
}

function positionNodeAtPoint(node, clientX, clientY) {
    const parent = node.parentNode || document.getElementById('rootnode');
    const parentRect = parent.getBoundingClientRect();
    const offsetX = Number(node.dataset.dragOffsetX ?? node.offsetWidth / 2);
    const offsetY = Number(node.dataset.dragOffsetY ?? node.offsetHeight / 2);
    node.style.left = `${clientX - parentRect.left - offsetX}px`;
    node.style.top = `${clientY - parentRect.top - offsetY}px`;
}

function detachNodeToRoot(node) {
    const root = document.getElementById('rootnode');
    reparentNodePreservingPosition(node, root);
    updateLine(node);
    recompilePreview();
}

function onDetachHandleMouseDown(event) {
    const wrapper = event.target.closest('.detach-wrapper');
    if (!wrapper) return;
    event.preventDefault();
    event.stopPropagation();
    const node = wrapper.closest('.node');
    if (!node || node.dataset.type === 'Scene') return;
    detachNodeToRoot(node);
    pos3 = event.clientX;
    pos4 = event.clientY;
    selectNode(node);
    startNodeDrag(node);
}

function selectNode(node) {
    if (selectedNode) {
        selectedNode.classList.remove('selected');
    }
    
    if (node && node.dataset.type !== 'Scene') {
        selectedNode = node;
        node.classList.add('selected');
        showParamPanel(node);
    } else {
        selectedNode = null;
        hideParamPanel();
    }
}

function showParamPanel(node) {
    const panel = document.getElementById('paramPanel');
    const content = document.getElementById('paramContent');
    const nodeName = document.getElementById('paramNodeName');
    
    const nodeType = node.dataset.type;
    const typeDef = NODE_TYPES[nodeType];
    const params = getNodeParams(node);
    
    nodeName.textContent = nodeType;
    content.innerHTML = '';
    
    if (typeDef.params && Object.keys(typeDef.params).length > 0) {
        const section = document.createElement('div');
        section.className = 'param-section';
        section.innerHTML = '<div class="param-section-title">Shape Parameters</div>';
        
        for (const [key, def] of Object.entries(typeDef.params)) {
            section.appendChild(createParamSlider(node, key, def, params[key]));
        }
        content.appendChild(section);
    }
    
    const transformSection = document.createElement('div');
    transformSection.className = 'param-section';
    transformSection.innerHTML = '<div class="param-section-title">Transform</div>';
    
    for (const [key, def] of Object.entries(TRANSFORM_PARAMS)) {
        transformSection.appendChild(createParamSlider(node, key, def, params[key]));
    }
    content.appendChild(transformSection);
    
    panel.classList.add('visible');
}

function createParamSlider(node, key, def, value) {
    const group = document.createElement('div');
    group.className = 'param-group';
    
    const label = document.createElement('label');
    label.textContent = key;
    
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = def.min;
    slider.max = def.max;
    slider.step = def.step;
    slider.value = value;
    
    const valueDisplay = document.createElement('div');
    valueDisplay.className = 'value-display';
    valueDisplay.textContent = value.toFixed(2);
    
    slider.addEventListener('input', () => {
        const numericValue = parseFloat(slider.value);
        valueDisplay.textContent = numericValue.toFixed(2);
        queueSliderUpdate(node, key, numericValue);
    });
    
    group.appendChild(label);
    group.appendChild(slider);
    group.appendChild(valueDisplay);
    
    return group;
}

function queueSliderUpdate(node, key, value) {
    let entry = pendingSliderUpdates.get(node);
    if (!entry) {
        entry = { node, changes: {} };
        pendingSliderUpdates.set(node, entry);
    }
    entry.changes[key] = value;
    if (!sliderFlushHandle) {
        sliderFlushHandle = requestAnimationFrame(() => {
            sliderFlushHandle = null;
            flushPendingSliderUpdates();
        });
    }
}

function flushPendingSliderUpdates() {
    if (!pendingSliderUpdates.size) return;
    pendingSliderUpdates.forEach(({ node, changes }) => {
        const params = getNodeParams(node);
        Object.assign(params, changes);
        setNodeParams(node, params);
    });
    pendingSliderUpdates.clear();
    updatePreviewUniforms();
}

function getPreviewScale() {
    return PREVIEW_PIXEL_SCALES[previewScaleIndex] || 1;
}

function updatePixelScaleLabel() {
    if (!pixelScaleLabel) return;
    pixelScaleLabel.textContent = `${getPreviewScale()}x`;
}

function applyPreviewScale() {
    const canvas = document.getElementById('glCanvas');
    if (!canvas) return;
    const scale = getPreviewScale();
    canvas.width = Math.max(64, Math.floor(window.innerWidth / scale));
    canvas.height = Math.max(64, Math.floor(window.innerHeight / scale));
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    if (gl) {
        gl.viewport(0, 0, canvas.width, canvas.height);
        if (program) {
            gl.useProgram(program);
            const resLoc = gl.getUniformLocation(program, 'resolution');
            if (resLoc) {
                gl.uniform2f(resLoc, canvas.width, canvas.height);
            }
            renderPreview();
        }
    }
}

function handlePixelScaleInput(event) {
    const raw = parseInt(event.target.value, 10);
    const clamped = Math.max(0, Math.min(PREVIEW_PIXEL_SCALES.length - 1, isNaN(raw) ? 0 : raw));
    if (clamped === previewScaleIndex) return;
    previewScaleIndex = clamped;
    updatePixelScaleLabel();
    applyPreviewScale();
}

function hideParamPanel() {
    document.getElementById('paramPanel').classList.remove('visible');
}

function onDocumentMouseDown(event) {
    const target = event.target;
    
    if (target.closest('.detach-wrapper')) {
        return;
    }
    
    if (target.closest('#sidebar') || target.closest('#paramPanel') || 
        target.closest('#glCanvas') || target.closest('#codeOutput') ||
        target.closest('#toggleCode') || target.closest('#previewControls')) {
        return;
    }
    
    if (target.classList.contains("node") || target.parentNode.classList.contains("node")) {
        event.preventDefault();
        const node = target.classList.contains("node") ? target : target.parentNode;
        
        pos3 = event.clientX;
        pos4 = event.clientY;
        
        selectNode(node);
        startNodeDrag(node);
    } else {
        selectNode(null);
        if (isStageInteractionTarget(target)) {
            if (event.button === 0) {
                beginCameraDrag('orbit', event.clientX, event.clientY);
            } else if (event.button === 2) {
                beginCameraDrag('pan', event.clientX, event.clientY);
            }
        }
    }
}

function onDocumentMouseMove(event) {
    if (cameraDragMode) {
        event.preventDefault();
        updateCameraDrag(event.clientX, event.clientY);
        return;
    }
    if (dragging) {
        event.preventDefault();
        pos1 = pos3 - event.clientX;
        pos2 = pos4 - event.clientY;
        pos3 = event.clientX;
        pos4 = event.clientY;
        nodeDrag();
    }
}

function onDocumentMouseUp(event) {
    if (cameraDragMode) {
        event.preventDefault();
        endCameraDrag();
        return;
    }
    if (dragging) {
        event.preventDefault();
        
        if (detached) {
            const attached = finalizeDrop(event.clientX, event.clientY);
            if (!attached && dragged.parentNode.id === "rootnode") {
                positionNodeAtPoint(dragged, event.clientX, event.clientY);
                recompilePreview(); // Node detached - structure changed
            }
        }
        
        clearDropPreview();
        stopNodeDrag();
    }
}

function startNodeDrag(node) {
    dragging = true;
    dragged = node;
    detached = node.parentNode.id === "rootnode";
    const rect = node.getBoundingClientRect();
    const offsetX = pos3 - rect.left;
    const offsetY = pos4 - rect.top;
    node.dataset.dragOffsetX = offsetX;
    node.dataset.dragOffsetY = offsetY;
}

function nodeDrag() {
    const parentRect = dragged.parentNode.getBoundingClientRect();
    dragged.style.left = `${pos3 - parentRect.left - dragged.dataset.dragOffsetX}px`;
    dragged.style.top = `${pos4 - parentRect.top - dragged.dataset.dragOffsetY}px`;
    updateLine(dragged);
    if (detached) {
        updateDropPreview();
    } else {
        clearDropPreview();
    }
    updateRecyclePreview();
}

function stopNodeDrag() {
    dragging = false;
    detached = false;
    dragFromMenu = false;
    dragged = null;
    clearDropPreview();
    clearRecyclePreview();
}

function isValidDropTarget(child, target) {
    if (!target || target === child) return false;
    if (!target.classList || !target.classList.contains('node')) return false;
    if (child.contains && child.contains(target)) return false;
    return canAcceptChild(target);
}

function getDropZoneRect(node) {
    const rect = node.getBoundingClientRect();
    const padding = 10;
    const width = rect.width * 1.2;
    const height = rect.height * 2.2;
    const centerX = rect.left + rect.width / 2;
    return {
        left: centerX - width / 2,
        right: centerX + width / 2,
        top: rect.bottom + padding,
        bottom: rect.bottom + padding + height,
        anchorX: centerX,
        anchorY: rect.top + rect.height / 2
    };
}

function findDropTarget(x, y) {
    for (const node of nodesArray) {
        if (!isValidDropTarget(dragged, node)) continue;
        const zone = getDropZoneRect(node);
        if (x >= zone.left && x <= zone.right && y >= zone.top && y <= zone.bottom) {
            return { node, zone };
        }
    }
    return null;
}

function getPreviewPathData(zone, pointerX, pointerY) {
    const midY = (zone.anchorY + pointerY) / 2;
    return [
        ['M', zone.anchorX, zone.anchorY],
        ['C', zone.anchorX, midY, pointerX, midY, pointerX, pointerY]
    ];
}

function updateDropPreview() {
    if (!dragged) return;
    const pointerX = pos3;
    const pointerY = pos4;
    if (!Number.isFinite(pointerX) || !Number.isFinite(pointerY)) return;
    
    const targetInfo = findDropTarget(pointerX, pointerY);
    if (!targetInfo) {
        clearDropPreview();
        return;
    }
    
    if (currentDropTarget === targetInfo.node) {
        if (dropPreview) {
            dropPreview.plot(getPreviewPathData(targetInfo.zone, pointerX, pointerY));
        }
        return;
    }
    
    currentDropTarget = targetInfo.node;
    const pathData = getPreviewPathData(targetInfo.zone, pointerX, pointerY);
    if (!dropPreview) {
        dropPreview = draw.path(pathData)
            .fill('none')
            .stroke({ width: 2, color: '#f6ad55', dasharray: '6 4', linecap: 'round' });
    } else {
        dropPreview.plot(pathData);
    }
}

function clearDropPreview() {
    if (dropPreview) {
        dropPreview.remove();
        dropPreview = null;
    }
    currentDropTarget = null;
}

function updateRecyclePreview() {
    if (!dragged) return;
    const rect = recycleRect();
    const inBin = pos3 >= rect.left && pos3 <= rect.right && pos4 >= rect.top && pos4 <= rect.bottom;
    if (inBin && !recycleActive) {
        recycleActive = true;
        recycleBin.classList.add('active');
    } else if (!inBin && recycleActive) {
        recycleActive = false;
        recycleBin.classList.remove('active');
    }
}

function clearRecyclePreview() {
    recycleActive = false;
    recycleBin.classList.remove('active');
}

function checkRecycleBin(clientX, clientY) {
    const rect = recycleRect();
    return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
}

function deleteNodeWithChildren(node) {
    if (!node || node.id === 'scene') return;
    if (selectedNode && (selectedNode === node || node.contains(selectedNode))) {
        selectNode(null);
    }
    node.remove();
    scanNodes();
    draw.clear();
    lines = [];
    dropPreview = null;
    currentDropTarget = null;
    addLines();
    recompilePreview();
}

function finalizeDrop(clientX, clientY) {
    if (checkRecycleBin(clientX, clientY)) {
        deleteNodeWithChildren(dragged);
        clearDropPreview();
        clearRecyclePreview();
        recompilePreview();
        return true;
    }
    
    if (currentDropTarget && attachNodeToParent(dragged, currentDropTarget)) {
        clearDropPreview();
        clearRecyclePreview();
        return true;
    }
    
    dragged.hidden = true;
    const elemBelow = document.elementFromPoint(clientX, clientY);
    dragged.hidden = false;
    
    if (elemBelow) {
        let targetNode = null;
        if (elemBelow.classList.contains("node")) {
            targetNode = elemBelow;
        } else if (elemBelow.parentNode && elemBelow.parentNode.classList.contains("node")) {
            targetNode = elemBelow.parentNode;
        }
        
        if (isValidDropTarget(dragged, targetNode)) {
            clearDropPreview();
            clearRecyclePreview();
            return attachNodeToParent(dragged, targetNode);
        }
    }
    
    clearDropPreview();
    clearRecyclePreview();
    return false;
}

// Helper to traverse all nodes connected to scene
function traverseSceneNodes(callback) {
    const sceneNode = document.getElementById('scene');
    
    function traverse(node) {
        if (node.dataset.type !== 'Scene') {
            callback(node);
        }
        getNodeChildren(node).forEach(child => traverse(child));
    }
    
    traverse(sceneNode);
}

function getSceneStats() {
    const sceneNode = document.getElementById('scene');
    let count = 0;
    let depth = 0;
    
    function traverse(node, currentDepth) {
        if (node.dataset.type !== 'Scene') {
            count++;
            depth = Math.max(depth, currentDepth);
        }
        getNodeChildren(node).forEach(child => traverse(child, currentDepth + 1));
    }
    
    traverse(sceneNode, 0);
    return { nodeCount: count, maxDepth: depth };
}

function getNodeVarName(node) {
    return 'd_' + node.id.replace(/[^a-zA-Z0-9]/g, '_');
}

// ===========================================
// EXPORT GLSL - Hardcoded values (for output)
// ===========================================
function generateExportGLSL() {
    const t0 = perfNow();
    const sceneNode = document.getElementById('scene');
    const children = getNodeChildren(sceneNode);
    
    let code = getSDFPreamble();
    
    if (children.length === 0) {
        code += `float sceneSDF(vec3 p) {
    return 1000.0; // Empty scene
}`;
    } else if (children.length === 1) {
        code += `
float sceneSDF(vec3 p) {
${generateExportNodeCode(children[0], 'p')}
    return ${getNodeVarName(children[0])};
}`;
    } else {
        let nodeCode = '';
        children.forEach(child => {
            nodeCode += generateExportNodeCode(child, 'p');
        });
        
        let unionExpr = getNodeVarName(children[0]);
        for (let i = 1; i < children.length; i++) {
            unionExpr = `min(${unionExpr}, ${getNodeVarName(children[i])})`;
        }
        
        code += `
float sceneSDF(vec3 p) {
${nodeCode}
    return ${unionExpr};
}`;
    }
    
    const stats = getSceneStats();
    perfLogDuration('generateExportGLSL', t0, `nodes=${stats.nodeCount} depth=${stats.maxDepth}`);
    return code;
}

function generateExportNodeCode(node, pointVar) {
    const nodeType = node.dataset.type;
    const params = getNodeParams(node);
    const varName = getNodeVarName(node);
    const typeDef = NODE_TYPES[nodeType];
    
    let code = '';
    const transformedPoint = varName + '_p';
    const rad = Math.PI / 180;
    const scaleVar = `${varName}_scale`;
    
    code += `    vec3 ${transformedPoint} = ${pointVar};\n`;
    code += `    ${transformedPoint} -= vec3(${params.posX.toFixed(3)}, ${params.posY.toFixed(3)}, ${params.posZ.toFixed(3)});\n`;
    if (params.rotX !== 0) code += `    ${transformedPoint} *= rotateX(${(params.rotX * rad).toFixed(4)});\n`;
    if (params.rotY !== 0) code += `    ${transformedPoint} *= rotateY(${(params.rotY * rad).toFixed(4)});\n`;
    if (params.rotZ !== 0) code += `    ${transformedPoint} *= rotateZ(${(params.rotZ * rad).toFixed(4)});\n`;
    code += `    float ${scaleVar} = max(${params.scale.toFixed(3)}, 0.0001);\n`;
    code += `    ${transformedPoint} /= ${scaleVar};\n`;
    
    if (typeDef.category === 'primitive') {
        const distVar = `${varName}_dist`;
        const boundExpr = getPrimitiveBoundExpr(nodeType, params);
        const distExpr = getPrimitiveDistanceExpr(nodeType, transformedPoint, params);
        code += `    float ${distVar};\n`;
        if (boundExpr) {
            const skipVar = `${varName}_skip`;
            code += `    float ${skipVar} = length(${transformedPoint}) - (${boundExpr});\n`;
            code += `    if (${skipVar} > 2.0) {\n`;
            code += `        ${distVar} = ${skipVar};\n`;
            code += `    } else {\n`;
            code += `        ${distVar} = ${distExpr};\n`;
            code += `    }\n`;
        } else {
            code += `    ${distVar} = ${distExpr};\n`;
        }
        code += `    float ${varName} = ${distVar};\n`;
    } else if (typeDef.category === 'operation') {
        const children = getNodeChildren(node);
        
        if (children.length < 2) {
            code += `    float ${varName} = 1000.0; // Incomplete operation\n`;
        } else {
            code += generateExportNodeCode(children[0], transformedPoint);
            code += generateExportNodeCode(children[1], transformedPoint);
            
            const child1Var = getNodeVarName(children[0]);
            const child2Var = getNodeVarName(children[1]);
            
            switch (nodeType) {
                case 'opUnion':
                    code += `    float ${varName} = min(${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothUnion':
                    code += `    float ${varName} = opSmoothUnion(${child1Var}, ${child2Var}, ${params.k.toFixed(3)});\n`;
                    break;
                case 'opSubtraction':
                    code += `    float ${varName} = max(-${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothSubtraction':
                    code += `    float ${varName} = opSmoothSubtraction(${child1Var}, ${child2Var}, ${params.k.toFixed(3)});\n`;
                    break;
                case 'opIntersection':
                    code += `    float ${varName} = max(${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothIntersection':
                    code += `    float ${varName} = opSmoothIntersection(${child1Var}, ${child2Var}, ${params.k.toFixed(3)});\n`;
                    break;
                case 'opXor':
                    code += `    float ${varName} = opXor(${child1Var}, ${child2Var});\n`;
                    break;
        }
    }
    } else if (typeDef.category === 'modifier') {
        const children = getNodeChildren(node);
        if (children.length < 1) {
            code += `    float ${varName} = 1000.0; // Incomplete modifier\n`;
        } else {
            const child = children[0];
            const childVar = getNodeVarName(child);
            switch (nodeType) {
                case 'opRound':
                    code += generateExportNodeCode(child, transformedPoint);
                    code += `    float ${varName} = ${childVar} - ${params.roundRadius.toFixed(3)};\n`;
                    break;
                case 'opOnion':
                    code += generateExportNodeCode(child, transformedPoint);
                    code += `    float ${varName} = abs(${childVar}) - ${params.shellThickness.toFixed(3)};\n`;
                    break;
                case 'opTwist': {
                    const warpPoint = `${varName}_warp`;
                    const angleVar = `${varName}_angle`;
                    const matVar = `${varName}_mat`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    float ${angleVar} = ${params.twistAmount.toFixed(3)} * ${warpPoint}.y;\n`;
                    code += `    mat2 ${matVar} = mat2(cos(${angleVar}), -sin(${angleVar}), sin(${angleVar}), cos(${angleVar}));\n`;
                    code += `    ${warpPoint}.xz = ${matVar} * ${warpPoint}.xz;\n`;
                    code += generateExportNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
                case 'opElongate': {
                    const qVar = `${varName}_q`;
                    const clampVar = `${varName}_clamped`;
                    code += `    vec3 ${qVar} = abs(${transformedPoint}) - vec3(${params.extentX.toFixed(3)}, ${params.extentY.toFixed(3)}, ${params.extentZ.toFixed(3)});\n`;
                    code += `    vec3 ${clampVar} = max(${qVar}, vec3(0.0));\n`;
                    code += generateExportNodeCode(child, clampVar);
                    code += `    float ${varName} = ${childVar} + min(max(${qVar}.x, max(${qVar}.y, ${qVar}.z)), 0.0);\n`;
                    break;
                }
                case 'opCheapBend': {
                    const warpPoint = `${varName}_warp`;
                    const angleVar = `${varName}_angle`;
                    const matVar = `${varName}_mat`;
                    const rotated = `${varName}_rot`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    float ${angleVar} = ${params.bendAmount.toFixed(3)} * ${warpPoint}.x;\n`;
                    code += `    mat2 ${matVar} = mat2(cos(${angleVar}), -sin(${angleVar}), sin(${angleVar}), cos(${angleVar}));\n`;
                    code += `    vec2 ${rotated} = ${matVar} * ${warpPoint}.xy;\n`;
                    code += `    ${warpPoint}.xy = ${rotated};\n`;
                    code += generateExportNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
                case 'opSymX': {
                    const warpPoint = `${varName}_warp`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    ${warpPoint}.x = abs(${warpPoint}.x);\n`;
                    code += generateExportNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
            }
        }
    }
    
    code += `    ${varName} *= ${scaleVar};\n`;
    
    return code;
}

// ===========================================
// PREVIEW GLSL - Uniform-based (for live edit)
// ===========================================
function generatePreviewGLSL() {
    const t0 = perfNow();
    const sceneNode = document.getElementById('scene');
    const children = getNodeChildren(sceneNode);
    
    let code = getSDFPreamble();
    
    // Generate uniform declarations
    code += '\n// Node uniforms\n';
    traverseSceneNodes(node => {
        const prefix = getNodeVarName(node);
        const nodeType = node.dataset.type;
        const typeDef = NODE_TYPES[nodeType];
        
        code += `uniform vec3 ${prefix}_pos;\n`;
        code += `uniform vec3 ${prefix}_rot;\n`;
        code += `uniform float ${prefix}_scale;\n`;
        
        if (typeDef.params) {
            for (const key of Object.keys(typeDef.params)) {
                code += `uniform float ${prefix}_${key};\n`;
            }
        }
    });
    
    code += '\n';
    
    if (children.length === 0) {
        code += `float sceneSDF(vec3 p) {
    return 1000.0; // Empty scene
}`;
    } else if (children.length === 1) {
        code += `
float sceneSDF(vec3 p) {
${generatePreviewNodeCode(children[0], 'p')}
    return ${getNodeVarName(children[0])};
}`;
    } else {
        let nodeCode = '';
        children.forEach(child => {
            nodeCode += generatePreviewNodeCode(child, 'p');
        });
        
        let unionExpr = getNodeVarName(children[0]);
        for (let i = 1; i < children.length; i++) {
            unionExpr = `min(${unionExpr}, ${getNodeVarName(children[i])})`;
        }
        
        code += `
float sceneSDF(vec3 p) {
${nodeCode}
    return ${unionExpr};
}`;
    }
    
    const stats = getSceneStats();
    perfLogDuration('generatePreviewGLSL', t0, `nodes=${stats.nodeCount} depth=${stats.maxDepth}`);
    return code;
}

function getPrimitiveDistanceExpr(nodeType, pointVar, params) {
    switch (nodeType) {
        case 'Sphere':
            return `sdSphere(${pointVar}, ${Number(params.radius ?? 0.5).toFixed(3)})`;
        case 'Box':
            return `sdBox(${pointVar}, vec3(${Number(params.sizeX ?? 0.5).toFixed(3)}, ${Number(params.sizeY ?? 0.5).toFixed(3)}, ${Number(params.sizeZ ?? 0.5).toFixed(3)}))`;
        case 'Torus':
            return `sdTorus(${pointVar}, vec2(${Number(params.majorRadius ?? 0.5).toFixed(3)}, ${Number(params.minorRadius ?? 0.2).toFixed(3)}))`;
        case 'Cylinder':
            return `sdCylinder(${pointVar}, ${Number(params.radius ?? 0.3).toFixed(3)}, ${Number(params.height ?? 1.0).toFixed(3)})`;
        case 'Plane':
            return `sdPlane(${pointVar}, ${Number(params.height ?? 0.0).toFixed(3)})`;
        case 'Pyramid':
            return `sdPyramid(${pointVar}, ${Number(params.height ?? 1.0).toFixed(3)})`;
        case 'VesicaSegment': {
            const ax = Number(params.ax ?? -0.5).toFixed(3);
            const ay = Number(params.ay ?? 0.0).toFixed(3);
            const az = Number(params.az ?? 0.0).toFixed(3);
            const bx = Number(params.bx ?? 0.5).toFixed(3);
            const by = Number(params.by ?? 0.0).toFixed(3);
            const bz = Number(params.bz ?? 0.0).toFixed(3);
            const width = Number(params.width ?? 0.25).toFixed(3);
            return `sdVesicaSegment(${pointVar}, vec3(${ax}, ${ay}, ${az}), vec3(${bx}, ${by}, ${bz}), ${width})`;
        }
        default:
            return '1000.0';
    }
}

function getPrimitiveBoundExpr(nodeType, params) {
    switch (nodeType) {
        case 'Sphere':
            return `${Number(params.radius ?? 0.5).toFixed(3)}`;
        case 'Box': {
            const sx = Number(params.sizeX ?? 0.5);
            const sy = Number(params.sizeY ?? 0.5);
            const sz = Number(params.sizeZ ?? 0.5);
            const diag = Math.sqrt(sx * sx + sy * sy + sz * sz);
            return `${diag.toFixed(3)}`;
        }
        case 'Torus': {
            const major = Number(params.majorRadius ?? 0.5);
            const minor = Number(params.minorRadius ?? 0.2);
            return `${(major + minor).toFixed(3)}`;
        }
        case 'Cylinder': {
            const r = Number(params.radius ?? 0.3);
            const h = Number(params.height ?? 1.0);
            return `${Math.sqrt(r * r + h * h).toFixed(3)}`;
        }
        case 'Pyramid':
            return `${Number(params.height ?? 1.0).toFixed(3)}`;
        case 'VesicaSegment': {
            const ax = Number(params.ax ?? -0.5);
            const ay = Number(params.ay ?? 0.0);
            const az = Number(params.az ?? 0.0);
            const bx = Number(params.bx ?? 0.5);
            const by = Number(params.by ?? 0.0);
            const bz = Number(params.bz ?? 0.0);
            const width = Number(params.width ?? 0.25);
            const length = Math.sqrt(
                Math.pow(bx - ax, 2) + Math.pow(by - ay, 2) + Math.pow(bz - az, 2)
            );
            return `${(0.5 * length + width).toFixed(3)}`;
        }
        default:
            return null;
    }
}

function generatePreviewNodeCode(node, pointVar) {
    const nodeType = node.dataset.type;
    const varName = getNodeVarName(node);
    const prefix = varName;
    const typeDef = NODE_TYPES[nodeType];
    
    let code = '';
    const transformedPoint = varName + '_p';
    const scaleVar = `${varName}_scale`;
    
    code += `    vec3 ${transformedPoint} = ${pointVar};\n`;
    code += `    ${transformedPoint} -= ${prefix}_pos;\n`;
    code += `    ${transformedPoint} *= rotateX(${prefix}_rot.x);\n`;
    code += `    ${transformedPoint} *= rotateY(${prefix}_rot.y);\n`;
    code += `    ${transformedPoint} *= rotateZ(${prefix}_rot.z);\n`;
    code += `    float ${scaleVar} = max(${prefix}_scale, 0.0001);\n`;
    code += `    ${transformedPoint} /= ${scaleVar};\n`;
    
    if (typeDef.category === 'primitive') {
        switch (nodeType) {
            case 'Sphere':
                code += `    float ${varName} = sdSphere(${transformedPoint}, ${prefix}_radius);\n`;
                break;
            case 'Box':
                code += `    float ${varName} = sdBox(${transformedPoint}, vec3(${prefix}_sizeX, ${prefix}_sizeY, ${prefix}_sizeZ));\n`;
                break;
            case 'Torus':
                code += `    float ${varName} = sdTorus(${transformedPoint}, vec2(${prefix}_majorRadius, ${prefix}_minorRadius));\n`;
                break;
            case 'Cylinder':
                code += `    float ${varName} = sdCylinder(${transformedPoint}, ${prefix}_radius, ${prefix}_height);\n`;
                break;
            case 'Plane':
                code += `    float ${varName} = sdPlane(${transformedPoint}, ${prefix}_height);\n`;
                break;
            case 'Pyramid':
                code += `    float ${varName} = sdPyramid(${transformedPoint}, ${prefix}_height);\n`;
                break;
            case 'VesicaSegment':
                code += `    float ${varName} = sdVesicaSegment(${transformedPoint}, vec3(${prefix}_ax, ${prefix}_ay, ${prefix}_az), vec3(${prefix}_bx, ${prefix}_by, ${prefix}_bz), ${prefix}_width);\n`;
                break;
        }
    } else if (typeDef.category === 'operation') {
        const children = getNodeChildren(node);
        
        if (children.length < 2) {
            code += `    float ${varName} = 1000.0; // Incomplete operation\n`;
        } else {
            code += generatePreviewNodeCode(children[0], transformedPoint);
            code += generatePreviewNodeCode(children[1], transformedPoint);
            
            const child1Var = getNodeVarName(children[0]);
            const child2Var = getNodeVarName(children[1]);
            
            switch (nodeType) {
                case 'opUnion':
                    code += `    float ${varName} = min(${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothUnion':
                    code += `    float ${varName} = opSmoothUnion(${child1Var}, ${child2Var}, ${prefix}_k);\n`;
                    break;
                case 'opSubtraction':
                    code += `    float ${varName} = max(-${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothSubtraction':
                    code += `    float ${varName} = opSmoothSubtraction(${child1Var}, ${child2Var}, ${prefix}_k);\n`;
                    break;
                case 'opIntersection':
                    code += `    float ${varName} = max(${child1Var}, ${child2Var});\n`;
                    break;
                case 'opSmoothIntersection':
                    code += `    float ${varName} = opSmoothIntersection(${child1Var}, ${child2Var}, ${prefix}_k);\n`;
                    break;
                case 'opXor':
                    code += `    float ${varName} = opXor(${child1Var}, ${child2Var});\n`;
                    break;
        }
    }
    } else if (typeDef.category === 'modifier') {
        const children = getNodeChildren(node);
        if (children.length < 1) {
            code += `    float ${varName} = 1000.0; // Incomplete modifier\n`;
        } else {
            const child = children[0];
            const childVar = getNodeVarName(child);
            switch (nodeType) {
                case 'opRound':
                    code += generatePreviewNodeCode(child, transformedPoint);
                    code += `    float ${varName} = ${childVar} - ${prefix}_roundRadius;\n`;
                    break;
                case 'opOnion':
                    code += generatePreviewNodeCode(child, transformedPoint);
                    code += `    float ${varName} = abs(${childVar}) - ${prefix}_shellThickness;\n`;
                    break;
                case 'opTwist': {
                    const warpPoint = `${varName}_warp`;
                    const angleVar = `${varName}_angle`;
                    const matVar = `${varName}_mat`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    float ${angleVar} = ${prefix}_twistAmount * ${warpPoint}.y;\n`;
                    code += `    mat2 ${matVar} = mat2(cos(${angleVar}), -sin(${angleVar}), sin(${angleVar}), cos(${angleVar}));\n`;
                    code += `    ${warpPoint}.xz = ${matVar} * ${warpPoint}.xz;\n`;
                    code += generatePreviewNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
                case 'opElongate': {
                    const qVar = `${varName}_q`;
                    const clampVar = `${varName}_clamped`;
                    code += `    vec3 ${qVar} = abs(${transformedPoint}) - vec3(${prefix}_extentX, ${prefix}_extentY, ${prefix}_extentZ);\n`;
                    code += `    vec3 ${clampVar} = max(${qVar}, vec3(0.0));\n`;
                    code += generatePreviewNodeCode(child, clampVar);
                    code += `    float ${varName} = ${childVar} + min(max(${qVar}.x, max(${qVar}.y, ${qVar}.z)), 0.0);\n`;
                    break;
                }
                case 'opCheapBend': {
                    const warpPoint = `${varName}_warp`;
                    const angleVar = `${varName}_angle`;
                    const matVar = `${varName}_mat`;
                    const rotated = `${varName}_rot`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    float ${angleVar} = ${prefix}_bendAmount * ${warpPoint}.x;\n`;
                    code += `    mat2 ${matVar} = mat2(cos(${angleVar}), -sin(${angleVar}), sin(${angleVar}), cos(${angleVar}));\n`;
                    code += `    vec2 ${rotated} = ${matVar} * ${warpPoint}.xy;\n`;
                    code += `    ${warpPoint}.xy = ${rotated};\n`;
                    code += generatePreviewNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
                case 'opSymX': {
                    const warpPoint = `${varName}_warp`;
                    code += `    vec3 ${warpPoint} = ${transformedPoint};\n`;
                    code += `    ${warpPoint}.x = abs(${warpPoint}.x);\n`;
                    code += generatePreviewNodeCode(child, warpPoint);
                    code += `    float ${varName} = ${childVar};\n`;
                    break;
                }
            }
        }
    }
    
    code += `    ${varName} *= ${scaleVar};\n`;
    
    return code;
}

function getSDFPreamble() {
    return `// SDF Primitives and Operations
float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float sdCylinder(vec3 p, float r, float h) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float sdPlane(vec3 p, float h) {
    return p.y - h;
}

float sdPyramid(vec3 p, float h) {
    float m2 = h * h + 0.25;
    p.xz = abs(p.xz);
    if (p.z > p.x) {
        p.xz = p.zx;
    }
    p.xz -= vec2(0.5);
    vec3 q = vec3(p.z, h * p.y - 0.5 * p.x, h * p.x + 0.5 * p.y);
    float s = max(-q.x, 0.0);
    float t = clamp((q.y - 0.5 * p.z) / (m2 + 0.25), 0.0, 1.0);
    float a = m2 * (q.x + s) * (q.x + s) + q.y * q.y;
    float b = m2 * (q.x + 0.5 * t) * (q.x + 0.5 * t) + (q.y - m2 * t) * (q.y - m2 * t);
    float d2 = (min(q.y, -q.x * m2 - 0.5 * q.y) > 0.0) ? 0.0 : min(a, b);
    return sqrt((d2 + q.z * q.z) / m2) * sign(max(q.z, -p.y));
}

float sdVesicaSegment(vec3 p, vec3 a, vec3 b, float w) {
    vec3 c = (a + b) * 0.5;
    vec3 ba = b - a;
    float l = length(ba);
    vec3 v = ba / max(l, 0.0001);
    vec3 rel = p - c;
    float y = dot(rel, v);
    vec2 q = vec2(length(rel - y * v), abs(y));
    float r = 0.5 * l;
    float ww = max(w, 0.0001);
    float d = 0.5 * (r * r - ww * ww) / ww;
    vec3 h = (r * q.x < d * (q.y - r)) ? vec3(0.0, r, 0.0) : vec3(-d, 0.0, d + ww);
    return length(q - h.xy) - h.z;
}

float opSmoothUnion(float d1, float d2, float k) {
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) - k * h * (1.0 - h);
}

float opSmoothSubtraction(float d1, float d2, float k) {
    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);
    return mix(d2, -d1, h) + k * h * (1.0 - h);
}

float opSmoothIntersection(float d1, float d2, float k) {
    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) + k * h * (1.0 - h);
}

float opXor(float d1, float d2) {
    return max(min(d1, d2), -max(d1, d2));
}

mat3 rotateX(float a) {
    float c = cos(a), s = sin(a);
    return mat3(1, 0, 0, 0, c, -s, 0, s, c);
}

mat3 rotateY(float a) {
    float c = cos(a), s = sin(a);
    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);
}

mat3 rotateZ(float a) {
    float c = cos(a), s = sin(a);
    return mat3(c, -s, 0, s, c, 0, 0, 0, 1);
}

`;
}

// ===========================================
// WebGL
// ===========================================
function initWebGL() {
    const canvas = document.getElementById('glCanvas');
    gl = canvas.getContext('webgl');
    
    if (!gl) {
        console.error('WebGL not supported');
        return;
    }
    
    // Create vertex buffer once
    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
}

function createShaderProgram(sdfCode) {
    const t0 = perfNow();
    const vertexShaderSource = `
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    `;
    
    const fragmentShaderSource = `
        precision highp float;
        uniform vec2 resolution;
        uniform float time;
        uniform vec3 u_cameraPos;
        uniform vec3 u_cameraTarget;
        
        ${sdfCode}
        
        vec3 computeRayDirection(vec2 uv) {
            vec3 forward = normalize(u_cameraTarget - u_cameraPos);
            vec3 worldUp = vec3(0.0, 1.0, 0.0);
            vec3 right = normalize(cross(forward, worldUp));
            if (length(right) < 0.001) {
                right = vec3(1.0, 0.0, 0.0);
            }
            vec3 up = normalize(cross(right, forward));
            return normalize(forward + uv.x * right + uv.y * up);
        }
        
        vec3 calcNormal(vec3 p) {
            vec2 e = vec2(0.001, 0.0);
            return normalize(vec3(
                sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),
                sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),
                sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)
            ));
        }
        
        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * resolution) / resolution.y;
            
            vec3 ro = u_cameraPos;
            vec3 rd = computeRayDirection(uv);
            
            float t = 0.0;
            vec3 col = vec3(1.0);
            
            for (int i = 0; i < 100; i++) {
                vec3 p = ro + rd * t;
                float d = sceneSDF(p);
                
                if (d < 0.001) {
                    vec3 n = calcNormal(p);
                    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                    float diff = max(dot(n, lightDir), 0.0);
                    float amb = 0.3;
                    col = vec3(0.85, 0.75, 0.7) * (diff + amb);
                    break;
                }
                
                if (t > 20.0) break;
                t += d;
            }
            
            gl_FragColor = vec4(col, 1.0);
        }
    `;
    
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);
    
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        console.error('Vertex shader error:', gl.getShaderInfoLog(vertexShader));
        return null;
    }
    
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);
    
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        console.error('Fragment shader error:', gl.getShaderInfoLog(fragmentShader));
        return null;
    }
    
    const prog = gl.createProgram();
    gl.attachShader(prog, vertexShader);
    gl.attachShader(prog, fragmentShader);
    gl.linkProgram(prog);
    
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(prog));
        return null;
    }
    
    cameraUniformLocations.pos = gl.getUniformLocation(prog, 'u_cameraPos');
    cameraUniformLocations.target = gl.getUniformLocation(prog, 'u_cameraTarget');
    
    perfLogDuration('createShaderProgram', t0);
    return prog;
}

function cacheUniformLocations() {
    const t0 = perfNow();
    let uniformCount = 0;
    uniformLocations = {};
    
    traverseSceneNodes(node => {
        const prefix = getNodeVarName(node);
        const nodeType = node.dataset.type;
        const typeDef = NODE_TYPES[nodeType];
        
        uniformLocations[`${prefix}_pos`] = gl.getUniformLocation(program, `${prefix}_pos`);
        uniformLocations[`${prefix}_rot`] = gl.getUniformLocation(program, `${prefix}_rot`);
        uniformLocations[`${prefix}_scale`] = gl.getUniformLocation(program, `${prefix}_scale`);
        uniformCount += 3;
        
        if (typeDef.params) {
            for (const key of Object.keys(typeDef.params)) {
                uniformLocations[`${prefix}_${key}`] = gl.getUniformLocation(program, `${prefix}_${key}`);
                uniformCount++;
            }
        }
    });
    
    perfLogDuration('cacheUniformLocations', t0, `uniforms=${uniformCount}`);
}

function updatePreviewUniforms() {
    if (!gl || !program) return;
    const t0 = perfNow();
    let uniformUpdates = 0;
    
    updateCameraUniforms();

    // Update export code display if visible
    if (codeOutput.style.display === 'block') {
        codeOutputContent.textContent = generateExportGLSL();
    }
    
    gl.useProgram(program);
    
    traverseSceneNodes(node => {
        const prefix = getNodeVarName(node);
        const params = getNodeParams(node);
        const nodeType = node.dataset.type;
        const typeDef = NODE_TYPES[nodeType];
        
        // Set transform uniforms
        const posLoc = uniformLocations[`${prefix}_pos`];
        if (posLoc) {
            gl.uniform3f(posLoc, params.posX, params.posY, params.posZ);
            uniformUpdates++;
        }
        
        const rotLoc = uniformLocations[`${prefix}_rot`];
        if (rotLoc) {
            const rad = Math.PI / 180;
            gl.uniform3f(rotLoc, params.rotX * rad, params.rotY * rad, params.rotZ * rad);
            uniformUpdates++;
        }
        
        const scaleLoc = uniformLocations[`${prefix}_scale`];
        if (scaleLoc) {
            gl.uniform1f(scaleLoc, params.scale);
            uniformUpdates++;
        }
        
        // Set type-specific uniforms
        if (typeDef.params) {
            for (const key of Object.keys(typeDef.params)) {
                const loc = uniformLocations[`${prefix}_${key}`];
                if (loc) {
                    gl.uniform1f(loc, params[key]);
                    uniformUpdates++;
                }
            }
        }
    });
    
    const uniformsEnd = perfLogDuration('updatePreviewUniforms', t0, `updates=${uniformUpdates}`);
    renderPreview(uniformsEnd);
}

function renderPreview(prevTimestamp) {
    if (!gl || !program) return;
    const t0 = perfNow();
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    const renderEnd = perfLogDuration('renderPreview', t0);
    if (typeof prevTimestamp === 'number') {
        const total = renderEnd - prevTimestamp + (prevTimestamp - t0);
        console.log(`[SDFperf] uniforms+render total: ${total.toFixed(2)}ms`);
    }
}

function recompilePreview() {
    if (!gl) return;
    const t0 = perfNow();
    
    const previewGLSL = generatePreviewGLSL();
    
    // Update export code display if visible
    if (codeOutput.style.display === 'block') {
        codeOutputContent.textContent = generateExportGLSL();
    }
    
    if (program) {
        gl.deleteProgram(program);
    }
    
    program = createShaderProgram(previewGLSL);
    if (!program) return;
    
    gl.useProgram(program);
    
    // Setup vertex attributes
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    const positionAttrib = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(positionAttrib);
    gl.vertexAttribPointer(positionAttrib, 2, gl.FLOAT, false, 0, 0);
    
    // Set resolution uniform
    const resolutionUniform = gl.getUniformLocation(program, 'resolution');
    gl.uniform2f(resolutionUniform, gl.canvas.width, gl.canvas.height);
    
    // Cache uniform locations and update values
    cacheUniformLocations();
    updatePreviewUniforms();
    
    const stats = getSceneStats();
    perfLogDuration('recompilePreview', t0, `nodes=${stats.nodeCount} depth=${stats.maxDepth}`);
}

function renderPreview() {
    if (!gl || !program) return;
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

init();
</script>
</body>
</html>